<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apuntadores Planos</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a class='active' href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Apuntadores Planos</h1>
    <p>Rust posee un numero de tipos apuntadores inteligentes en su biblioteca estándar, pero hay dos tipos que son extra especiales. Gran parte de la seguridad de Rust proviene de sus chequeos en tiempo de compilación, pero los apuntadores planos no poseen dichas garantías, y se consideran <a href="unsafe.html">inseguros (unsafe)</a> de usar.</p>

<p><code>*const T</code> y <code>*mut T</code> son denominados ‘apuntadores planos’ (‘raw pointers’) en Rust. Algunas veces, cuando se escriben cierto tipo de bibliotecas, es necesario saltar las garantías de seguridad de Rust por alguna razón. En este caso, se puede hacer uso de los apuntadores planos para implementar tu biblioteca, exponiendo una interfaz segura a tus usuarios. Por ejemplo, los apuntadores <code>*</code> tienen permitido establecer aliasing (dos o mas apuntadores a la misma data), permitiéndoles ser usados en la escritura de tipos con pertenencia compartida, e incluso tipos thread safe de memoria compartida (Los tipos <code>Rc&lt;T&gt;</code> y <code>Arc&lt;T&gt;</code> están implementados en su totalidad en Rust).</p>

<p>A continuación se listan algunas características a tener presentes acerca de los apuntadores planos las cuales son diferentes de los demás tipos de apuntadores. Ellos:</p>

<ul>
<li>no garantizan a apuntar a memoria valida y no garantizan ser no-nulos (a diferencia de <code>Box</code> y <code>&amp;</code>);</li>
<li>no poseen ningún tipo de limpieza automática, a diferencia de <code>Box</code>,por lo que requieren manejo manual de recursos;</li>
<li>son data pura, esto es, no mueven pertenencia, otra vez y a diferencia de <code>Box</code>, en consecuencia el compilador de Rust no puede proteger de bugs como uso-despues-de-liberacion (use-after-free);</li>
<li>carecen de cualquier forma de tiempos de vida, a diferencia de <code>&amp;</code>, y es por ello que el compilador no puede razonar acerca de apuntadores colgantes; y no proveen mas garantías acerca de aliasing o mutabilidad que no sean diferentes a no tener permitido hacerlo a través de un <code>*const T</code>.</li>
</ul>

<h1 id='bases' class='section-header'><a href='#bases'>Bases</a></h1>
<p>Crear un apuntador plano es perfectamente seguro:</p>
<span class='rusttest'>fn main() {
    let x = 5;
    let plano = &amp;x as *const i32;
    
    let mut y = 10;
    let plano_mut = &amp;mut y as *mut i32;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>plano</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;
<span class='kw'>let</span> <span class='ident'>plano_mut</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>i32</span>;</pre>

<p>Sin embargo, dereferenciar uno no lo es. Lo siguiente no funciona:</p>
<span class='rusttest'>fn main() {
    let x = 5;
    let plano = &amp;x as *const i32;
    
    println!(&quot;plano apunta a {}&quot;, *plano);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>plano</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;plano apunta a {}&quot;</span>, <span class='op'>*</span><span class='ident'>plano</span>);</pre>

<p>Con este error:</p>

<pre><code class="language-text">error: dereference of raw pointer requires unsafe function or block [E0133]
     println!(&quot;plano apunta a {}&quot;, *plano);
                                  ^~~~
</code></pre>

<p>Cuando dereferencias un apuntador plano, asumes la responsabilidad de que este no apunte a ningún lugar incorrecto. Por ello necesitas <code>unsafe</code>:</p>
<span class='rusttest'>fn main() {
    let x = 5;
    let plano = &amp;x as *const i32;
    
    let apunta_a = unsafe { *plano };
    
    println!(&quot;plano apunta a {}&quot;, apunta_a);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>plano</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>;

<span class='kw'>let</span> <span class='ident'>apunta_a</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='op'>*</span><span class='ident'>plano</span> };

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;plano apunta a {}&quot;</span>, <span class='ident'>apunta_a</span>);</pre>

<p>Para mayor información acerca de apuntadores planos, véase <a href="../std/primitive.pointer.html">la documentación de su API</a>.</p>

<h1 id='ffi' class='section-header'><a href='#ffi'>FFI</a></h1>
<p>Los apuntadores planos son útiles para efectuar FFI: Los <code>*const T</code> y <code>*mut T</code> de Rust son similares a <code>const T*</code> y <code>T*</code> en C, respectivamente. Para mas información acerca de este uso, consulta el <a href="ffi.html">capitulo de FFI</a>.</p>

<h1 id='referencias-y-apuntadores-planos' class='section-header'><a href='#referencias-y-apuntadores-planos'>Referencias y apuntadores planos</a></h1>
<p>En tiempo de ejecución, un apuntador plano <code>*</code> y una referencia apuntando a la misma sección de data poseen una representación idéntica. En efecto, una referencia <code>&amp;T</code> hará implícitamente coercion a un apuntador plano <code>*const T</code> en código seguro y de manera similar para las variantes <code>mut</code> (ambas coerciones pueden ser respectivamente llevadas acabo de manera explicita con, <code>valor as *const T</code> and <code>value as *mut T</code>).</p>

<p>Ir en sentido opuesto, de una <code>*const</code> a una referencia <code>&amp;</code>, no es seguro. Un <code>&amp;T</code> es siempre valido, entonces, como mínimo, el apuntador plano <code>*const T</code> debe apuntar a una instancia valida de tipo <code>T</code>. Aun mas, el apuntador resultante debe satisfacer las leyes de las referencias acerca de mutabilidad y aliasing . El compilador asume que dichas propiedades son ciertas para cualquier referencia, sin importar como haya sido creada, y en consecuencia cualquier conversión desde un apuntador plano es una aserción de estas se mantienen. El programador <em>debe</em> garantizar lo anterior.</p>

<p>El método recomendado de conversión es:</p>
<span class='rusttest'>fn main() {
    // conversion explicita
    let i: u32 = 1;
    let p_imm: *const u32 = &amp;i as *const u32;
    
    // coercion implicita
    let mut m: u32 = 2;
    let p_mut: *mut u32 = &amp;mut m;
    
    unsafe {
        let ref_imm: &amp;u32 = &amp;*p_imm;
        let ref_mut: &amp;mut u32 = &amp;mut *p_mut;
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// conversion explicita</span>
<span class='kw'>let</span> <span class='ident'>i</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>p_imm</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>i</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span>;

<span class='comment'>// coercion implicita</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>m</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>2</span>;
<span class='kw'>let</span> <span class='ident'>p_mut</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>m</span>;

<span class='kw'>unsafe</span> {
    <span class='kw'>let</span> <span class='ident'>ref_imm</span>: <span class='kw-2'>&amp;</span><span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>p_imm</span>;
    <span class='kw'>let</span> <span class='ident'>ref_mut</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='ident'>p_mut</span>;
}</pre>

<p>El estilo de dereferencia <code>&amp;*x</code> es preferido por encima del uso de <code>transmute</code>. Este ultimo es mucho mas poderoso de lo necesario, y la operación mas restrictiva es difícil de usar de manera incorrecta: por ejemplo, requiere que <code>x</code> sea un apuntador (a diferencia de <code>transmute</code>).</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
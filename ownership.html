<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Pertenencia</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a class='active' href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Pertenencia</h1>
    <p>Esta guía es una de las tres presentando el sistema de pertenencia de Rust. Este es una de las características mas únicas e irresistibles de Rust, con la que desarrolladores Rust deben estar familiarizados. A través de la pertenencia es como Rust logra su objetivo mas importante, la seguridad. Existen unos pocos conceptos distintos, cada uno con su propio capitulo:</p>

<ul>
<li>pertenencia, la que lees actualmente</li>
<li><a href="references-and-borrowing.html">préstamo</a>, y su característica asociada ‘referencias’</li>
<li><a href="lifetimes.html">tiempo de vida</a>, un concepto avanzado del préstamo</li>
</ul>

<p>Estos tres capítulos están relacionados, en orden. Necesitaras los tres para entender completamente el sistema de pertenencia de Rust.</p>

<h1 id='meta' class='section-header'><a href='#meta'>Meta</a></h1>
<p>Antes de entrar en detalle, dos notas importantes acerca del sistema de pertenencia.</p>

<p>Rust tiene foco en seguridad y velocidad. Rust logra esos objetivos a travez de muchas ‘abstracciones de cero costo’, lo que significa que en Rust, las abstracciones cuestan tan poco como sea posible para hacerlas funcionar. El sistema de pertenencia es un ejemplo primordial de una abstracción de cero costo. Todo el análisis del que estaremos hablando en la presente guía es <em>llevado a cabo en tiempo de compilación</em>. No pagas ningún costo en tiempo de ejecución por ninguna de estas facilidades.</p>

<p>Sin embargo, este sistema tiene cierto costo: la curva de aprendizaje. Muchos usuarios nuevos Rust experimentan algo que nosotros denominamos ‘pelear con el comprobador de préstamo’ (‘fighting with the borrow checker’), situación en la cual el compilador de Rust se rehusa a compilar un programa el cual el autor piensa valido. Esto ocurre con frecuencia debido a que el modelo mental del programador acerca de como funciona la pertenencia no concuerda con las reglas actuales implementadas en Rust. Probablemente tu experimentes cosas similares al comienzo. Sin embargo, hay buenas noticias: otros desarrolladores Rust experimentados  reportan que una vez que trabajan con las reglas del sistema de pertenencia por un periodo de tiempo, pelean cada vez menos con el comprobador de préstamo.</p>

<p>Con eso en mente, aprendamos acerca de la pertenencia.</p>

<h1 id='pertenencia' class='section-header'><a href='#pertenencia'>Pertenencia</a></h1>
<p>Los <a href="variable-bindings.html">Bindings a variable</a> poseen una propiedad en Rust: Estos ‘poseen pertenencia’ sobre lo que están asociados. Lo que se traduce a que cuando un binding a variable sale de ámbito, Rust libera los recursos asociados a este. Por ejemplo:</p>
<span class='rusttest'>fn main() {
    fn foo() {
        let v = vec![1, 2, 3];
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
}</pre>

<p>Cuando <code>v</code> entra en ámbito, un nuevo <a href="../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> es creado. En este caso el vector también asigna algo de memoria desde el <a href="the-stack-and-the-heap.html">montículo</a>, para los tres elementos. Cuando <code>v</code> sale de ámbito al final de <code>foo()</code>, Rust limpiara todo lo relacionado al vector, incluyendo la memoria asignada desde el montículo. Esto ocurre de manera determinista, al final de el ámbito.</p>

<h1 id='semantica-de-movimiento' class='section-header'><a href='#semantica-de-movimiento'>Semantica de movimiento</a></h1>
<p>Hay algo mas sutil acá, Rust se asegura que solo exista <em>exactamente un</em> binding a cualquier recurso en particular. Por ejemplo, si tenemos un vector, podemos asignarlo a otro binding a variable:</p>
<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];
    
    let v2 = v;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;</pre>

<p>Pero, si intentamos usar <code>v</code> después, obtenemos un error:</p>
<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];
    
    let v2 = v;
    
    println!(&quot;v[0] es: {}&quot;, v[0]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;v[0] es: {}&quot;</span>, <span class='ident'>v</span>[<span class='number'>0</span>]);</pre>

<p>El error luce como este:</p>

<pre><code class="language-text">error: use of moved value: `v` (uso de valor movido: `v`)
println!(&quot;v[0] es: {}&quot;, v[0]);
                        ^
</code></pre>

<p>Algo similar ocurre si definimos una función que tome pertenencia, y tratamos de usar algo después de habérselo pasado como argumento:</p>
<span class='rusttest'>fn main() {
    fn tomar(v: Vec&lt;i32&gt;) {
        // lo que sucede acá no es relevante
    }
    
    let v = vec![1, 2, 3];
    
    tomar(v);
    
    println!(&quot;v[0] es: {}&quot;, v[0]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>tomar</span>(<span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) {
    <span class='comment'>// lo que sucede acá no es relevante</span>
}

<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='ident'>tomar</span>(<span class='ident'>v</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;v[0] es: {}&quot;</span>, <span class='ident'>v</span>[<span class='number'>0</span>]);</pre>

<p>El mismo error: ‘use of moved value’ (uso de valor movido). Cuando transferimos la pertenencia a algo, decimos que hemos ‘movido’ la cosa a la cual nos estamos refiriendo. No necesitas ningún tipo de anotación especial para ello, es lo que Rust hace por defecto.</p>

<h2 id='los-detalles' class='section-header'><a href='#los-detalles'>Los detalles</a></h2>
<p>La razón por la cual no podemos usar un binding a variable después de haberlo movido es sutil, pero importante. Cuando escribimos código como este:</p>
<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];
    
    let v2 = v;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;</pre>

<p>La primera linea asigna memoria para el objeto vector, <code>v</code>, y para la data que contiene. El objeto vector es entonces almacenado en la pila <a href="the-stack-and-the-heap.html">pila</a> y contiene un apuntador a el contenido (<code>[1, 2, 3]</code>) almacenado en el <a href="the-stack-and-the-heap.html">monticulo</a>. Cuando movemos <code>v</code> a <code>v2</code>, se crea una copia de dicho apuntador para <code>v2</code>. Todo esto significa que existirían dos apuntadores para el contenido del vector en el montículo. Lo cual viola las garantías de seguridad de Rust, introduciendo una condición de carrera. Es por ello que Rust prohibe el uso de <code>v</code> después que el movimiento ha sido llevado a cabo.</p>

<p>Es importante destacar que algunas optimizaciones podrían remover la copia de los bytes en la pila, dependiendo de ciertas circunstancias. Así que puede no ser tan ineficiente a como luce inicialmente.</p>

<h2 id='tipos-copy' class='section-header'><a href='#tipos-copy'>Tipos <code>Copy</code></a></h2>
<p>Hemos establecido que cuando transferimos la pertenencia a otro binding a variable, no podemos usar el binding original. Sin embargo, existe un trait <a href="traits.html">trait</a> que cambia este comportamiento, se llama <code>Copy</code>. No hemos discutido los traits (rasgos) todavía, pero por ahora puedes verlos como una anotación hecha a un tipo en particular la cual agrega comportamiento extra. Por ejemplo:</p>
<span class='rusttest'>fn main() {
    let v = 1;
    
    let v2 = v;
    
    println!(&quot;v es: {}&quot;, v);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;v es: {}&quot;</span>, <span class='ident'>v</span>);</pre>

<p>En este caso, <code>v</code> es un <code>i32</code>, que implementa el trait <code>Copy</code>. Esto significa que, justo como en un movimiento, cuando asignamos <code>v</code> a <code>v2</code>, una copia de la data es hecha. Pero, a diferencia de lo que ocurre en un movimiento, podemos hacer uso de <code>v</code> después. Esto es debido a que un <code>i32</code> no posee apuntadores a data en ningún otro lugar, copiarlos significa copiado completo.</p>

<p>Todos los tipos primitivos implementan el trait <code>Copy</code> y su pertenencia no es movida como uno podría asumir, siguiendo las <code>reglas de pertenencia</code>. Como ejemplo, los siguientes dos pedazos de código solo compilan porque los tipos <code>i32</code> y <code>bool</code> implementan el trait <code>Copy</code>.</p>
<span class='rusttest'>fn main() {
    let a = 5;

    let _y = doblar(a);
    println!(&quot;{}&quot;, a);
}

fn doblar(x: i32) -&gt; i32 {
    x * 2
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='kw'>let</span> <span class='ident'>_y</span> <span class='op'>=</span> <span class='ident'>doblar</span>(<span class='ident'>a</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}

<span class='kw'>fn</span> <span class='ident'>doblar</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>2</span>
}</pre>
<span class='rusttest'>fn main() {
    let a = true;

    let _y = cambiar_verdad(a);
    println!(&quot;{}&quot;, a);
}

fn cambiar_verdad(x: bool) -&gt; bool {
    !x
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='boolval'>true</span>;

    <span class='kw'>let</span> <span class='ident'>_y</span> <span class='op'>=</span> <span class='ident'>cambiar_verdad</span>(<span class='ident'>a</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}

<span class='kw'>fn</span> <span class='ident'>cambiar_verdad</span>(<span class='ident'>x</span>: <span class='ident'>bool</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='op'>!</span><span class='ident'>x</span>
}</pre>

<p>De haber tenido tipos que no implementasen el trait <code>Copy</code>, hubiésemos obtenido un error de compilación por tratar de usar un valor movido.</p>

<pre><code class="language-text">error: use of moved value: `a`
println!(&quot;{}&quot;, a);
               ^
</code></pre>

<p>Discutiremos como hacer que tus propios tipos sean <code>Copy</code> en la sección de <a href="traits.html">traits</a></p>

<h1 id='mas-que-pertenencia' class='section-header'><a href='#mas-que-pertenencia'>Mas que pertenencia</a></h1>
<p>Por supuesto, si necesitaremos devolver la pertenencia con cada función que escribiésemos:</p>
<span class='rusttest'>fn main() {
    fn foo(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        // hacer algo con v
    
        // devolviendo pertenencia
        v
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='comment'>// hacer algo con v</span>

    <span class='comment'>// devolviendo pertenencia</span>
    <span class='ident'>v</span>
}</pre>

<p>Las cosas se volverían bastante tediosas. Se pone aun peor mientras tengamos mas cosas sobre las cuales queramos tener pertenencia:</p>
<span class='rusttest'>fn main() {
    fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
        // hacer algo con v1 y v2
    
        // devolviendo pertenencia, así como el resultado de nuestra función
        (v1, v2, 42)
    }
    
    let v1 = vec![1, 2, 3];
    let v2 = vec![1, 2, 3];
    
    let (v1, v2, respuesta) = foo(v1, v2);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>v2</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> (<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>i32</span>) {
    <span class='comment'>// hacer algo con v1 y v2</span>

    <span class='comment'>// devolviendo pertenencia, así como el resultado de nuestra función</span>
    (<span class='ident'>v1</span>, <span class='ident'>v2</span>, <span class='number'>42</span>)
}

<span class='kw'>let</span> <span class='ident'>v1</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> (<span class='ident'>v1</span>, <span class='ident'>v2</span>, <span class='ident'>respuesta</span>) <span class='op'>=</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>, <span class='ident'>v2</span>);</pre>

<p>Ugh! El tipo de retorno, la linea de retorno, y el llamado a la función se vuelven mucho mas complicados.</p>

<p>Por suerte, Rust ofrece una facilidad, el préstamo, facilidad que nos sirve para solucionar este problema.</p>

<p>Es el tópico de la siguiente sección!</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Coerciones Deref</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a class='active' href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Coerciones Deref</h1>
    <p>La biblioteca estándar proporciona un trait especial <a href="../std/ops/trait.Deref.html"><code>Deref</code></a>. Es usado normalmente para sobrecargar <code>*</code>, el operador de dereferencia:</p>
<span class='rusttest'>use std::ops::Deref;

struct EjemploDeref&lt;T&gt; {
    valor: T,
}

impl&lt;T&gt; Deref for EjemploDeref&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.valor
    }
}

fn main() {
    let x = EjemploDeref { valor: &#39;a&#39; };
    assert_eq!(&#39;a&#39;, *x);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Deref</span>;

<span class='kw'>struct</span> <span class='ident'>EjemploDeref</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>valor</span>: <span class='ident'>T</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Deref</span> <span class='kw'>for</span> <span class='ident'>EjemploDeref</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Target</span> <span class='op'>=</span> <span class='ident'>T</span>;

    <span class='kw'>fn</span> <span class='ident'>deref</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>T</span> {
        <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>valor</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>EjemploDeref</span> { <span class='ident'>valor</span>: <span class='string'>&#39;a&#39;</span> };
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&#39;a&#39;</span>, <span class='op'>*</span><span class='ident'>x</span>);
}</pre>

<p>Lo anterior es útil para escribir tipos personalizados de apuntadores. Sin embargo, hay una facilidad del lenguaje relacionada a <code>Deref</code>: las ‘coerciones deref’. He aquí la regla: Si tienes un tipo <code>U</code>, y este implementa <code>Deref&lt;Target=T&gt;</code>, los valores de <code>&amp;U</code> harán coercion Automatica a un <code>&amp;T</code>. A continuación un ejemplo:</p>
<span class='rusttest'>fn main() {
    fn foo(s: &amp;str) {
        // tomar la cadena prestada por un segundo
    }
    
    // String implementa Deref&lt;Target=str&gt;
    let owned = &quot;Hola&quot;.to_string();
    
    // entonces, esto funciona:
    foo(&amp;owned);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
    <span class='comment'>// tomar la cadena prestada por un segundo</span>
}

<span class='comment'>// String implementa Deref&lt;Target=str&gt;</span>
<span class='kw'>let</span> <span class='ident'>owned</span> <span class='op'>=</span> <span class='string'>&quot;Hola&quot;</span>.<span class='ident'>to_string</span>();

<span class='comment'>// entonces, esto funciona:</span>
<span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='ident'>owned</span>);</pre>

<p>Usando un ampersand en frente del valor tomamos una referencia a el. Entonces <code>owned</code> es un <code>String</code>, <code>&amp;owned</code> es un <code>&amp;String</code>, y debido a <code>impl Deref&lt;Target=str&gt; para</code>String<code>,</code>&amp;String<code>hará deref a</code>&amp;str<code>que es tomado por foo()</code>.</p>

<p>Eso es todo. Dicha regla es uno de los únicos lugares en los que Rust hace conversiones automáticas por nosotros, pero al mismo tiempo agrega mucha flexibilidad. Por ejemplo el tipo <code>Rc&lt;T&gt;</code> implementa <code>Deref&lt;Target=T&gt;</code>, de manera que esto funciona:</p>
<span class='rusttest'>fn main() {
    use std::rc::Rc;
    
    fn foo(s: &amp;str) {
        // tomar la cadena prestada por un segundo
    }
    
    // String implementa Deref&lt;Target=str&gt;
    let owned = &quot;Hello&quot;.to_string();
    let contado = Rc::new(owned);
    
    // entonces, esto funciona:
    foo(&amp;contado);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
    <span class='comment'>// tomar la cadena prestada por un segundo</span>
}

<span class='comment'>// String implementa Deref&lt;Target=str&gt;</span>
<span class='kw'>let</span> <span class='ident'>owned</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>contado</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>(<span class='ident'>owned</span>);

<span class='comment'>// entonces, esto funciona:</span>
<span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='ident'>contado</span>);</pre>

<p>Todo lo que hemos hecho es envolver nuestro <code>String</code> en un <code>Rc&lt;T&gt;</code>. Pero ahora podemos pasar el <code>Rc&lt;String&gt;</code> a cualquier lugar en el cual tengamos un a <code>String</code>. La firma de <code>foo</code> no cambio, pero funciona de igual forma con cualquiera de los dos tipos. Este ejemplo tiene dos conversiones: de <code>Rc&lt;String&gt;</code> a <code>String</code> y luego de <code>String</code> a <code>&amp;str</code>. Rust hará esto tantas veces como sea posible hasta que los tipos coincidan.</p>

<p>Otra implementación muy común proporcionada por la biblioteca estándar es:</p>
<span class='rusttest'>fn main() {
    fn foo(s: &amp;[i32]) {
        // tomar el pedazo prestado por un segundo
    }
    
    // Vec&lt;T&gt; implementa Deref&lt;Target=[T]&gt;
    let owned = vec![1, 2, 3];
    
    foo(&amp;owned);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>]) {
    <span class='comment'>// tomar el pedazo prestado por un segundo</span>
}

<span class='comment'>// Vec&lt;T&gt; implementa Deref&lt;Target=[T]&gt;</span>
<span class='kw'>let</span> <span class='ident'>owned</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='ident'>owned</span>);</pre>

<p>Los vectores pueden hacer <code>Deref</code> a un slice.</p>

<h2 id='deref-y-llamadas-a-metodo' class='section-header'><a href='#deref-y-llamadas-a-metodo'>Deref y llamadas a metodo</a></h2>
<p><code>Deref</code> también entrara en efecto cuando se llame a un método. Considera el siguiente ejemplo:</p>
<span class='rusttest'>fn main() {
    struct Foo;
    
    impl Foo {
        fn foo(&amp;self) { println!(&quot;Foo&quot;); }
    }
    
    let f = &amp;&amp;Foo;
    
    f.foo();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Foo&quot;</span>); }
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='op'>&amp;&amp;</span><span class='ident'>Foo</span>;

<span class='ident'>f</span>.<span class='ident'>foo</span>();</pre>

<p>Aunque <code>f</code> es un <code>&amp;&amp;Foo</code> y <code>Foo</code> recibe a <code>&amp;self</code>, lo anterior funciona. Todo esto como consecuencia de que todas estas cosas son lo mismo:</p>
<span class='rusttest'>fn main() {
    f.foo();
    (&amp;f).foo();
    (&amp;&amp;f).foo();
    (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();
    
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>f</span>.<span class='ident'>foo</span>();
(<span class='kw-2'>&amp;</span><span class='ident'>f</span>).<span class='ident'>foo</span>();
(<span class='op'>&amp;&amp;</span><span class='ident'>f</span>).<span class='ident'>foo</span>();
(<span class='op'>&amp;&amp;</span><span class='op'>&amp;&amp;</span><span class='op'>&amp;&amp;</span><span class='op'>&amp;&amp;</span><span class='ident'>f</span>).<span class='ident'>foo</span>();</pre>

<p>Un valor de tipo <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code> puede aun tener llamadas a métodos definidos en <code>Foo</code> debido a que el compilador insertara tantas operaciones * sean necesarias para hacerlo funcionar. Y debido a que inserta <code>*</code>s, se hace uso de <code>Deref</code>.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Tipos Asociados</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a class='active' href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patrones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Tipos Asociados</h1>
    <p>Los tipos asociados son una parte poderosa del sistema de tipos de Rust. Se relacionan con la idea de una ‘familia de tipos’, en otras palabras, la agrupación de multiples tipos. Esa descripción es una poco abstracta, es mejor que nos adentremos de una vez en un ejemplo. Si queremos escribir un trait <code>Grafo</code>, tenemos dos tipos por encima de los cuales debemos ser genéricos: el tipo de los nodos y el tipo de los vertices. Podríamos escribir un trait, <code>Grafo&lt;N, V&gt;</code> como este:</p>
<span class='rusttest'>fn main() {
    trait Grafo&lt;N, V&gt; {
        fn tiene_vertice(&amp;self, &amp;N, &amp;N) -&gt; bool;
        fn vertices(&amp;self, &amp;N) -&gt; Vec&lt;V&gt;;
        // etc
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Grafo</span><span class='op'>&lt;</span><span class='ident'>N</span>, <span class='ident'>V</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>tiene_vertice</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='ident'>N</span>, <span class='kw-2'>&amp;</span><span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
    <span class='kw'>fn</span> <span class='ident'>vertices</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>V</span><span class='op'>&gt;</span>;
    <span class='comment'>// etc</span>
}</pre>

<p>Si bien esto de alguna manera funciona, termina siendo un poco raro. Por ejemplo, cualquier función que quiera recibir un <code>Grafo</code> como parámetro ahora también necesita ser genérica por sobre los tipos <code>N</code>odo y <code>V</code>ertice:</p>
<span class='rusttest'>fn main() {
    fn distancia&lt;N, V, G: Grafo&lt;N, V&gt;&gt;(grafo: &amp;G, inicio: &amp;N, fin: &amp;N) -&gt; u32 { ... }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>distancia</span><span class='op'>&lt;</span><span class='ident'>N</span>, <span class='ident'>V</span>, <span class='ident'>G</span>: <span class='ident'>Grafo</span><span class='op'>&lt;</span><span class='ident'>N</span>, <span class='ident'>V</span><span class='op'>&gt;&gt;</span>(<span class='ident'>grafo</span>: <span class='kw-2'>&amp;</span><span class='ident'>G</span>, <span class='ident'>inicio</span>: <span class='kw-2'>&amp;</span><span class='ident'>N</span>, <span class='ident'>fin</span>: <span class='kw-2'>&amp;</span><span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> { ... }</pre>

<p>Nuestro calculo de la distancia funciona sin tomar en cuenta nuestro tipo <code>Vértice</code>, en consecuencia la <code>V</code> en esta firma es simplemente una distracción.</p>

<p>Lo que realmente queremos expresar es que ciertos tipos <code>V</code>ertice y <code>N</code>odo vienen juntos para formar cada clase de <code>Grafo</code>. Podemos hacer esto con tipos asociados:</p>
<span class='rusttest'>fn main() {
    trait Grafo {
        type N;
        type V;
    
        fn tiene_vertice(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
        fn vertices(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::V&gt;;
        // etc
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Grafo</span> {
    <span class='kw'>type</span> <span class='ident'>N</span>;
    <span class='kw'>type</span> <span class='ident'>V</span>;

    <span class='kw'>fn</span> <span class='ident'>tiene_vertice</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='ident'>Self</span>::<span class='ident'>N</span>, <span class='kw-2'>&amp;</span><span class='ident'>Self</span>::<span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
    <span class='kw'>fn</span> <span class='ident'>vertices</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='ident'>Self</span>::<span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Self</span>::<span class='ident'>V</span><span class='op'>&gt;</span>;
    <span class='comment'>// etc</span>
}</pre>

<p>Ahora, nuestros clientes pueden abstraerse por encima de un determinado <code>Grafo</code>:</p>
<span class='rusttest'>fn main() {
    fn distancia&lt;G: Grafo&gt;(grafo: &amp;G, inicio: &amp;G::N, fin: &amp;G::N) -&gt; u32 { ... }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>distancia</span><span class='op'>&lt;</span><span class='ident'>G</span>: <span class='ident'>Grafo</span><span class='op'>&gt;</span>(<span class='ident'>grafo</span>: <span class='kw-2'>&amp;</span><span class='ident'>G</span>, <span class='ident'>inicio</span>: <span class='kw-2'>&amp;</span><span class='ident'>G</span>::<span class='ident'>N</span>, <span class='ident'>fin</span>: <span class='kw-2'>&amp;</span><span class='ident'>G</span>::<span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> { ... }</pre>

<p>Sin necesidad de lidiar con el tipo <code>V</code>ertice!</p>

<p>Echemos un vistazo con mayor detalle a todo esto.</p>

<h2 id='definiendo-tipos-asociados' class='section-header'><a href='#definiendo-tipos-asociados'>Definiendo tipos asociados</a></h2>
<p>Construyamos ese trait <code>Grafo</code>. He aquí la definición:</p>
<span class='rusttest'>fn main() {
    trait Graph {
        type N;
        type V;
    
        fn tiene_vertice(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
        fn vertices(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::V&gt;;
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Graph</span> {
    <span class='kw'>type</span> <span class='ident'>N</span>;
    <span class='kw'>type</span> <span class='ident'>V</span>;

    <span class='kw'>fn</span> <span class='ident'>tiene_vertice</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='ident'>Self</span>::<span class='ident'>N</span>, <span class='kw-2'>&amp;</span><span class='ident'>Self</span>::<span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
    <span class='kw'>fn</span> <span class='ident'>vertices</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='ident'>Self</span>::<span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Self</span>::<span class='ident'>V</span><span class='op'>&gt;</span>;
}</pre>

<p>Simple. Los tipos asociados usan la palabra reservada <code>type</code>, y van dentro del cuerpo del trait en conjunto con las funciones.</p>

<p>Dichas declaraciones <code>type</code> pueden tener lo mismo que las funciones. Por ejemplo si deseáramos que nuestro tipo <code>N</code> implementase <code>Display</code>, de manera que pudiésemos imprimir los nodos, podríamos hacer lo siguiente:</p>
<span class='rusttest'>fn main() {
    use std::fmt;
    
    trait Grafo {
        type N: fmt::Display;
        type V;
    
        fn tiene_vertice(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
        fn vertices(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::V&gt;;
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>;

<span class='kw'>trait</span> <span class='ident'>Grafo</span> {
    <span class='kw'>type</span> <span class='ident'>N</span>: <span class='ident'>fmt</span>::<span class='ident'>Display</span>;
    <span class='kw'>type</span> <span class='ident'>V</span>;

    <span class='kw'>fn</span> <span class='ident'>tiene_vertice</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='ident'>Self</span>::<span class='ident'>N</span>, <span class='kw-2'>&amp;</span><span class='ident'>Self</span>::<span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
    <span class='kw'>fn</span> <span class='ident'>vertices</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='ident'>Self</span>::<span class='ident'>N</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Self</span>::<span class='ident'>V</span><span class='op'>&gt;</span>;
}</pre>

<h2 id='implementando-tipos-asociados' class='section-header'><a href='#implementando-tipos-asociados'>Implementando tipos asociados</a></h2>
<p>Justo como cualquier otro trait, los traits que usan tipos asociados hacen uso de la palabra reservada <code>impl</code> para proporcionar implementaciones. A continuación una implementación simple de Grafo:</p>
<span class='rusttest'>fn main() {
    trait Grafo {
        type N;
        type V;
        fn tiene_vertice(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
        fn vertices(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::V&gt;;
    }
    struct Nodo;
    
    struct Vertice;
    
    struct MiGrafo;
    
    impl Grafo for MiGrafo {
        type N = Nodo;
        type V = Vertice;
    
        fn tiene_vertice(&amp;self, n1: &amp;Nodo, n2: &amp;Nodo) -&gt; bool {
            true
        }
    
        fn vertices(&amp;self, n: &amp;Nodo) -&gt; Vec&lt;Vertice&gt; {
            Vec::new()
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Nodo</span>;

<span class='kw'>struct</span> <span class='ident'>Vertice</span>;

<span class='kw'>struct</span> <span class='ident'>MiGrafo</span>;

<span class='kw'>impl</span> <span class='ident'>Grafo</span> <span class='kw'>for</span> <span class='ident'>MiGrafo</span> {
    <span class='kw'>type</span> <span class='ident'>N</span> <span class='op'>=</span> <span class='ident'>Nodo</span>;
    <span class='kw'>type</span> <span class='ident'>V</span> <span class='op'>=</span> <span class='ident'>Vertice</span>;

    <span class='kw'>fn</span> <span class='ident'>tiene_vertice</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>n1</span>: <span class='kw-2'>&amp;</span><span class='ident'>Nodo</span>, <span class='ident'>n2</span>: <span class='kw-2'>&amp;</span><span class='ident'>Nodo</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='boolval'>true</span>
    }

    <span class='kw'>fn</span> <span class='ident'>vertices</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>n</span>: <span class='kw-2'>&amp;</span><span class='ident'>Nodo</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Vertice</span><span class='op'>&gt;</span> {
        <span class='ident'>Vec</span>::<span class='ident'>new</span>()
    }
}</pre>

<p>Esta tonta implementación siempre retorna <code>true</code> y un <code>Vec&lt;Vertice&gt;</code> vacío, pero te da una idea de como se implementa este tipo de traits con tipos asociados. Primero necesitamos tres <code>struct</code>s, una para el grafo, una para el nodo, y una para el vértice. De haber tenido mas sentido usar un tipo diferente, también hubiese funcionado, ahora usaremos <code>struct</code>s para los tres.</p>

<p>Lo siguiente es la linea <code>impl</code>, que es idéntica a la implementación de cualquier otro trait.</p>

<p>De aquí en adelante, usamos <code>=</code> para definir nuestros tipos asociados. El nombre que el trait usa va del lado izquierdo del <code>=</code>, y el tipo en concreto para el  que estamos implementando este trait va del lado derecho. Finalmente, podemos usar tipos concretos en nuestras declaraciones de función.</p>

<h2 id='objetos-trait-con-tipos-asociados' class='section-header'><a href='#objetos-trait-con-tipos-asociados'>Objetos trait con tipos asociados</a></h2>
<p>Hay otra sintaxis de la cual debemos hablar: objetos trait. Si deseáramos crear un objeto trait a partir de un tipo asociado de esta manera:</p>
<span class='rusttest'>fn main() {
    trait Grafo {
        type N;
        type V;
        fn tiene_vertice(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
        fn vertices(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::V&gt;;
    }
    struct Nodo;
    struct Vertice;
    struct MiGrafo;
    impl Grafo for MiGrafo {
        type N = Node;
        type V = Vertice;
        fn tiene_vertice(&amp;self, n1: &amp;Nodo, n2: &amp;Nodo) -&gt; bool {
            true
        }
        fn vertices(&amp;self, n: &amp;Nodo) -&gt; Vec&lt;Vertice&gt; {
            Vec::new()
        }
    }
    let grafo = MiGrafo;
    let obj = Box::new(grafo) as Box&lt;MiGrafo&gt;;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>grafo</span> <span class='op'>=</span> <span class='ident'>MiGrafo</span>;
<span class='kw'>let</span> <span class='ident'>obj</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>grafo</span>) <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>MiGrafo</span><span class='op'>&gt;</span>;</pre>

<p>Obtendríamos estos dos errores:</p>

<pre><code class="language-text">error: the value of the associated type `V` (from the trait `main::Grafo`) must
be specified [E0191]
let obj = Box::new(grafo) as Box&lt;Grafo&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
24:44 error: the value of the associated type `N` (from the trait
`main::Grafo`) must be specified [E0191]
let obj = Box::new(grafo) as Box&lt;Grafo&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>

<p>No podemos crear objetos trait de esta manera, puesto a que no conocemos los tipos asociados. En su lugar podríamos escribir:</p>
<span class='rusttest'>fn main() {
    trait Grafo {
        type N;
        type V;
        fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
        fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::V&gt;;
    }
    struct Nodo;
    struct Vertice;
    struct MiGrafo;
    impl Grafo for MiGrafo {
        type N = Nodo;
        type V = Vertice;
        fn tiene_vertice(&amp;self, n1: &amp;Nodo, n2: &amp;Nodo) -&gt; bool {
            true
        }
        fn vertices(&amp;self, n: &amp;Nodo) -&gt; Vec&lt;Vertice&gt; {
            Vec::new()
        }
    }
    let grafo = MiGrafo;
    let obj = Box::new(grafo) as Box&lt;Grafo&lt;N=Nodo, V=Vertice&gt;&gt;;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>grafo</span> <span class='op'>=</span> <span class='ident'>MiGrafo</span>;
<span class='kw'>let</span> <span class='ident'>obj</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>grafo</span>) <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Grafo</span><span class='op'>&lt;</span><span class='ident'>N</span><span class='op'>=</span><span class='ident'>Nodo</span>, <span class='ident'>V</span><span class='op'>=</span><span class='ident'>Vertice</span><span class='op'>&gt;&gt;</span>;</pre>

<p>La sintaxis <code>N=Nodo</code> nos permite crear un tipo concreto, <code>Nodo</code>, para el parámetro de tipo <code>N</code>. Lo mismo con <code>V=Vertice</code>. De no haber proporcionado esta restricción, no hubiéramos podido determinar contra cual <code>impl</code> debe ser usado el objeto trait.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
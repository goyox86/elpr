<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>La Cena de los Filósofos</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a class='active' href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Monticulo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilacion Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentacion</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribucion</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> Ciclos for</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> Ciclos while</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> Referencias y Prestamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Sintaxis de Metodos</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Genericos</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Rasgos</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Objetos de Razgo</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Sintaxis de Llamada a Funciones Universal</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates y Modulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Conversion entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Tipos sin Tamano</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Inverstigacion Academica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">La Cena de los Filósofos</h1>
    <p>Para nuestro segundo proyecto, echemos un vistazo a un problema clásico de concurrencia. Se llama ‘La cena de los filósofos’. Fue originalmente concebido por Dijkstra en 1965, pero nosotros usaremos una version ligeramente adaptada de <a href="http://www.usingcsp.com/cspbook.pdf">este paper</a> por Tony Hoare en 1985.</p>

<blockquote>
<p>En tiempos ancestrales, un filántropo adinerado preparo una universidad para alojar a cinco
filósofos eminentes. Cada filósofo tenia una habitación en la cual podía desempeñar su
actividad profesional del pensamiento: también había un comedor en común, amoblado con una
mesa circular, rodeada por cinco sillas, cada una identificada con el nombre del filosofo que
se sentaba en ella. Los filósofos se sentaban en sentido anti-horario alrededor de la mesa. A la
izquierda de cada filósofo yacía un tenedor dorado, y en el centro un tazón de espagueti, el
cual era constantemente rellenado. Se esperaba que un filósofo empleara la mayoría de su
tiempo pensando; pero cuando se sintieran con hambre, se dirigiera a el comedor tomara el
tenedor que estaba a su izquierda y lo sumieran en el espagueti. Pero tal era naturaleza
enredada del espagueti que un segundo tenedor era requerido para llevarlo a la boca.
El filósofo por ende tenia que también tomar el tenedor a su derecha. Cuando terminaban
debían bajar ambos tenedores, levantarse de la silla y continuar pensando. Por supuesto,
un tenedor puede ser usado por un solo filósofo a la vez. Si otro filósofo lo desea,
tiene que esperar hasta que el tenedor este disponible nuevamente.</p>
</blockquote>

<p>Este problema clásico exhibe algunos elementos de la concurrencia. La razón de ello es que es una solución efectivamente difícil de implementar: una implementación simple puede generar un deadlock. Por ejemplo, consideremos un algoritmo simple que podría resolver este problema:</p>

<ol>
<li>Un filósofo toma el tenedor a su izquierda.</li>
<li>Después toma el tenedor en a su derecha.</li>
<li>Come.</li>
<li>Baja los tenedores.</li>
</ol>

<p>Ahora, imaginemos esta secuencia de eventos:</p>

<ol>
<li>Filosofo 1 comienza el algoritmo, tomando el tenedor a su izquierda.</li>
<li>Filosofo 2 comienza el algoritmo, tomando el tenedor a su izquierda.</li>
<li>Filosofo 3 comienza el algoritmo, tomando el tenedor a su izquierda.</li>
<li>Filosofo 4 comienza el algoritmo, tomando el tenedor a su izquierda.</li>
<li>Filosofo 5 comienza el algoritmo, tomando el tenedor a su izquierda.</li>
<li>... ? Todos los tenedores han sido tomados, pero nadie puede comer!</li>
</ol>

<p>Existen diferentes formas de resolver este problema. Te guiaremos a través de la solución de este tutorial. Por ahora, comencemos modelando el problema. Empecemos con los filósofos:</p>
<span class='rusttest'>struct Filosofo {
    nombre: String,
}

impl Filosofo {
    fn new(nombre: &amp;str) -&gt; Filosofo {
        Filosofo {
            nombre: nombre.to_string(),
        }
    }
}

fn main() {
    let f1 = Filosofo::new(&quot;Judith Butler&quot;);
    let f2 = Filosofo::new(&quot;Gilles Deleuze&quot;);
    let f3 = Filosofo::new(&quot;Karl Marx&quot;);
    let f4 = Filosofo::new(&quot;Emma Goldman&quot;);
    let f5 = Filosofo::new(&quot;Michel Foucault&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Filosofo</span> {
    <span class='ident'>nombre</span>: <span class='ident'>String</span>,
}

<span class='kw'>impl</span> <span class='ident'>Filosofo</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>nombre</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Filosofo</span> {
        <span class='ident'>Filosofo</span> {
            <span class='ident'>nombre</span>: <span class='ident'>nombre</span>.<span class='ident'>to_string</span>(),
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>f1</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Judith Butler&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>f2</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Gilles Deleuze&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>f3</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Karl Marx&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>f4</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Emma Goldman&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>f5</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Michel Foucault&quot;</span>);
}
</pre>

<p>Acá, creamos una <a href="structs.html"><code>estructura</code></a> (struct) para representar un filósofo. Por ahora el nombre es todo lo que necesitamos. Elegimos el tipo <a href="strings.html"><code>String</code></a> para el nombre, en vez de <code>&amp;str</code>. Generalmente hablando, trabajar con tipo que es dueño (posee pertenencia) de su data es mas fácil que trabajar con uno que use referencias.</p>

<p>Continuemos:</p>
<span class='rusttest'>fn main() {
    struct Filosofo {
        nombre: String,
    }
    impl Filosofo {
        fn new(nombre: &amp;str) -&gt; Filosofo {
            Filosofo {
                nombre: nombre.to_string(),
            }
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Filosofo</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>nombre</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Filosofo</span> {
        <span class='ident'>Filosofo</span> {
            <span class='ident'>nombre</span>: <span class='ident'>nombre</span>.<span class='ident'>to_string</span>(),
        }
    }
}
</pre>

<p>Este bloque <code>impl</code> nos permite definir cosas en estructuras <code>Filosofo</code>. En este caso estamos definiendo una ‘función asociada’ llamada <code>new</code>. La primera linea luce así:</p>
<span class='rusttest'>fn main() {
    struct Filosofo {
        nombre: String,
    }
    impl Filosofo {
    fn new(nombre: &amp;str) -&gt; Filosofo {
            Filosofo {
                nombre: nombre.to_string(),
            }
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>nombre</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Filosofo</span> {
</pre>

<p>Recibimos un argumento, <code>nombre</code>, de tipo <code>&amp;str</code>. Una referencia a otra cadena de caracteres. Esta retorna una instancia de nuestra estructura <code>Filosofo</code>.</p>
<span class='rusttest'>fn main() {
    struct Filosofo {
        nombre: String,
    }
    impl Filosofo {
       fn new(nombre: &amp;str) -&gt; Filosofo {
    Filosofo {
        nombre: nombre.to_string(),
    }
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>Filosofo</span> {
    <span class='ident'>nombre</span>: <span class='ident'>nombre</span>.<span class='ident'>to_string</span>(),
}
</pre>

<p>Lo anterior crea un nuevo <code>Filosofo</code>, y asigna nuestro argumento <code>nombre</code> a el campo <code>nombre</code>. No a el argumento en si mismo, debido a que llamamos <code>.to_string()</code> en el. Lo cual crea una copia de la cadena a la que apunta nuestro <code>&amp;str</code>, y nos da un nuevo <code>String</code>, que es del tipo del campo <code>nombre</code> de <code>Filosofo</code>.</p>

<p>Porque no aceptar un <code>String</code> directamente? Es mas fácil de llamar. Si recibiéramos un <code>String</code> pero quien nos llama tuviese un <code>&amp;str</code> ellos se verían en la obligación de llamar <code>.to_string()</code> de su lado. La desventaja de esta flexibilidad es que <em>siempre</em> hacemos una copia. Para este pequeño programa, esto no es particularmente importante, y que sabemos que estaremos usando cadenas cortas de cualquier modo.</p>

<p>Una ultima cosas que habrás notado: solo definimos un <code>Filosofo</code>, y no parecemos hacer nada con el. Rust es un lenguaje ‘basado en expresiones’, lo que significa que casi cualquier cosa en Rust es una expresión que retorna un valor. Esto es cierto para las funciones también, la ultima expresión es retornada automáticamente. Debido a que creamos un nuevo <code>Filosofo</code> como la ultima expresión de esta función, terminamos retornándolo.</p>

<p>El nombre <code>new()</code>, no es nada especial para Rust, pero es una convención para funciones que crean nuevas instancias de estructuras. Antes que hablemos del porque, echamos un vistazo a <code>main()</code> otra vez:</p>
<span class='rusttest'>struct Filosofo {
    nombre: String,
}

impl Filosofo {
    fn new(nombre: &amp;str) -&gt; Filosofo {
        Filosofo {
            nombre: nombre.to_string(),
        }
    }
}

fn main() {
    let f1 = Filosofo::new(&quot;Judith Butler&quot;);
    let f2 = Filosofo::new(&quot;Gilles Deleuze&quot;);
    let f3 = Filosofo::new(&quot;Karl Marx&quot;);
    let f4 = Filosofo::new(&quot;Emma Goldman&quot;);
    let f5 = Filosofo::new(&quot;Michel Foucault&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>f1</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Judith Butler&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>f2</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Gilles Deleuze&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>f3</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Karl Marx&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>f4</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Emma Goldman&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>f5</span> <span class='op'>=</span> <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Michel Foucault&quot;</span>);
}
</pre>

<p>Acá, creamos cinco variables con cinco nuevos filósofos. Estos son mis cinco favoritos, pero puedes substituirlos con quienes prefieras. De no haber definido la función <code>new()</code> , <code>main()</code> luciría así:</p>
<span class='rusttest'>struct Filosofo {
    nombre: String,
}
fn main() {
    let f1 = Filosofo { nombre: &quot;Judith Butler&quot;.to_string() };
    let f2 = Filosofo { nombre: &quot;Gilles Deleuze&quot;.to_string() };
    let f3 = Filosofo { nombre: &quot;Karl Marx&quot;.to_string() };
    let f4 = Filosofo { nombre: &quot;Emma Goldman&quot;.to_string() };
    let f5 = Filosofo { nombre: &quot;Michel Foucault&quot;.to_string() };
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>f1</span> <span class='op'>=</span> <span class='ident'>Filosofo</span> { <span class='ident'>nombre</span>: <span class='string'>&quot;Judith Butler&quot;</span>.<span class='ident'>to_string</span>() };
    <span class='kw'>let</span> <span class='ident'>f2</span> <span class='op'>=</span> <span class='ident'>Filosofo</span> { <span class='ident'>nombre</span>: <span class='string'>&quot;Gilles Deleuze&quot;</span>.<span class='ident'>to_string</span>() };
    <span class='kw'>let</span> <span class='ident'>f3</span> <span class='op'>=</span> <span class='ident'>Filosofo</span> { <span class='ident'>nombre</span>: <span class='string'>&quot;Karl Marx&quot;</span>.<span class='ident'>to_string</span>() };
    <span class='kw'>let</span> <span class='ident'>f4</span> <span class='op'>=</span> <span class='ident'>Filosofo</span> { <span class='ident'>nombre</span>: <span class='string'>&quot;Emma Goldman&quot;</span>.<span class='ident'>to_string</span>() };
    <span class='kw'>let</span> <span class='ident'>f5</span> <span class='op'>=</span> <span class='ident'>Filosofo</span> { <span class='ident'>nombre</span>: <span class='string'>&quot;Michel Foucault&quot;</span>.<span class='ident'>to_string</span>() };
}
</pre>

<p>Un poco mas ruidoso. Usar <code>new</code> tiene también posee otras ventajas, pero incluso en este simple caso termina por ser de mejor utilidad.</p>

<p>Ahora que tenemos lo básico en su lugar, hay un numero de maneras en las cuales podemos atacar el problema mas amplio. A mi me gusta comenzar por el final: creemos una forma para que cada filosofo pueda finalizar de comer. Como un paso pequeño, hagamos un método, y luego iteremos a través de todos los filósofos llamándolo:</p>
<span class='rusttest'>struct Filosofo {
    nombre: String,
}

impl Filosofo {
    fn new(nombre: &amp;str) -&gt; Filosofo {
        Filosofo {
            nombre: nombre.to_string(),
        }
    }

    fn comer(&amp;self) {
        println!(&quot;{} ha finalizado de comer.&quot;, self.nombre);
    }
}

fn main() {
    let filosofos = vec![
        Filosofo::new(&quot;Judith Butler&quot;),
        Filosofo::new(&quot;Gilles Deleuze&quot;),
        Filosofo::new(&quot;Karl Marx&quot;),
        Filosofo::new(&quot;Emma Goldman&quot;),
        Filosofo::new(&quot;Michel Foucault&quot;),
    ];

    for f in &amp;filosofos {
        f.comer();
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Filosofo</span> {
    <span class='ident'>nombre</span>: <span class='ident'>String</span>,
}

<span class='kw'>impl</span> <span class='ident'>Filosofo</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>nombre</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Filosofo</span> {
        <span class='ident'>Filosofo</span> {
            <span class='ident'>nombre</span>: <span class='ident'>nombre</span>.<span class='ident'>to_string</span>(),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>comer</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} ha finalizado de comer.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>filosofos</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Judith Butler&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Gilles Deleuze&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Karl Marx&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Emma Goldman&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Michel Foucault&quot;</span>),
    ];

    <span class='kw'>for</span> <span class='ident'>f</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>filosofos</span> {
        <span class='ident'>f</span>.<span class='ident'>comer</span>();
    }
}
</pre>

<p>Primero veamos a <code>main()</code>. En lugar de tener cinco variables individuales para nuestros filósofos, creamos un <code>Vec&lt;T&gt;</code>. <code>Vec&lt;T&gt;</code> es llamado también un ‘vector’, y es un arreglo capaz de crecer. Después usamos un ciclo [<code>for</code>][for] para iterar a través del vector, obteniendo un referencia a cada filosofo a la vez.</p>

<p>En el cuerpo del bucle, llamamos <code>f.comer();</code>, que esta definido como:</p>
<span class='rusttest'>fn main() {
    fn comer(&amp;self) {
        println!(&quot;{} ha finalizado de comer.&quot;, self.nombre);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>comer</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} ha finalizado de comer.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);
}
</pre>

<p>En Rust, los métodos reciben un parámetro explícito <code>self</code>.  Es por ello que <code>comer()</code> es un método y <code>new</code> es una función asociada: <code>new()</code> no tiene <code>self</code>. Para nuestra primera version de <code>comer()</code>, solo imprimimos el nombre del filósofo, y mencionamos que ha finalizado de comer. Ejecutar este programa deber generar la siguiente salida:</p>

<pre><code class="language-text">Judith Butler ha finalizado de comer.
Gilles Deleuze ha finalizado de comer.
Karl Marx ha finalizado de comer.
Emma Goldman ha finalizado de comer.
Michel Foucault ha finalizado de comer.
</code></pre>

<p>Muy fácil, todos han terminado de comer! Pero no hemos implementado el problema real todavía, así que aun no terminamos!</p>

<p>A continuación, no solo queremos solo finalicen de comer, sino que efectivamente coman. He aquí la siguiente versión:</p>
<span class='rusttest'>use std::thread;

struct Filosofo {
    nombre: String,
}

impl Filosofo {
    fn new(nombre: &amp;str) -&gt; Filosofo {
        Filosofo {
            nombre: nombre.to_string(),
        }
    }

    fn comer(&amp;self) {
        println!(&quot;{} esta comiendo.&quot;, self.nombre);

        thread::sleep_ms(1000);

        println!(&quot;{} ha finalizado de comer.&quot;, self.nombre);
    }
}

fn main() {
    let filosofos = vec![
        Filosofo::new(&quot;Judith Butler&quot;),
        Filosofo::new(&quot;Gilles Deleuze&quot;),
        Filosofo::new(&quot;Karl Marx&quot;),
        Filosofo::new(&quot;Emma Goldman&quot;),
        Filosofo::new(&quot;Michel Foucault&quot;),
    ];

    for f in &amp;filosofos {
        f.comer();
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>struct</span> <span class='ident'>Filosofo</span> {
    <span class='ident'>nombre</span>: <span class='ident'>String</span>,
}

<span class='kw'>impl</span> <span class='ident'>Filosofo</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>nombre</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Filosofo</span> {
        <span class='ident'>Filosofo</span> {
            <span class='ident'>nombre</span>: <span class='ident'>nombre</span>.<span class='ident'>to_string</span>(),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>comer</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} esta comiendo.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);

        <span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>1000</span>);

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} ha finalizado de comer.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>filosofos</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Judith Butler&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Gilles Deleuze&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Karl Marx&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Emma Goldman&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Michel Foucault&quot;</span>),
    ];

    <span class='kw'>for</span> <span class='ident'>f</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>filosofos</span> {
        <span class='ident'>f</span>.<span class='ident'>comer</span>();
    }
}
</pre>

<p>Solo unos pocos cambios. Analicémoslos parte por parte.</p>
<span class='rusttest'>fn main() {
    use std::thread;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
</pre>

<p><code>use</code> hace disponibles nombres en nuestro ámbito (scope). Comenzaremos a usar el modulo <code>thread</code> de la biblioteca estándar, y es por ello que necesitamos hacer <code>use</code> en el.</p>
<span class='rusttest'>fn main() {
        fn comer(&amp;self) {
            println!(&quot;{} esta comiendo.&quot;, self.nombre);
    
            thread::sleep_ms(1000);
    
            println!(&quot;{} ha finalizado de comer.&quot;, self.nombre);
        }
    
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>fn</span> <span class='ident'>comer</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} esta comiendo.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);

        <span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>1000</span>);

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} ha finalizado de comer.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);
    }
</pre>

<p>Ahora estamos imprimiendo dos mensajes, con un <code>sleep_ms()</code> en el medio. Lo cual simulara el tiempo que tarda un filosofo en comer.</p>

<p>Si ejecutas este programa, deberias ver comer a cada filosofo a la vez:</p>

<pre><code class="language-text">Judith Butler esta comiendo.
Judith Butler ha finalizado de comer.
Gilles Deleuze esta comiendo.
Gilles Deleuze ha finalizado de comer.
Karl Marx esta comiendo.
Karl Marx ha finalizado de comer.
Emma Goldman esta comiendo.
Emma Goldman ha finalizado de comer.
Michel Foucault esta comiendo.
Michel Foucault ha finalizado de comer.
</code></pre>

<p>Excelente! Estamos avanzando. Solo hay un detalle: no estamos operando de manera concurrente, lo cual es parte central de nuestro problema!</p>

<p>Para hacer a nuestros filósofos comer de manera concurrente, necesitamos hacer un pequeño cambio.</p>

<p>He aqui la siguiente iteración:</p>
<span class='rusttest'>use std::thread;

struct Filosofo {
    nombre: String,
}

impl Filosofo {
    fn new(nombre: &amp;str) -&gt; Filosofo {
        Filosofo {
            nombre: nombre.to_string(),
        }
    }

    fn comer(&amp;self) {
        println!(&quot;{} esta comiendo.&quot;, self.nombre);

        thread::sleep_ms(1000);

        println!(&quot;{} ha finalizado de comer.&quot;, self.nombre);
    }
}

fn main() {
    let filosofos = vec![
        Filosofo::new(&quot;Judith Butler&quot;),
        Filosofo::new(&quot;Gilles Deleuze&quot;),
        Filosofo::new(&quot;Karl Marx&quot;),
        Filosofo::new(&quot;Emma Goldman&quot;),
        Filosofo::new(&quot;Michel Foucault&quot;),
    ];

    let handles: Vec&lt;_&gt; = filosofos.into_iter().map(|f| {
        thread::spawn(move || {
            f.comer();
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>struct</span> <span class='ident'>Filosofo</span> {
    <span class='ident'>nombre</span>: <span class='ident'>String</span>,
}

<span class='kw'>impl</span> <span class='ident'>Filosofo</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>nombre</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Filosofo</span> {
        <span class='ident'>Filosofo</span> {
            <span class='ident'>nombre</span>: <span class='ident'>nombre</span>.<span class='ident'>to_string</span>(),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>comer</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} esta comiendo.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);

        <span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>1000</span>);

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} ha finalizado de comer.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>filosofos</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Judith Butler&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Gilles Deleuze&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Karl Marx&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Emma Goldman&quot;</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Michel Foucault&quot;</span>),
    ];

    <span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>filosofos</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>f</span><span class='op'>|</span> {
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='ident'>f</span>.<span class='ident'>comer</span>();
        })
    }).<span class='ident'>collect</span>();

    <span class='kw'>for</span> <span class='ident'>h</span> <span class='kw'>in</span> <span class='ident'>handles</span> {
        <span class='ident'>h</span>.<span class='ident'>join</span>().<span class='ident'>unwrap</span>();
    }
}
</pre>

<p>Todo lo que hemos hecho es cambiar el ciclo en <code>main()</code>, y agregado un segundo! Este es el primer cambio:</p>
<span class='rusttest'>fn main() {
    let handles: Vec&lt;_&gt; = filosofos.into_iter().map(|f| {
        thread::spawn(move || {
             f.comer();
        })
    }).collect();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>filosofos</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>f</span><span class='op'>|</span> {
    <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
         <span class='ident'>f</span>.<span class='ident'>comer</span>();
    })
}).<span class='ident'>collect</span>();
</pre>

<p>Aun así son solo cinco lineas, son cinco densas lineas. Analicemos por partes.</p>
<span class='rusttest'>fn main() {
    let handles: Vec&lt;_&gt; =
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span>
</pre>

<p>Introducimos una nueva variable, llamada <code>handles</code>. Le hemos dado este nombre porque crearemos algunos nuevos hilos, que resultaran en algunos handles (agarradores, manillas) a esos dichos hilos los cuales nos permitirán controlar su operación. Necesitamos anotar el tipo explícitamente, debido a algo que haremos referencia mas adelante. El  <code>_</code> es un marcador de posición para un tipo. Estamos diciendo “<code>handles</code> es un vector de algo, pero tu, Rust, puedes determinar que es ese algo.”</p>
<span class='rusttest'>fn main() {
    filosofos.into_iter().map(|f| {
    
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>filosofos</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>f</span><span class='op'>|</span> {
</pre>

<p>Tomamos nuestra lista de filósofos y llamamos <code>into_iter()</code> en ella. Esto crea un iterador que se adueña (toma pertenencia) de cada filosofo. Necesitamos hacer esto para poder pasar los filósofos a nuestros hilos. Luego tomamos ese iterador y llamamos <code>map</code> en el, método que toma un closure como argumento y llama dicho closure en cada uno de los elementos a la vez.</p>
<span class='rusttest'>fn main() {
        thread::spawn(move || {
            f.comer();
        })
    
}</span><pre class='rust rust-example-rendered'>
    <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
        <span class='ident'>f</span>.<span class='ident'>comer</span>();
    })
</pre>

<p>Es aquí donde la concurrencia ocurre. La función <code>thread::spawn</code> toma un closure como argumento y ejecuta ese closure en un nuevo hilo. El closure necesita una anotación extra, <code>move</code>, para indicar que el closure va a adueñarse de los valores que esta capturando. Principalmente, la variable <code>f</code> de la función <code>map</code>.</p>

<p>Dentro del hilo, todo lo que hacemos es llamar a <code>comer();</code> en <code>f</code>.</p>
<span class='rusttest'>fn main() {
    }).collect();
    
}</span><pre class='rust rust-example-rendered'>
}).<span class='ident'>collect</span>();
</pre>

<p>Finalmente, tomamos el resultado de todos esas llamadas a <code>map</code> y los coleccionamos. <code>collect()</code> los convertirá en una colección de alguna tipo, que es el porque anotamos el tipo de retorno: queremos un <code>Vec&lt;T&gt;</code>. Los elementos son los valores retornados de las llamadas a <code>thread::spawn</code>, que son handles a esos hilos. Whew!</p>
<span class='rusttest'>fn main() {
    for h in handles {
        h.join().unwrap();
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>for</span> <span class='ident'>h</span> <span class='kw'>in</span> <span class='ident'>handles</span> {
    <span class='ident'>h</span>.<span class='ident'>join</span>().<span class='ident'>unwrap</span>();
}
</pre>

<p>Al final de <code>main()</code>, iteramos a través de los handles llamando <code>join()</code> en ellos, lo cual bloquea la ejecución hasta que el hilo haya completado su ejecución. Esto asegura que el hilo complete su ejecución antes que el programa termine.</p>

<p>Si ejecutas este programa, veras que los filósofos comen sin orden!
Tenemos multi-hilos!</p>

<pre><code class="language-text">Gilles Deleuze esta comiendo.
Gilles Deleuze ha finalizado de comer.
Emma Goldman esta comiendo.
Emma Goldman ha finalizado de comer.
Michel Foucault esta comiendo.
Judith Butler esta comiendo.
Judith Butler ha finalizado de comer.
Karl Marx esta comiendo.
Karl Marx ha finalizado de comer.
Michel Foucault ha finalizado de comer.
</code></pre>

<p>Pero que acerca de los tenedores no los hemos modelado del todo todavía.</p>

<p>Para hacerlo, creemos un nuevo <code>struct</code>:</p>
<span class='rusttest'>fn main() {
    use std::sync::Mutex;
    
    struct Mesa {
        tenedores: Vec&lt;Mutex&lt;()&gt;&gt;,
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>Mutex</span>;

<span class='kw'>struct</span> <span class='ident'>Mesa</span> {
    <span class='ident'>tenedores</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Mutex</span><span class='op'>&lt;</span>()<span class='op'>&gt;&gt;</span>,
}
</pre>

<p>Esta <code>Mesa</code> contiene un vector de <code>Mutex</code>es. Un mutex es una forma de controlar concurrencia, solo un hilo puede acceder el contenido a la vez. Esta es la exactamente la propiedad que necesitamos para nuestros tenedores. Usamos una dupla vacía, <code>()</code>,  dentro del mutex, debido a que no vamos a usar el valor, solo nos aferraremos a el.</p>

<p>Modifiquemos el programa para hacer uso de <code>Mesa</code>:</p>
<span class='rusttest'>use std::thread;
use std::sync::{Mutex, Arc};

struct Filosofo {
    nombre: String,
    izquierda: usize,
    derecha: usize,
}

impl Filosofo {
    fn new(nombre: &amp;str, izquierda: usize, derecha: usize) -&gt; Filosofo {
        Filosofo {
            nombre: nombre.to_string(),
            izquierda: izquierda,
            derecha: derecha,
        }
    }

    fn comer(&amp;self, mesa: &amp;Mesa) {
        let _izquierda = mesa.tenedores[self.izquierda].lock().unwrap();
        let _derecha = mesa.tenedores[self.derecha].lock().unwrap();

        println!(&quot;{} esta comiendo.&quot;, self.nombre);

        thread::sleep_ms(1000);

        println!(&quot;{} ha finalizado de comer.&quot;, self.nombre);
    }
}

struct Mesa {
    tenedores: Vec&lt;Mutex&lt;()&gt;&gt;,
}

fn main() {
    let mesa = Arc::new(Mesa { tenedores: vec![
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
    ]});

    let filosofos = vec![
        Filosofo::new(&quot;Judith Butler&quot;, 0, 1),
        Filosofo::new(&quot;Gilles Deleuze&quot;, 1, 2),
        Filosofo::new(&quot;Karl Marx&quot;, 2, 3),
        Filosofo::new(&quot;Emma Goldman&quot;, 3, 4),
        Filosofo::new(&quot;Michel Foucault&quot;, 0, 4),
    ];

    let handles: Vec&lt;_&gt; = filosofos.into_iter().map(|f| {
        let mesa = mesa.clone();

        thread::spawn(move || {
            f.comer(&amp;mesa);
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::{<span class='ident'>Mutex</span>, <span class='ident'>Arc</span>};

<span class='kw'>struct</span> <span class='ident'>Filosofo</span> {
    <span class='ident'>nombre</span>: <span class='ident'>String</span>,
    <span class='ident'>izquierda</span>: <span class='ident'>usize</span>,
    <span class='ident'>derecha</span>: <span class='ident'>usize</span>,
}

<span class='kw'>impl</span> <span class='ident'>Filosofo</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>nombre</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>izquierda</span>: <span class='ident'>usize</span>, <span class='ident'>derecha</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>Filosofo</span> {
        <span class='ident'>Filosofo</span> {
            <span class='ident'>nombre</span>: <span class='ident'>nombre</span>.<span class='ident'>to_string</span>(),
            <span class='ident'>izquierda</span>: <span class='ident'>izquierda</span>,
            <span class='ident'>derecha</span>: <span class='ident'>derecha</span>,
        }
    }

    <span class='kw'>fn</span> <span class='ident'>comer</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>mesa</span>: <span class='kw-2'>&amp;</span><span class='ident'>Mesa</span>) {
        <span class='kw'>let</span> <span class='ident'>_izquierda</span> <span class='op'>=</span> <span class='ident'>mesa</span>.<span class='ident'>tenedores</span>[<span class='self'>self</span>.<span class='ident'>izquierda</span>].<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
        <span class='kw'>let</span> <span class='ident'>_derecha</span> <span class='op'>=</span> <span class='ident'>mesa</span>.<span class='ident'>tenedores</span>[<span class='self'>self</span>.<span class='ident'>derecha</span>].<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} esta comiendo.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);

        <span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>1000</span>);

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} ha finalizado de comer.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);
    }
}

<span class='kw'>struct</span> <span class='ident'>Mesa</span> {
    <span class='ident'>tenedores</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Mutex</span><span class='op'>&lt;</span>()<span class='op'>&gt;&gt;</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>mesa</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Mesa</span> { <span class='ident'>tenedores</span>: <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
    ]});

    <span class='kw'>let</span> <span class='ident'>filosofos</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Judith Butler&quot;</span>, <span class='number'>0</span>, <span class='number'>1</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Gilles Deleuze&quot;</span>, <span class='number'>1</span>, <span class='number'>2</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Karl Marx&quot;</span>, <span class='number'>2</span>, <span class='number'>3</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Emma Goldman&quot;</span>, <span class='number'>3</span>, <span class='number'>4</span>),
        <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Michel Foucault&quot;</span>, <span class='number'>0</span>, <span class='number'>4</span>),
    ];

    <span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>filosofos</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>f</span><span class='op'>|</span> {
        <span class='kw'>let</span> <span class='ident'>mesa</span> <span class='op'>=</span> <span class='ident'>mesa</span>.<span class='ident'>clone</span>();

        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='ident'>f</span>.<span class='ident'>comer</span>(<span class='kw-2'>&amp;</span><span class='ident'>mesa</span>);
        })
    }).<span class='ident'>collect</span>();

    <span class='kw'>for</span> <span class='ident'>h</span> <span class='kw'>in</span> <span class='ident'>handles</span> {
        <span class='ident'>h</span>.<span class='ident'>join</span>().<span class='ident'>unwrap</span>();
    }
}
</pre>

<p>Muchos cambios! Sin embargo, con esta iteración, hemos obtenido un programa funcional.
Veamos los detalles:</p>
<span class='rusttest'>fn main() {
    use std::sync::{Mutex, Arc};
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::{<span class='ident'>Mutex</span>, <span class='ident'>Arc</span>};
</pre>

<p>Usaremos otra estructura del paquete <code>std::sync</code>: <code>Arc&lt;T&gt;</code>.</p>

<p>Hablaremos mas acerca de ella cuando la usemos.</p>
<span class='rusttest'>fn main() {
    struct Filosofo {
        nombre: String,
        izquierda: usize,
        derecha: usize,
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Filosofo</span> {
    <span class='ident'>nombre</span>: <span class='ident'>String</span>,
    <span class='ident'>izquierda</span>: <span class='ident'>usize</span>,
    <span class='ident'>derecha</span>: <span class='ident'>usize</span>,
}
</pre>

<p>Vamos a necesitar agregar dos campos mas a nuestra estructura <code>Filosofo</code>. Cada filosofo tendrá dos tenedores: el de la izquierda, y el de la derecha. Usaremos el tipo <code>usize</code> para indicarlos, debido a que este es el tipo con el cual se indexan los vectores. Estos dos valores serán indices en los <code>tenedores</code> que nuestra <code>Mesa</code> posee.</p>
<span class='rusttest'>fn main() {
    fn new(nombre: &amp;str, izquierda: usize, derecha: usize) -&gt; Filosofo {
        Filosofo {
            nombre: nombre.to_string(),
            izquierda: izquierda,
            derecha: derecha,
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>nombre</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>izquierda</span>: <span class='ident'>usize</span>, <span class='ident'>derecha</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>Filosofo</span> {
    <span class='ident'>Filosofo</span> {
        <span class='ident'>nombre</span>: <span class='ident'>nombre</span>.<span class='ident'>to_string</span>(),
        <span class='ident'>izquierda</span>: <span class='ident'>izquierda</span>,
        <span class='ident'>derecha</span>: <span class='ident'>derecha</span>,
    }
}
</pre>

<p>Ahora necesitamos construir esos valores <code>izquierda</code> y <code>derecha</code>, de manera que podamos agregarlos a <code>new()</code>.</p>
<span class='rusttest'>fn main() {
    fn comer(&amp;self, mesa: &amp;Mesa) {
        let _izquierda = mesa.tenedores[self.izquierda].lock().unwrap();
        let _derecha = mesa.tenedores[self.derecha].lock().unwrap();
    
        println!(&quot;{} esta comiendo.&quot;, self.nombre);
    
        thread::sleep_ms(1000);
    
        println!(&quot;{} ha finalizado de comer.&quot;, self.nombre);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>comer</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>mesa</span>: <span class='kw-2'>&amp;</span><span class='ident'>Mesa</span>) {
    <span class='kw'>let</span> <span class='ident'>_izquierda</span> <span class='op'>=</span> <span class='ident'>mesa</span>.<span class='ident'>tenedores</span>[<span class='self'>self</span>.<span class='ident'>izquierda</span>].<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
    <span class='kw'>let</span> <span class='ident'>_derecha</span> <span class='op'>=</span> <span class='ident'>mesa</span>.<span class='ident'>tenedores</span>[<span class='self'>self</span>.<span class='ident'>derecha</span>].<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} esta comiendo.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);

    <span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>1000</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} ha finalizado de comer.&quot;</span>, <span class='self'>self</span>.<span class='ident'>nombre</span>);
}
</pre>

<p>Tenemos dos nuevas lineas, también hemos agregado un argumento, <code>mesa</code>. Accedemos a la lista de tenedores de la <code>Mesa</code>, y después usamos <code>self.izquierda</code> y <code>self.derecha</code> para acceder al tenedor en un indice en particular. Eso nos da acceso al <code>Mutex</code> en ese indice, en donde llamamos <code>lock()</code>. Si el mutex esta siendo accedido actualmente por alguien mas, nos bloquearemos hasta que este disponible.</p>

<p>La llamada a <code>lock()</code> puede fallar, y si lo hace, queremos terminar abruptamente. En este caso el error que puede ocurrir es que el mutex este <a href="../std/sync/struct.Mutex.html#poisoning">‘envenenado’</a> (‘poisoned’), que es lo que ocurre cuando el hilo hace pánico mientras el mantiene el bloqueo. Debido a que esto no debería ocurrir, simplemente usamos <code>unwrap()</code>.</p>

<p>Otra cosa extraña acerca de esta lineas: hemos nombrado los resultados <code>_izquierda</code> and <code>_derecha</code>. Que hay con ese sub-guion? Bueno, en realidad no planeamos <em>usar</em> el valor dentro del bloqueo. Solo queremos adquirirlo. A consecuencia, Rust nos advertirá que nunca usamos el valor. A través del uso del sub-guion le decimos a Rust que es lo que quisimos, de esa manera no generara la advertencia.</p>

<p>Que acerca de soltar el bloqueo?, Bueno, esto ocurrirá cuando <code>_izquierda</code> y <code>_derecha</code> salgan de ámbito, automáticamente.</p>
<span class='rusttest'>fn main() {
        let mesa = Arc::new(Mesa { tenedores: vec![
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
        ]});
    
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>let</span> <span class='ident'>mesa</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Mesa</span> { <span class='ident'>tenedores</span>: <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
    ]});
</pre>

<p>A continuación, en <code>main()</code>, creamos una nueva <code>Mesa</code> y la envolvemos en un <code>Arc&lt;T&gt;</code>. ‘arc’ proviene de ‘atomic reference count’ (cuenta de referencias atómica), necesitamos compartir nuestra <code>Mesa</code> entre multiples hilos. A media que la compartimos, la cuenta de referencias subirá, y cuando cada hilo termine, ira bajando.</p>
<span class='rusttest'>fn main() {
    let filosofos = vec![
        Filosofo::new(&quot;Judith Butler&quot;, 0, 1),
        Filosofo::new(&quot;Gilles Deleuze&quot;, 1, 2),
        Filosofo::new(&quot;Karl Marx&quot;, 2, 3),
        Filosofo::new(&quot;Emma Goldman&quot;, 3, 4),
        Filosofo::new(&quot;Michel Foucault&quot;, 0, 4),
    ];
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>filosofos</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
    <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Judith Butler&quot;</span>, <span class='number'>0</span>, <span class='number'>1</span>),
    <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Gilles Deleuze&quot;</span>, <span class='number'>1</span>, <span class='number'>2</span>),
    <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Karl Marx&quot;</span>, <span class='number'>2</span>, <span class='number'>3</span>),
    <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Emma Goldman&quot;</span>, <span class='number'>3</span>, <span class='number'>4</span>),
    <span class='ident'>Filosofo</span>::<span class='ident'>new</span>(<span class='string'>&quot;Michel Foucault&quot;</span>, <span class='number'>0</span>, <span class='number'>4</span>),
];
</pre>

<p>Necesitamos pasar nuestros valores <code>izquierda</code> and <code>derecha</code> a los constructores de nuestros <code>Filosofo</code>s. Pero hay un detalle mas aquí, y es <em>muy</em> importante. Si observas al patrón, es consistente hasta el final,  Monsieur Foucault debe tener <code>4, 0</code> como argumentos, pero en vez de esto tiene <code>0, 4</code>. Esto es lo que previene deadlocks, en efecto: uno de los filósofos es zurdo! Esa es una forma de resolver el problema, y en mi opinion, es la mas simple.</p>
<span class='rusttest'>fn main() {
    let handles: Vec&lt;_&gt; = filosofos.into_iter().map(|f| {
        let mesa = mesa.clone();
    
        thread::spawn(move || {
            f.comer(&amp;mesa);
        })
    }).collect();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>filosofos</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>f</span><span class='op'>|</span> {
    <span class='kw'>let</span> <span class='ident'>mesa</span> <span class='op'>=</span> <span class='ident'>mesa</span>.<span class='ident'>clone</span>();

    <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
        <span class='ident'>f</span>.<span class='ident'>comer</span>(<span class='kw-2'>&amp;</span><span class='ident'>mesa</span>);
    })
}).<span class='ident'>collect</span>();
</pre>

<p>Finalmente, dentro de nuestro ciclo <code>map()</code>/<code>collect()</code>, llamamos <code>mesa.clone()</code>. El método <code>clone()</code> en <code>Arc&lt;T&gt;</code> es lo que incrementa la cuenta de referencias, y cuando sale de ámbito, la decrementa. Notaras que podemos introducir una nueva variable <code>mesa</code>, y esta sobre escribirá (shadow) la anterior. Esto es frecuentemente usado de manera tal de no tener que inventar dos nombres únicos.</p>

<p>Con todo esto, nuestro programa funciona! Solo dos filosofo pueden comer en un momento dado y en consecuencia tendrás salida se vera así:</p>

<pre><code class="language-text">Gilles Deleuze esta comiendo.
Emma Goldman esta comiendo.
Emma Goldman ha finalizado de comer.
Gilles Deleuze ha finalizado de comer.
Judith Butler esta comiendo.
Karl Marx esta comiendo.
Judith Butler ha finalizado de comer.
Michel Foucault esta comiendo.
Karl Marx ha finalizado de comer.
Michel Foucault ha finalizado de comer.
</code></pre>

<p>Felicitaciones! Haz implementado un problema clásico de concurrencia en Rust.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
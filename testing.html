<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Pruebas</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Monticulo</a>
</li>
<li><a class='active' href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilacion Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentacion</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribucion</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> Ciclos for</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> Ciclos while</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> Referencias y Prestamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Sintaxis de Metodos</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Genericos</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Rasgos</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Objetos de Razgo</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Sintaxis de Llamada a Funciones Universal</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates y Modulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Conversion entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Tipos sin Tamano</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Inverstigacion Academica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Pruebas</h1>
    <blockquote>
<p>Probar programas puede ser una forma efectiva de mostrar la presencia de bugs, pero es desesperanzadamente inadecuada para mostrar su ausencia.
Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>

<p>Hablaremos acerca de como probar código Rust. De lo que no estaremos hablando es acerca de la manera correcta de probar código Rust. Hay muchas escuelas de pensamiento en relación a la forma correcta e incorrecta de escribir pruebas. Todos esos enfoques usan las mismas herramientas básicas, en esta sección te mostraremos la sintaxis para hacer uso de ellas.</p>

<h1 id="el-atributo-test" class='section-header'><a
                           href="#el-atributo-test">El atributo <code>test</code></a></h1>
<p>En esencia, una prueba en Rust es una función que esta anotada con el atributo <code>test</code>. Vamos a crear un nuevo proyecto llamado <code>sumador</code> con Cargo:</p>

<pre><code class="language-bash">$ cargo new sumador
$ cd adder
</code></pre>

<p>Cargo generara automáticamente una prueba simple cuando creas un proyecto nuevo.
He aqui el contenido de <code>src/lib.rs</code>:</p>
<span class='rusttest'>fn main() {
    #[test]
    fn it_works() {
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
}
</pre>

<p>Nota el <code>#[test]</code>. Este atributo indica que esta es una función de prueba. Actualmente no tiene cuerpo. Pero eso es suficiente para pasar! Podemos ejecutar los tests con <code>cargo test</code>:</p>

<pre><code class="language-bash">$ cargo test
  Compiling sumador v0.1.0 (file:///Users/goyox86/Code/rust/sumador)
     Running target/debug/sumador-ba17f4f6708ca3b9

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests sumador

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Cargo compilo y ejecuto nuestros tests. Hay dos conjuntos de salida aquí: uno para las pruebas que nosotros escribimos, y otro para los tests de documentación. Hablaremos acerca de estos mas tarde. Por ahora veamos esta linea:</p>

<pre><code class="language-text">test it_works ... ok
</code></pre>

<p>Nota el <code>it_works</code>. Proviene del nombre de nuestra función:</p>
<span class='rusttest'>fn main() {
    fn it_works() {
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
</pre>

<p>También obtenemos una linea de resumen:</p>

<pre><code class="language-text">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Entonces, porque nuestras pruebas vacías pasan? Cualquier prueba que no haga <code>panic!</code> pasa, y cualquier prueba que hace <code>panic!</code> falla. Hagamos fallar a nuestra prueba:</p>
<span class='rusttest'>fn main() {
    #[test]
    fn it_works() {
        assert!(false);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='boolval'>false</span>);
}
</pre>

<p><code>assert!</code> es una macro proporcionada por Rust la cual toma un argumento: si el argumento es <code>true</code>, nada pasa. Si el argumento es <code>false</code>, <code>assert!</code> hace <code>panic!</code>. Ejecutemos nuestras pruebas otra vez:</p>

<pre><code class="language-bash">$ cargo test
   Compiling sumador v0.1.0 (file:///Users/goyox86/Code/rust/sumador)
     Running target/debug/sumador-ba17f4f6708ca3b9

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
    thread &#39;it_works&#39; panicked at &#39;assertion failed: false&#39;, src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread &#39;&lt;main&gt;&#39; panicked at &#39;Some tests failed&#39;, /Users/rustbuild/src/rust-buildbot/slave/stable-dist-rustc-mac/build/src/libtest/lib.rs:259
</code></pre>

<p>Rust nos indica que nuestra prueba ha fallado:</p>

<pre><code class="language-text">test it_works ... FAILED
</code></pre>

<p>Y se refleja en la linea de resumen:</p>

<pre><code class="language-text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>

<p>También obtenemos un valor de retorno diferente a cero:</p>

<pre><code class="language-bash">$ echo $?
101
</code></pre>

<p>Esto es muy útil para integrar <code>cargo test</code> con otras herramientas.</p>

<p>Podemos invertir la falla de nuestras pruebas con otro atributo: <code>should_panic</code>:</p>
<span class='rusttest'>fn main() {
    #[test]
    #[should_panic]
    fn it_works() {
        assert!(false);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='attribute'>#[<span class='ident'>should_panic</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='boolval'>false</span>);
}
</pre>

<p>Estas pruebas tendrán éxito si hacemos <code>panic!</code> y fallaran si se completan. Probemos:</p>

<pre><code class="language-bash">$ cargo test
   Compiling sumador v0.1.0 (file:///Users/goyox86/Code/rust/sumador)
     Running target/debug/sumador-ba17f4f6708ca3b9

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests sumador

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Rust proporciona otra macro, <code>assert_eq!</code>, que compara dos argumentos para verificar igualdad:</p>
<span class='rusttest'>fn main() {
    #[test]
    #[should_panic]
    fn it_works() {
        assert_eq!(&quot;Hola&quot;, &quot;mundo&quot;);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='attribute'>#[<span class='ident'>should_panic</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;Hola&quot;</span>, <span class='string'>&quot;mundo&quot;</span>);
}
</pre>

<p>Esta prueba pasa o falla? Debido a la presencia del atributo <code>should_panic</code>, pasa:</p>

<pre><code class="language-bash">$ cargo test
   Compiling sumador v0.1.0 (file:///Users/goyox86/Code/rust/sumador)
     Running target/debug/sumador-ba17f4f6708ca3b9

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests sumador

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Las pruebas <code>should_panic</code> pueden ser frágiles, es difícil garantizar que la prueba no falló por una razón inesperada. Para ayudar en esto, un parámetro opcional <code>expected</code> puede ser agregado a el atributo <code>should_panic</code>. La prueba se asegurara que el mensaje de error contenga el mensaje proporcionado. Una versión mas segura de la prueba seria:</p>
<span class='rusttest'>fn main() {
    #[test]
    #[should_panic(expected = &quot;assertion failed&quot;)]
    fn it_works() {
        assert_eq!(&quot;Hola&quot;, &quot;mundo&quot;);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='attribute'>#[<span class='ident'>should_panic</span>(<span class='ident'>expected</span> <span class='op'>=</span> <span class='string'>&quot;assertion failed&quot;</span>)]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;Hola&quot;</span>, <span class='string'>&quot;mundo&quot;</span>);
}
</pre>

<p>Eso fue todo para lo básico! Escribamos una prueba &#39;real&#39;:</p>
<span class='rusttest'>fn main() {
    pub fn suma_dos(a: i32) -&gt; i32 {
        a + 2
    }
    
    #[test]
    fn it_works() {
        assert_eq!(4, suma_dos(2));
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>suma_dos</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>a</span> <span class='op'>+</span> <span class='number'>2</span>
}

<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>suma_dos</span>(<span class='number'>2</span>));
}
</pre>

<p>Este es un uso muy común de <code>assert_eq!</code>: llamar alguna función con algunos argumentos conocidos y comparar la salida de dicha llamada con la salida esperada.</p>

<h1 id="el-modulo-tests" class='section-header'><a
                           href="#el-modulo-tests">El modulo <code>tests</code></a></h1>
<p>Hay una forma en la cual nuestro ejemplo no es idiomático: le falta el modulo <code>tests</code>. La manera idiomática de escribir nuestro ejemplo luce así:</p>
<span class='rusttest'>fn main() {
    pub fn suma_dos(a: i32) -&gt; i32 {
        a + 2
    }
    
    #[cfg(test)]
    mod tests {
        use super::suma_dos;
    
        #[test]
        fn it_works() {
            assert_eq!(4, suma_dos(2));
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>suma_dos</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>a</span> <span class='op'>+</span> <span class='number'>2</span>
}

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>tests</span> {
    <span class='kw'>use</span> <span class='ident'>super</span>::<span class='ident'>suma_dos</span>;

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>it_works</span>() {
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>suma_dos</span>(<span class='number'>2</span>));
    }
}
</pre>

<p>Hay unos cuantos cambios acá. El primero es la inclusion de un <code>mod tests</code> con un atributo <code>cfg</code>. El modulo nos permite agrupar todas nuestras pruebas, y también nos permite definir funciones de soporte de ser necesario, todo eso no forma parte de nuestro crate. El atributo <code>cfg</code> solo compila nuestro código de pruebas si estuviéramos intentando correr las pruebas. Esto puede ahorrar tiempo de compilación, también se asegura que nuestras pruebas queden completamente excluidas de una compilación normal.</p>

<p>El segundo cambio es la declaración <code>use</code>. Debido a que estamos en un modulo interno, necesitamos hace disponible a nuestra prueba dentro de nuestro ámbito actual. Esto puede ser molesto si posees un modulo grande, y es por ello que es común el uso de la facilidad <code>glob</code>. Cambiemos nuestro <code>src/lib.rs</code> para que haga uso de ello:</p>
<span class='rusttest'>
fn main() {
    pub fn suma_dos(a: i32) -&gt; i32 {
        a + 2
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn it_works() {
            assert_eq!(4, suma_dos(2));
        }
    }
    
}</span><pre class='rust rust-example-rendered'>

<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>suma_dos</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>a</span> <span class='op'>+</span> <span class='number'>2</span>
}

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>tests</span> {
    <span class='kw'>use</span> <span class='ident'>super</span>::<span class='op'>*</span>;

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>it_works</span>() {
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>suma_dos</span>(<span class='number'>2</span>));
    }
}
</pre>

<p>Nota la linea <code>use</code> diferente. Ahora ejecutamos nuestras pruebas:</p>

<pre><code class="language-bash">$ cargo test
   Compiling sumador v0.1.0 (file:///Users/goyox86/Code/rust/sumador)
     Running target/debug/sumador-ba17f4f6708ca3b9

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests sumador

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Funciona!</p>

<p>La convención actual es usar el modulo <code>tests</code> para contener tus pruebas de &quot;estilo-unitario&quot;. Cualquier cosa que solo pruebe un pequeño pedazo de funcionalidad va aquí. Pero que acerca de las pruebas &quot;estilo-integracion&quot;? Para ellas, tenemos el directorio <code>tests</code>.</p>

<h1 id="el-directorio-tests" class='section-header'><a
                           href="#el-directorio-tests">El directorio <code>tests</code></a></h1>
<p>Para escribir una prueba de integración, creemos un directorio <code>tests</code> y coloquemos un archivo <code>tests/lib.rs</code> dentro, con el siguiente de contenido:</p>
<span class='rusttest'>fn main() {
    extern crate sumador;
    
    #[test]
    fn it_works() {
        assert_eq!(4, sumador::suma_dos(2));
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>sumador</span>;

<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>sumador</span>::<span class='ident'>suma_dos</span>(<span class='number'>2</span>));
}
</pre>

<p>Luce similar a nuestras pruebas anteriores, pero ligeramente diferente. Ahora tenemos un <code>extern crate sumador</code> al principio. Esto es debido a que las pruebas en el directorio son un crate separado, entonces debemos importar nuestra biblioteca. Esto es también el porque <code>tests</code> es un lugar idóneo pera escribir tests de integración: estas pruebas usan la biblioteca justo como cualquier otro consumidor lo haría.</p>

<p>Ejecutemoslas:</p>

<pre><code class="language-bash">$ cargo test
   Compiling sumador v0.1.0 (file:///Users/goyox86/Code/rust/sumador)
     Running target/debug/lib-f71036151ee98b04

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/sumador-ba17f4f6708ca3b9

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests sumador

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Ahora tenemos tres secciones: nuestras pruebas anteriores también fueron ejecutadas, junto con la nueva prueba de integración.</p>

<p>Eso fue todo para el directorio <code>tests</code>. El modulo <code>tests</code> no es necesario aquí, debido a que el modulo completo esta dedicado a pruebas.</p>

<p>Finalmente echemos un vistazo a esa tercera sección: pruebas de documentación.</p>

<h1 id="pruebas-de-documentación" class='section-header'><a
                           href="#pruebas-de-documentación">Pruebas de documentación</a></h1>
<p>Nada es mejor que documentación con ejemplos. Nada es peor que ejemplos que no funcionan, debido a que el código a cambiado desde que la documentación fue escrita. Respecto a esto, Rust soporta la ejecución automática de los ejemplos presentes en tu documentación. He aquí un <code>src/lib.rs</code> pulido con ejemplos:</p>
<span class='rusttest'>fn main() {
    //! The `adder` crate provides functions that add numbers to other numbers.
    //!
    //! # Examples
    //!
    //! ```
    //! assert_eq!(4, adder::add_two(2));
    //! ```
    
    /// This function adds two to its argument.
    ///
    /// # Examples
    ///
    /// ```
    /// use adder::add_two;
    ///
    /// assert_eq!(4, add_two(2));
    /// ```
    pub fn add_two(a: i32) -&gt; i32 {
        a + 2
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn it_works() {
            assert_eq!(4, add_two(2));
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='doccomment'>//! The `adder` crate provides functions that add numbers to other numbers.</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! # Examples</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ```</span>
<span class='doccomment'>//! assert_eq!(4, adder::add_two(2));</span>
<span class='doccomment'>//! ```</span>

<span class='doccomment'>/// This function adds two to its argument.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// # Examples</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// use adder::add_two;</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// assert_eq!(4, add_two(2));</span>
<span class='doccomment'>/// ```</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>add_two</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>a</span> <span class='op'>+</span> <span class='number'>2</span>
}

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>tests</span> {
    <span class='kw'>use</span> <span class='ident'>super</span>::<span class='op'>*</span>;

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>it_works</span>() {
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>add_two</span>(<span class='number'>2</span>));
    }
}
</pre>

<p>Nota la documentación a nivel de modulo con <code>//!</code> y la documentación a nivel de función con <code>///</code>. La documentación de Rust soporta Markdown en comentarios y graves (```) triples delimitan bloques de código. Es convencional incluir la sección <code># Examples</code>, exactamente asi, seguida por los ejemplos.</p>

<p>Ejecutemos las pruebas nuevamente:</p>

<pre><code class="language-bash">$ cargo test
  Compiling sumador v0.1.0 (file:///Users/goyox86/Code/rust/sumador)
     Running target/debug/lib-f71036151ee98b04

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/sumador-ba17f4f6708ca3b9

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests sumador

running 2 tests
test _0 ... ok
test suma_dos_0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Ahora tenemos los tres tipos de pruebas corriendo! Nota los nombres de las pruebas de documentación: el <code>_0</code> es generado para la prueba del modulo, y <code>suma_dos_0</code> para la prueba de función. Estos números se auto incrementaran con nombres como <code>suma_dos_1</code> a medida que mas ejemplos son agregados.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
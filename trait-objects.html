<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Objetos Trait</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a class='active' href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patrones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Objetos Trait</h1>
    <p>Cuando el código involucra polimorfismo, es necesario un mecanismo para determinar que versión especifica debe ser ejecutada. Dicho mecanismo es denominado <code>despacho</code>. Hay dos formas mayores de despacho: despacho estático y despacho dinámico. Si bien es cierto que Rust prefiere el despacho estático, también soporta despacho dinámico a través de un mecanismo llamado ‘objetos trait’.</p>

<h2 id='bases' class='section-header'><a href='#bases'>Bases</a></h2>
<p>Por el resto de este capitulo, necesitaremos un trait y algunas implementaciones. Creemos uno simple, <code>Foo</code>. <code>Foo</code> posee un solo método que retorna un <code>String</code>.</p>
<span class='rusttest'>fn main() {
    trait Foo {
        fn metodo(&amp;self) -&gt; String;
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>metodo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span>;
}</pre>

<p>También implementaremos este trait para <code>u8</code> y <code>String</code>:</p>
<span class='rusttest'>fn main() {
    trait Foo { fn metodo(&amp;self) -&gt; String; }
    impl Foo for u8 {
        fn metodo(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
    }
    
    impl Foo for String {
        fn metodo(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>u8</span> {
    <span class='kw'>fn</span> <span class='ident'>metodo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> { <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;u8: {}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>metodo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> { <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;string: {}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}</pre>

<h2 id='despacho-estático' class='section-header'><a href='#despacho-estático'>Despacho estático</a></h2>
<p>Podemos usar el trait para efectuar despacho estático mediante el uso de limites de trait:</p>
<span class='rusttest'>trait Foo { fn metodo(&amp;self) -&gt; String; }
impl Foo for u8 { fn metodo(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn metodo(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn hacer_algo&lt;T: Foo&gt;(x: T) {
    x.metodo();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hola&quot;.to_string();

    hacer_algo(x);
    hacer_algo(y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>hacer_algo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='ident'>x</span>.<span class='ident'>metodo</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='string'>&quot;Hola&quot;</span>.<span class='ident'>to_string</span>();

    <span class='ident'>hacer_algo</span>(<span class='ident'>x</span>);
    <span class='ident'>hacer_algo</span>(<span class='ident'>y</span>);
}</pre>

<p>Rust utiliza ‘monomorfizacion’ para el despacho estático en este código. Lo que significa que creara una versión especial de <code>hacer_algo()</code> para ambos <code>u8</code> y <code>String</code>, reemplazando luego los lugares de llamada con invocaciones a estas funciones especializadas. En otras palabras, Rust genera algo así:</p>
<span class='rusttest'>trait Foo { fn metodo(&amp;self) -&gt; String; }
impl Foo for u8 { fn metodo(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn metodo(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn hacer_algo_u8(x: u8) {
    x.metodo();
}

fn hacer_algo_string(x: String) {
    x.metodo();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hola&quot;.to_string();

    hacer_algo_u8(x);
    hacer_algo_string(y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>hacer_algo_u8</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>) {
    <span class='ident'>x</span>.<span class='ident'>metodo</span>();
}

<span class='kw'>fn</span> <span class='ident'>hacer_algo_string</span>(<span class='ident'>x</span>: <span class='ident'>String</span>) {
    <span class='ident'>x</span>.<span class='ident'>metodo</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='string'>&quot;Hola&quot;</span>.<span class='ident'>to_string</span>();

    <span class='ident'>hacer_algo_u8</span>(<span class='ident'>x</span>);
    <span class='ident'>hacer_algo_string</span>(<span class='ident'>y</span>);
}</pre>

<p>Lo anterior posee una gran ventaja: el despacho estático permite que las llamadas a función puedan ser insertadas en linea debido a que el receptor es conocido en tiempo de compilación, y la inserción en linea es clave para una buena optimizacion. El despacho estático es rápido, pero viene con una desventaja: ‘código inflado’ (‘code bloat’), a consecuencia de las repetidas copias de la misma función que son insertadas en el binario, una para cada tipo.</p>

<p>Ademas, los compiladores no son perfectos y pueden “optimizar” código haciendolo mas lento. Por ejemplo, funciones insertadas en linea de manera ansiosa inflaran la cache de instrucciones (y el cache gobierna todo a nuestro alrededor). Es por ello que <code>#[inline]</code> y <code>#[inline(always)]</code> deben ser usadas con cautela, y una razón por la cual usar despacho dinámico es algunas veces mas eficiente.</p>

<p>Sin embargo, el caso común es que el despacho estático sea mas eficiente. Uno puede tener una delgada función envoltorio despachada de manera estática efectuando despacho dinámico, pero no vice versa, es decir; las llamadas estáticas son mas flexibles. Es por esto que la biblioteca estándar intenta ser despachada dinámicamente siempre y cuando sea posible.</p>

<h2 id='despacho-dinámico' class='section-header'><a href='#despacho-dinámico'>Despacho dinámico</a></h2>
<p>Rust proporciona despacho dinámico a través de una facilidad denominada ‘objetos trait’. Los objetos trait, como <code>&amp;Foo</code> o <code>Box&lt;Foo&gt;</code>, son valores normales que almacenan un valor de <em>cualquier</em> tipo que implementa el trait determinado, en donde el tipo preciso solo puede ser determinado en tiempo de ejecución.</p>

<p>Un objeto trait puede ser obtenido de un apuntador a un tipo concreto que implemente el trait <em>convirtiéndolo</em> (e.j. <code>&amp;x as &amp;Foo</code>) o aplicándole <em>coercion</em> (e.j. usando <code>&amp;x</code> como un argumento a una función que recibe <code>&amp;Foo</code>).</p>

<p>Esas coerciones y conversiones también funcionan para apuntadores como <code>&amp;mut T</code> a <code>&amp;mut Foo</code> y <code>Box&lt;T&gt;</code> a <code>Box&lt;Foo&gt;</code>, pero eso es todo hasta el momento. Las coerciones y conversiones son idénticas.</p>

<p>Esta operación puede ser vista como el ‘borrado’ del conocimiento del compilador acerca del tipo especifico del apuntador, y es por ello que los objetos traits son a veces referidos como <code>borrado de tipos</code>.</p>

<p>Volviendo a el ejemplo anterior, podemos usar el mismo trait para llevar a cabo despacho dinámico con conversión de objetos trait:</p>
<span class='rusttest'>trait Foo { fn metodo(&amp;self) -&gt; String; }
impl Foo for u8 { fn metodo(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn metodo(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn hacer_algo(x: &amp;Foo) {
    x.metodo();
}

fn main() {
    let x = 5u8;
    hacer_algo(&amp;x as &amp;Foo);
}
</span><pre class='rust rust-example-rendered'>

<span class='kw'>fn</span> <span class='ident'>hacer_algo</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>) {
    <span class='ident'>x</span>.<span class='ident'>metodo</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='ident'>hacer_algo</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>);
}</pre>

<p>o a traves de la coercion:</p>
<span class='rusttest'>trait Foo { fn metodo(&amp;self) -&gt; String; }
impl Foo for u8 { fn metodo(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn metodo(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn hacer_algo(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = &quot;Hola&quot;.to_string();
    hacer_algo(&amp;x);
}
</span><pre class='rust rust-example-rendered'>

<span class='kw'>fn</span> <span class='ident'>hacer_algo</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;Hola&quot;</span>.<span class='ident'>to_string</span>();
    <span class='ident'>hacer_algo</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span>);
}</pre>

<p>Una función que recibe un objeto trait no es especializada para cada uno de los tipos que implementan <code>Foo</code>: solo una copia es generada, resultando algunas veces (pero no siempre) en menos inflación de código. Sin embargo, el despacho dinámico viene con el costo de requerir las llamadas mas lentas a funciones virtuales, efectivamente inhibiendo cualquier posibilidad de inserción en linea y las optimizaciones relacionadas.</p>

<h3 id='porque-apuntadores' class='section-header'><a href='#porque-apuntadores'>Porque apuntadores?</a></h3>
<p>Rust, a diferencia de muchos lenguajes administrados, no coloca cosas detrás de apuntadores por defecto, lo que se traduce en que los tipos tengan diferentes tamaños. Conocer el tamaño de un valor en tiempo de compilación es importante para cosas como: pasarlo como argumento a una función, moverlo en la pila y asignarle (y deasignarle) espacio en el montículo para su almacenamiento.</p>

<p>Para <code>Foo</code>, necesitaríamos tener un valor que podría ser mas pequeño que un <code>String</code> (24 bytes) o un <code>u8</code> (1 byte), así como cualquier otro tipo que pueda implementar <code>Foo</code> en crates dependientes (cualquier numero de bytes). No hay forma de garantizar que este ultimo caso pueda funcionar si los valores no son almacenados en un apuntador, puesto que esos otros tipos pueden ser de tamaño arbitrario.</p>

<p>Colocar el valor detrás de un apuntador significa que el tamaño del valor no es relevante cuando estemos lanzando un objeto trait por los alrededores, solo el tamaño del apuntador en si mismo.</p>

<h3 id='representación' class='section-header'><a href='#representación'>Representación</a></h3>
<p>Los métodos del trait pueden ser llamados en un objeto trait a través de un registro de apuntadores a función tradicionalmente llamado ‘vtable’ (creado y administrado por el compilador).</p>

<p>Los objetos trait son simples y complejos al mismo tiempo: su representation y distribución es bastante directa, pero existen algunos mensajes de error un poco raros y algunos comportamientos sorpresivos por descubrir.</p>

<p>Comencemos por lo mas simple, la representación de un objeto trait en tiempo de ejecución. El modulo <code>std::raw</code> contiene structs con distribuciones que son igual de complicadas que las de los tipos integrados, <a href="../std/raw/struct.TraitObject.html">incluyendo los objetos trait</a>:</p>
<span class='rusttest'>fn main() {
    mod foo {
    pub struct TraitObject {
        pub data: *mut (),
        pub vtable: *mut (),
    }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>TraitObject</span> {
    <span class='kw'>pub</span> <span class='ident'>data</span>: <span class='op'>*</span><span class='kw-2'>mut</span> (),
    <span class='kw'>pub</span> <span class='ident'>vtable</span>: <span class='op'>*</span><span class='kw-2'>mut</span> (),
}</pre>

<p>Eso es, un trait object como <code>&amp;Foo</code> consiste de un apuntador ‘data’ y un apuntador ‘vtable’.</p>

<p>El apuntador data apunta hacia los datos (de un tipo desconocido <code>T</code>) que guarda el objeto trait, y el vtable pointer apunta a la vtable (table de metodos virtuales’) (‘virtual method table’) correspondiente a la implementación de <code>Foo</code> para <code>T</code>.</p>

<p>Una vtable es esencialmente una struct de apuntadores a función, apuntando al segmento concreto de código maquina para cada implementación de metodo. Una llamada a metodo como <code>objeto_trait.metodo()</code> retornara el apuntador correcto desde la vtable y luego hará una llamada dinámica de este. Por ejemplo:</p>
<span class='rusttest'>fn main() {
    struct FooVtable {
        destructor: fn(*mut ()),
        tamano: usize,
        alineacion: usize,
        metodo: fn(*const ()) -&gt; String,
    }
    
    // u8:
    
    fn llamar_metodo_en_u8(x: *const ()) -&gt; String {
        // el compilador garantiza que esta función solo sea llamada
        // con `x` apuntando a un u8
        let byte: &amp;u8 = unsafe { &amp;*(x as *const u8) };
    
        byte.metodo()
    }
    
    static Foo_vtable_para_u8: FooVtable = FooVtable {
        destructor: /* magia del compilador */,
        tamano: 1,
        alineacion: 1,
    
        // conversion a a un apuntador a función
        metodo: llamar_metodo_en_u8 as fn(*const ()) -&gt; String,
    };
    
    
    // String:
    
    fn llamar_metodo_en_String(x: *const ()) -&gt; String {
        // el compilador garantiza que esta función solo sea llamada
        // con `x` apuntando a un String
        let string: &amp;String = unsafe { &amp;*(x as *const String) };
    
        string.metodo()
    }
    
    static Foo_vtable_para_String: FooVtable = FooVtable {
        destructor: /* magia del compilador */,
        // valores para una computadora de 64 bits, dividelos por la mitad para una de 32
        tamano: 24,
        alineacion: 8,
    
        metodo: llamar_metodo_en_String as fn(*const ()) -&gt; String,
    };
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw-2'>mut</span> ()),
    <span class='ident'>tamano</span>: <span class='ident'>usize</span>,
    <span class='ident'>alineacion</span>: <span class='ident'>usize</span>,
    <span class='ident'>metodo</span>: <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
}

<span class='comment'>// u8:</span>

<span class='kw'>fn</span> <span class='ident'>llamar_metodo_en_u8</span>(<span class='ident'>x</span>: <span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='comment'>// el compilador garantiza que esta función solo sea llamada</span>
    <span class='comment'>// con `x` apuntando a un u8</span>
    <span class='kw'>let</span> <span class='ident'>byte</span>: <span class='kw-2'>&amp;</span><span class='ident'>u8</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='op'>*</span>(<span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) };

    <span class='ident'>byte</span>.<span class='ident'>metodo</span>()
}

<span class='kw'>static</span> <span class='ident'>Foo_vtable_para_u8</span>: <span class='ident'>FooVtable</span> <span class='op'>=</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='comment'>/* magia del compilador */</span>,
    <span class='ident'>tamano</span>: <span class='number'>1</span>,
    <span class='ident'>alineacion</span>: <span class='number'>1</span>,

    <span class='comment'>// conversion a a un apuntador a función</span>
    <span class='ident'>metodo</span>: <span class='ident'>llamar_metodo_en_u8</span> <span class='kw'>as</span> <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
};


<span class='comment'>// String:</span>

<span class='kw'>fn</span> <span class='ident'>llamar_metodo_en_String</span>(<span class='ident'>x</span>: <span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='comment'>// el compilador garantiza que esta función solo sea llamada</span>
    <span class='comment'>// con `x` apuntando a un String</span>
    <span class='kw'>let</span> <span class='ident'>string</span>: <span class='kw-2'>&amp;</span><span class='ident'>String</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='op'>*</span>(<span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>String</span>) };

    <span class='ident'>string</span>.<span class='ident'>metodo</span>()
}

<span class='kw'>static</span> <span class='ident'>Foo_vtable_para_String</span>: <span class='ident'>FooVtable</span> <span class='op'>=</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='comment'>/* magia del compilador */</span>,
    <span class='comment'>// valores para una computadora de 64 bits, dividelos por la mitad para una de 32</span>
    <span class='ident'>tamano</span>: <span class='number'>24</span>,
    <span class='ident'>alineacion</span>: <span class='number'>8</span>,

    <span class='ident'>metodo</span>: <span class='ident'>llamar_metodo_en_String</span> <span class='kw'>as</span> <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
};</pre>

<p>El campo <code>destructor</code> en cada vtable apunta a una función que limpiara todos los recursos del tipo de la vtable: para <code>u8</code> es trivial, pero para <code>String</code> liberara memoria. Esto es necesario para adueñarse de objetos trait como <code>Box&lt;Foo&gt;</code>, que necesitan limpiar ambos la asignación <code>Box</code> así como el tipo interno cuando salgan de ámbito. Los campos <code>tamano</code> y <code>alineacion</code> almacenan el tamaño del tipo borrado, y sus requerimientos de alineación; estos son esencialmente no usados por el momento puesto que la información es embebida en el destructor, pero sera usada en el futuro, a medida que los objetos trait sean progresivamente hechos mas flexibles.</p>

<p>Supongamos que tenemos algunos valores que implementen <code>Foo</code>. La forma explicita de construcción y uso de objetos trait <code>Foo</code> puede lucir un poco como (ignorando las incongruencias entre tipos: son apuntadores de cualquier manera):</p>
<span class='rusttest'>fn main() {
    let a: String = &quot;foo&quot;.to_string();
    let x: u8 = 1;
    
    // let b: &amp;Foo = &amp;a;
    let b = TraitObject {
        // almacena los datos
        data: &amp;a,
        // almacena los metodos
        vtable: &amp;Foo_vtable_para_String
    };
    
    // let y: &amp;Foo = x;
    let y = TraitObject {
        // almacena los datos
        data: &amp;x,
        // almacena los metodos
        vtable: &amp;Foo_vtable_para_u8
    };
    
    // b.metodo();
    (b.vtable.metodo)(b.data);
    
    // y.metodo();
    (y.vtable.metodo)(y.data);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>u8</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='comment'>// let b: &amp;Foo = &amp;a;</span>
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>TraitObject</span> {
    <span class='comment'>// almacena los datos</span>
    <span class='ident'>data</span>: <span class='kw-2'>&amp;</span><span class='ident'>a</span>,
    <span class='comment'>// almacena los metodos</span>
    <span class='ident'>vtable</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo_vtable_para_String</span>
};

<span class='comment'>// let y: &amp;Foo = x;</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>TraitObject</span> {
    <span class='comment'>// almacena los datos</span>
    <span class='ident'>data</span>: <span class='kw-2'>&amp;</span><span class='ident'>x</span>,
    <span class='comment'>// almacena los metodos</span>
    <span class='ident'>vtable</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo_vtable_para_u8</span>
};

<span class='comment'>// b.metodo();</span>
(<span class='ident'>b</span>.<span class='ident'>vtable</span>.<span class='ident'>metodo</span>)(<span class='ident'>b</span>.<span class='ident'>data</span>);

<span class='comment'>// y.metodo();</span>
(<span class='ident'>y</span>.<span class='ident'>vtable</span>.<span class='ident'>metodo</span>)(<span class='ident'>y</span>.<span class='ident'>data</span>);</pre>

<h2 id='seguridad-de-objetos' class='section-header'><a href='#seguridad-de-objetos'>Seguridad de Objetos</a></h2>
<p>No todo trait puede ser usado para crear un objeto trait. Por ejemplo, los vectores implementan <code>Clone</code>, pero si intentamos crear un objeto trait:</p>
<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];
    let o = &amp;v as &amp;Clone;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>o</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>v</span> <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='ident'>Clone</span>;</pre>

<p>Obtenemos un error:</p>

<pre><code class="language-text">error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]
let o = &amp;v as &amp;Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &amp;v as &amp;Clone;
        ^~
</code></pre>

<p>El error dice que <code>Clone</code> no es ‘seguro para objetos’ (‘object-safe’). Solo los traits que son seguros para objetos pueden ser usados en la creación de objetos trait. Un trait es seguro para objetos si ambas condiciones son verdaderas:</p>

<ul>
<li>el trait no requiere que <code>Self: Sized</code></li>
<li>todos sus métodos son seguros para objetos</li>
</ul>

<p>Entonces, que hace a un metodo seguro para objetos? Cada metodo debe requerir que <code>Self: Sized</code> o todas de las siguientes:</p>

<ul>
<li>no debe tener ninguna parámetro de tipo</li>
<li>no debe usar <code>Self</code></li>
</ul>

<p>Uff! Como podemos ver, casi todas estas reglas hablan acerca de <code>Self</code>. Una buena intuición seria “exceptuando circunstancias especiales, si tu metodo de trait usa <code>Self</code>, no es seguro para objetos.”</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
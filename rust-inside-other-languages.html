<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust Dentro de Otros Lenguajes</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a class='active' href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Monticulo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilacion Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentacion</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribucion</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> Ciclos for</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> Ciclos while</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> Referencias y Prestamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Sintaxis de Metodos</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Genericos</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Rasgos</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Objetos de Razgo</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Sintaxis de Llamada a Funciones Universal</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates y Modulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Conversion entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Tipos sin Tamano</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Inverstigacion Academica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Rust Dentro de Otros Lenguajes</h1>
    <p>Para nuestro tercer proyecto, elegiremos algo que demuestra una de las mayores fortalezas de Rust: la ausencia de un entorno de ejecución.</p>

<p>A medida que las organizaciones crecen, estas de manera progresiva, hacen uso de una multitud de lenguajes de programación. Diferentes lenguajes de programación poseen diferentes fortalezas y debilidades, y una arquitectura poliglota permite usar un lenguaje en particular donde sus fortalezas hagan sentido y otro lenguaje sea débil.</p>

<p>Un area muy común en donde muchos lenguajes de programación son débiles es el performance en tiempo de ejecución. Frecuentemente, usar un lenguaje que es lento, pero ofrece mayor productividad para el programador, es un equilibrio que vale la pena. Para ayudar a mitigar esto, dichos lenguajes proveen una manera de escribir una parte de tu sistema en C y luego llamar ese código como si hubiese sido escrito en un lenguaje de mas alto nivel. Esta facilidad es denominada ‘interfaz de funciones foráneas’ (‘foreign function interface’), comúnmente abreviando a ‘FFI’.</p>

<p>Rust posee soporte para FFI en ambas direcciones: puede llamar código en C de manera fácil, pero crucialmente puede ser <em>llamado</em> tan fácilmente como C. Combinado con la ausencia de un recolector de basura y bajos requerimientos en tiempo de ejecución, Rust es un candidato para ser embebido dentro de otros lenguajes cuando necesites esos ooKmh extra.</p>

<p>Existe un <a href="ffi.html">capitulo completo dedicado a FFI</a> y sus detalles en otra parte del libro, pero en este capitulo, examinaremos el uso particular de FFI con ejemplos en Ruby, Python, y JavaScript.</p>

<h1 id="el-problema" class='section-header'><a
                           href="#el-problema">El problema</a></h1>
<p>Existen muchos problemas que podríamos haber escogido, pero elegiremos un ejemplo en el cual Rust tiene una ventaja clara por encima de otros lenguajes: computación numérica e hilos.</p>

<p>Muchos lenguajes, en honor a la consistencia, colocan números en el montículo, en vez de en la pila. Especialmente en lenguajes enfocados en programación orientada a objetos y el uso de un recolector de basura, la asignación de memoria desde el montículo es el comportamiento por defecto. Algunas veces optimizaciones pueden colocar ciertos números en la pila, pero en vez de confiar en un optimizador para realizar este trabajo, podríamos querer asegurarnos que siempre estemos usando numero primitivos en vez de algun tipo de objetos.</p>

<p>Segundo, muchos lenguajes poseen un  ‘bloqueo global del interprete’ (‘global interpreter lock’) (GIL), que limita la concurrencia en muchas situaciones. Esto es hecho en el nombre de la seguridad lo cual es un efecto positivo, pero limita la cantidad de trabajo que puede ser llevado a cabo de manera concurrente, lo cual es un gran negativo.</p>

<p>Para enfatizar estos 2 aspectos, crearemos un pequeño proyecto que usa estos dos aspectos en gran medida. Debido a que el foco del ejemplo es embeber Rust en otros lenguajes, en vez de el problema en si mismo, usaremos un ejemplo de juguete:</p>

<blockquote>
<p>Inicia diez hilos. Dentro de cada hilo, cuenta desde uno hasta cinco millones. Después que todos los hilos hayan finalizado, imprime &quot;completado!&quot;.</p>
</blockquote>

<p>He escogido cinco millones basado en mi computador en particular. He aquí un ejemplo de este código en Ruby:</p>

<pre><code class="language-ruby">threads = []

10.times do
  threads &lt;&lt; Thread.new do
    count = 0

    5_000_000.times do
      count += 1
    end
  end
end

threads.each { |t| t.join }
puts &quot;completado!&quot;
</code></pre>

<p>Intenta ejecutar este ejemplo, y escoge un numero que corra por unos segundos. Dependiendo en el hardware de tu computador, tendrás que incrementar o decrementar el numero.</p>

<p>En mi sistema, ejecutar este programa toma <code>2.156</code>. Si uso alguna tipo de herramienta de monitoreo de procesos, como <code>top</code>, puedo ver que solo usa un núcleo en mi maquina. El GIL presente haciendo su trabajo.</p>

<p>Si bien es cierto que este en un programa sintético, uno podría imaginar muchos problemas similares a este en el mundo real. Para nuestros propósitos, levantar unos pocos hilos y ocuparlos representa una especie de computación paralela y costosa.</p>

<h1 id="una-biblioteca-rust" class='section-header'><a
                           href="#una-biblioteca-rust">Una biblioteca Rust</a></h1>
<p>Escribamos este problema en Rust. Primero, creemos un proyecto nuevo con Cargo:</p>

<pre><code class="language-bash">$ cargo new embeber
$ cd embeber
</code></pre>

<p>Este programa es fácil de escribir en Rust:</p>
<span class='rusttest'>fn main() {
    use std::thread;
    
    fn procesar() {
        let handles: Vec&lt;_&gt; = (0..10).map(|_| {
            thread::spawn(|| {
                let mut _x = 0;
                for _ in (0..5_000_000) {
                    _x += 1
                }
            })
        }).collect();
    
        for h in handles {
            h.join().ok().expect(&quot;No se pudo unir un hilo!&quot;);
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>fn</span> <span class='ident'>procesar</span>() {
    <span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> (<span class='number'>0</span>..<span class='number'>10</span>).<span class='ident'>map</span>(<span class='op'>|</span>_<span class='op'>|</span> {
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='op'>||</span> {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>_x</span> <span class='op'>=</span> <span class='number'>0</span>;
            <span class='kw'>for</span> _ <span class='kw'>in</span> (<span class='number'>0</span>..<span class='number'>5_000_000</span>) {
                <span class='ident'>_x</span> <span class='op'>+=</span> <span class='number'>1</span>
            }
        })
    }).<span class='ident'>collect</span>();

    <span class='kw'>for</span> <span class='ident'>h</span> <span class='kw'>in</span> <span class='ident'>handles</span> {
        <span class='ident'>h</span>.<span class='ident'>join</span>().<span class='ident'>ok</span>().<span class='ident'>expect</span>(<span class='string'>&quot;No se pudo unir un hilo!&quot;</span>);
    }
}
</pre>

<p>Algo de esto debe lucir familiar a ejemplos anteriores. Iniciamos diez hilos, colectandolos en un vector <code>handles</code>. Dentro de cada hilo, iteramos cinco millones de veces, agregando uno a <code>_x</code> en cada iteración. Porque el sub-guion? Bueno, si lo removemos y luego compilamos:</p>

<pre><code class="language-bash">$ cargo build
  Compiling embeber v0.1.0 (file:///Users/goyox86/Code/rust/embeber)
src/lib.rs:3:1: 16:2 warning: function is never used: `procesar`, #[warn(dead_code)] on by default
src/lib.rs:3 fn procesar() {
src/lib.rs:4     let handles: Vec&lt;_&gt; = (0..10).map(|_| {
src/lib.rs:5         thread::spawn(|| {
src/lib.rs:6             let mut x = 0;
src/lib.rs:7             for _ in (0..5_000_000) {
src/lib.rs:8                 x += 1
             ...
src/lib.rs:6:17: 6:22 warning: variable `x` is assigned to, but never used, #[warn(unused_variables)] on by default
src/lib.rs:6             let mut x = 0;
                             ^~~~~
</code></pre>

<p>La primera advertencia es debido es a consecuencia de estar construyendo una biblioteca. Si tuviéramos una prueba para esta función, la advertencia desaparecería. Pero por ahora nunca es llamada.</p>

<p>La segunda esta relacionada a <code>x</code> versus <code>_x</code>. Como producto de que efectivamente <em>no hacemos nada</em> con <code>x</code> obtenemos una advertencia. Eso, en nuestro caso, esta perfectamente bien, puesto que queremos desperdiciar ciclos de CPU. Usando un sub-guión de prefijo eliminamos la advertencia.</p>

<p>Finalmente, hacemos join en cada uno de los hilos.</p>

<p>Hasta el momento, sin embargo, es una biblioteca Rust, y no expone nada que pueda ser llamado desde C. Si quisiéramos conectarla con otro lenguaje, en su estado actual, no funcionaria. Solo necesitamos hacer unos pequeños cambios para arreglarlo. Lo primero es modificar el principio de nuestro código:</p>
<span class='rusttest'>fn main() {
    #[no_mangle]
    pub extern fn procesar() {
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>procesar</span>() {
</pre>

<p>Debemos agregar un nuevo atributo, <code>no_mangle</code>. Cuando creamos una biblioteca Rust, este cambia el nombre de la función en la salida compilada. Las razones de esto escapan del alcance de este tutorial, pero para que otros lenguajes puedan saber como llamar a la función, debemos evitar que el compilador cambie el nombre en la salida compilada. Este atributo desactiva ese comportamiento.</p>

<p>El otro cambio es el <code>pub extern</code>. El <code>pub</code> significa que esta función puede ser llamada desde afuera de este modulo, y el <code>extern</code> dice que esta puede ser llamada desde C. Eso es todo! No muchos cambios.</p>

<p>La segunda cosa que necesitamos hacer es cambiar una configuración en nuestro  <code>Cargo.toml</code>. Agrega esto al final:</p>

<pre><code class="language-toml">[lib]
name = &quot;embeber&quot;
crate-type = [&quot;dylib&quot;]
</code></pre>

<p>Estas lineas le informan a Rust que queremos compilar nuestra biblioteca en una biblioteca dinámica estándar. Rust compila un ‘rlib’, un formato especifico de Rust.</p>

<p>Ahora construyamos el proyecto:</p>

<pre><code class="language-bash">$ cargo build --release
   Compiling embeber v0.1.0 (file:///Users/goyox86/Code/rust/embeber)
</code></pre>

<p>Hemos elegido <code>cargo build --release</code>, lo cual construye el proyecto con optimizaciones. Queremos que sea lo mas rápido posible! Puedes encontrar la salida de la biblioteca en <code>target/release</code>:</p>

<pre><code class="language-bash">$ ls target/release/
build  deps  examples  libembeber.dylib native
</code></pre>

<p>Esa <code>libembeber.dylib</code> es nuestra biblioteca de ‘objetos compartidos’. Podemos usar esta biblioteca como cualquier biblioteca de objetos compartido escrita en C! Como nota, esta podría ser <code>libembeber.so</code> o <code>libembeber.dll</code>, dependiendo la plataforma.</p>

<p>Ahora que tenemos nuestra biblioteca Rust, usémosla desde Ruby.</p>

<h1 id="ruby" class='section-header'><a
                           href="#ruby">Ruby</a></h1>
<p>Crea un archivo <code>embeber.rb</code> dentro de nuestro proyecto, y coloca esto dentro:</p>

<pre><code class="language-ruby">require &#39;ffi&#39;

module Hola
  extend FFI::Library
  ffi_lib &#39;target/release/libembeber.dylib&#39;
  attach_function :procesar, [], :void
end

Hola.procesar

puts &#39;completado!&#39;
</code></pre>

<p>Antes de que podamos ejecutarlo, necesitamos instalar la gema <code>ffi</code>:</p>

<pre><code class="language-bash">$ gem install ffi # esto puede necesitar sudo
Fetching: ffi-1.9.8.gem (100%)
Building native extensions.  This could take a while...
Successfully installed ffi-1.9.8
Parsing documentation for ffi-1.9.8
Installing ri documentation for ffi-1.9.8
Done installing documentation for ffi after 0 seconds
1 gem installed
</code></pre>

<p>Finalmente, intentemos ejecutarlo:</p>

<pre><code class="language-bash">$ ruby embeber.rb
completado!
$
</code></pre>

<p>Whoa, eso fue rápido! En mi sistema, tomo <code>0.086</code> segundos, a diferencia de los dos segundos que la version en Ruby puro. Analicemos este código Ruby:</p>

<pre><code class="language-ruby">require &#39;ffi&#39;
</code></pre>

<p>Primero necesitamos requerir la gema <code>ffi</code>. Nos permite interactuar con una biblioteca Rust como una biblioteca en C.</p>

<pre><code class="language-ruby">module Hola
  extend FFI::Library
  ffi_lib &#39;target/release/libembeber.dylib&#39;
</code></pre>

<p>El modulo <code>Hola</code> es usado para adjuntar las funciones nativas de la biblioteca compartida. Dentro, <code>extend</code>emos el modulo <code>FFI::Library</code> y luego llamamos el método <code>ffi_lib</code> para cargar nuestra biblioteca de objetos compartidos. Simplemente pasamos la ruta en la cual nuestra biblioteca esta almacenada, la cual, como vimos anteriormente, es <code>target/release/libembeber.dylib</code>.</p>

<pre><code class="language-ruby">attach_function :procesar, [], :void
</code></pre>

<p>El método <code>attach_function</code> es proporcionado por la gema FFI. Es lo que conecta nuestra función <code>procesar()</code> en Rust a un método en Ruby con el mismo nombre. Debido a que <code>procesar()</code> no recibe argumentos, el segundo parámetro es un arreglo vacío, y ya que no retorna nada, pasamos <code>:void</code> como argumento final.</p>

<pre><code class="language-ruby">Hola.procesar
</code></pre>

<p>Esta es la llamada a Rust. La combinación de nuestro modulo y la llamada a <code>attach_function</code> han configurado todo. Se ve como un método Ruby pero es en realidad código Rust!</p>

<pre><code class="language-ruby">puts &#39;completado!&#39;
</code></pre>

<p>Finalmente, y como requerimiento de nuestro proyecto, imprimimos <code>completado!</code>.</p>

<p>Eso es todo! Como hemos visto, hacer un puente entre los dos lenguajes es realmente fácil, y nos compra mucho performance.</p>

<p>A continuación, probemos Python!</p>

<h1 id="python" class='section-header'><a
                           href="#python">Python</a></h1>
<p>Crea un archivo <code>embeber.py</code> en este directorio, y coloca esto en el:</p>

<pre><code class="language-python">from ctypes import cdll

lib = cdll.LoadLibrary(&quot;target/release/libembeber.dylib&quot;)

lib.procesar()

print(&quot;completado!&quot;)
</code></pre>

<p>Aun mas fácil! Usamos <code>cdll</code> del modulo <code>ctypes</code>. Una llamada rápida a <code>LoadLibrary</code> después, y luego podemos llamar <code>procesar()</code>.</p>

<p>En mi sistema, toma <code>0.017</code> segundos. Rápidillo!</p>

<h1 id="node.js" class='section-header'><a
                           href="#node.js">Node.js</a></h1>
<p>Node no es un lenguaje, pero es actualmente la implementación de Javascript dominante del lado del servidor.</p>

<p>Para hacer FFI con Node, primero necesitamos instalar la biblioteca:</p>

<pre><code class="language-bash">$ npm install ffi
</code></pre>

<p>Después de que este instalada, podemos usarla:</p>

<pre><code class="language-javascript">var ffi = require(&#39;ffi&#39;);

var lib = ffi.Library(&#39;target/release/libembeber&#39;, {
  &#39;procesar&#39;: [&#39;void&#39;, []]
});

lib.procesar();

console.log(&quot;completado!&quot;);
</code></pre>

<p>Luce mas parecido al ejemplo Ruby que al de Python. Usamos el modulo <code>ffi</code> para obtener acceso a <code>ffi.Library()</code>, la cual nos permite cargar nuestra biblioteca de objetos compartidos. Necesitamos anotar el tipo de retorno y los tipos de los argumentos de la función, que son <code>void</code> para el retorno y un arreglo vacío para representar ningún argumento. De allí simplemente llamamos a la función <code>procesar()</code> e imprimimos el resultado.</p>

<p>En my sistema, este ejemplo toma unos rápidos <code>0.092</code> segundos.</p>

<h1 id="conclusion" class='section-header'><a
                           href="#conclusion">Conclusion</a></h1>
<p>Como puedes ver, las bases de hacer FFI son <em>muy</em> fáciles. Por supuesto hay mucho mas que podríamos hacer aquí. Echa un vistazo al capitulo <a href="ffi.html">FFI</a> para mas detalles.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>La Pila y el Montículo</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a class='active' href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Monticulo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilacion Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentacion</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribucion</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> Ciclos for</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> Ciclos while</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> Referencias y Prestamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Sintaxis de Metodos</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Genericos</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Rasgos</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Objetos de Razgo</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Sintaxis de Llamada a Funciones Universal</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates y Modulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Conversion entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Tipos sin Tamano</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Inverstigacion Academica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">La Pila y el Montículo</h1>
    <p>Como un lenguaje de sistemas, Rust opera a un bajo nivel. Si provienes de un lenguaje de alto nivel, hay algunos aspectos de los lenguajes de programación de sistemas con los cuales puedas no estar familiarizado. El mas importante es el funcionamiento de la memoria, con la pila y el montículo. Si estas familiarizado con el como lenguajes como C usan asignación desde la pila, este capitulo sera un repaso. Si no lo estas, aprenderás acerca de este concepto general, pero con un enfoque Rustero.</p>

<h1 id="manejo-de-memoria" class='section-header'><a
                           href="#manejo-de-memoria">Manejo de memoria</a></h1>
<p>Estos dos términos hacen referencia a el manejo de la memoria. La pila y el montículo son abstracciones que ayudan a determinar cuando asignar y liberar memoria.</p>

<p>He aquí una comparación de alto nivel:</p>

<p>La pila es muy rápida, y es de donde la memoria es asignada por defecto en Rust. Pero la asignación es local a una llamada a función, y es limitada en tamaño. El montículo por otro lado, es mas lento, y es asignado por tu programa. Pero es efectivamente de un tamaño ilimitado, y es globalmente accesible.</p>

<h1 id="la-pila" class='section-header'><a
                           href="#la-pila">La Pila</a></h1>
<p>Hablemos acerca de este programa Rust:</p>
<span class='rusttest'>fn main() {
    let x = 42;
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>42</span>;
}
</pre>

<p>Este programa posee una variable (variable binding), <code>x</code>. La memoria tiene que ser asignada desde algún sitio. Rust asigna desde la pila por defecto, lo que se traduce en que los valores básicos ‘van a la pila’. Pero, que significa esto?</p>

<p>Veamos, cuando una función es llamada, algo de memoria es asignada para sus variables locales y otra información extra. Dicha memoria es llamada  ‘registro de activación’ (‘stack frame’), para el propósito de este tutorial, ignoraremos la información extra y solo consideraremos las variables locales a las que estamos asignando memoria. Así que en este caso, cuando <code>main()</code> es ejecutada, asignamos un entero de 32 bits para nuestro registro de activación. Todo esto es manejado automáticamente, como has podido ver, no tuvimos que escribir ningún código Rust especial o alguna otra cosa.</p>

<p>Cuando la función termina, su registro de activación es liberado o desasignado. Esto ocurre de manera automática, no tuvimos que hacer nada especial acá.</p>

<p>Eso es todo para este simple programa. Lo clave a entender aquí es que la asignación de memoria desde la pila es muy, muy rápida. Debido a que conocemos por adelantado todas las variables locales, podemos obtener toda la memoria de una sola vez. Y debido a que la desecharemos toda completa, podemos deshacernos de ella muy rápido, también.</p>

<p>La desventaja es que no podemos mantener valores rondando por allí si los necesitamos por un periodo mas largo que el tiempo de vida de una función. Tampoco hemos hablado acerca de que significa ese nombre, ‘pila’. Para hacerlo necesitamos un ejemplo ligeramente mas complejo:</p>
<span class='rusttest'>fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='number'>100</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>42</span>;

    <span class='ident'>foo</span>();
}
</pre>

<p>Este programa tiene tres variables en total: dos en <code>foo()</code>, una en <code>main()</code>. Al igual que antes, cuando <code>main()</code> es llamada, un solo entero es asignado para su registro de activación. Pero antes que demostremos que es lo que pasa cuando <code>foo()</code> es llamada, necesitamos visualizar que es lo que esta pasando en memoria. Tu sistema operativo presenta a tu programa una visión muy simple: una lista inmensa de direcciones, desde 0 hasta un numero muy grande, que representa cuanta memoria RAM posee la maquina. Por ejemplo si tienes un gigabyte de RAM, tus direcciones irán desde 0 hasta <code>1,073,741,824</code>,  numero que proviene de 2<sup>30</sup>, el numero de bytes en un gigabyte.</p>

<p>Esta memoria es una especie de arreglo gigante: las direcciones comienzan en cero y se incrementan hasta el numero final. Entonces, he aquí un diagrama de nuestro primer registro de activación:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>x</td>
<td>42</td>
</tr>
</tbody></table>

<p>Hemos colocado a <code>x</code> en la dirección <code>0</code>, con el valor <code>42</code></p>

<p>Cuando <code>foo()</code> es llamada un nuevo registro de activación es asignado:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2</td>
<td>z</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>y</td>
<td>5</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>42</td>
</tr>
</tbody></table>

<p>Debido a que <code>0</code> fue reservado para la primera frame, <code>1</code> y <code>2</code> son usados para el registro de activación de <code>foo()</code>. La pila crece hacia arriba, a medida que llamamos a mas funciones.</p>

<p>Hay algunas cosas importantes que debemos notar aquí. Los números 0, 1 y 2 existen solo para propósitos ilustrativos, y no poseen ninguna relación con los números que una computadora realmente usaría. En particular, la serie de direcciones están separadas por un numero de bytes, y esa separación puede incluso exceder el tamaño del valor que esta siendo almacenado.</p>

<p>Después que <code>foo()</code> termina, su registro de activación es liberado:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>x</td>
<td>42</td>
</tr>
</tbody></table>

<p>Y luego después de que <code>main()</code> finaliza, este ultimo valor se va. Fácil!</p>

<p>Es llamada una pila (‘stack’) debido a que funciona como una pila de platos: el primer plato que colocas es el ultimo plato que sacarás. Las pilas son algunas veces llamadas ‘colas ultimo que entra, primero que sale’ (‘last in, first out queues’), por estas razones el ultimo valor que pusiste en la pila será el primero que obtendrás de ella.</p>

<p>Probemos un ejemplo de tres niveles:</p>
<span class='rusttest'>fn bar() {
    let i = 6;
}

fn foo() {
    let a = 5;
    let b = 100;
    let c = 1;

    bar();
}

fn main() {
    let x = 42;

    foo();
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>bar</span>() {
    <span class='kw'>let</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>6</span>;
}

<span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='number'>100</span>;
    <span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='number'>1</span>;

    <span class='ident'>bar</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>42</span>;

    <span class='ident'>foo</span>();
}
</pre>

<p>Bien, en primera instancia, llamamos a <code>main()</code>:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>x</td>
<td>42</td>
</tr>
</tbody></table>

<p>Acto seguido, <code>main()</code> llama a <code>foo()</code>:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>3</td>
<td>c</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td>5</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>42</td>
</tr>
</tbody></table>

<p>Luego <code>foo()</code> llama a <code>bar()</code>:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>4</td>
<td>i</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td>5</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>42</td>
</tr>
</tbody></table>

<p>Uff! Nuestra pila esta creciendo.</p>

<p>Después que <code>bar()</code> termina, su registro de activación es liberado, dejando solo a <code>foo()</code> y <code>main()</code>:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>3</td>
<td>c</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td>5</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>42</td>
</tr>
</tbody></table>

<p>Después <code>foo()</code> termina, dejando solo a <code>main()</code></p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>x</td>
<td>42</td>
</tr>
</tbody></table>

<p>Hemos terminado entonces. Se entiende? Es como apilar platos: agregas al tope y sacas de el.</p>

<h1 id="el-montículo" class='section-header'><a
                           href="#el-montículo">El Montículo</a></h1>
<p>Ahora, todo esto trabaja bien, pero no todo funciona de esa manera. Algunas veces, necesitas pasar memoria entre diferentes funciones, o mantener memoria viva por un tiempo mayor que la ejecución de una función. Para esto usamos el montículo.</p>

<p>En Rust, puedes asignar memoria desde el montículo con el <a href="../std/boxed/index.html">tipo <code>Box&lt;T&gt;</code></a> (caja).</p>

<p>He aqui un ejemplo:</p>
<span class='rusttest'>fn main() {
    let x = Box::new(5);
    let y = 42;
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>5</span>);
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>42</span>;
}
</pre>

<p>Acá, lo que sucede cuando <code>main()</code> es llamada:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>y</td>
<td>42</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>??????</td>
</tr>
</tbody></table>

<p>Asignamos espacio para dos variables en la pila. <code>y</code> es <code>42</code>, como conocemos hasta ahora, pero que acerca de <code>x</code>? Bueno, <code>x</code> es un <code>Box&lt;i32&gt;</code>, y las cajas (boxes) asignan memoria desde el montículo. El valor de la caja en cuestión es una estructura que posee un apuntador a ‘el montículo’. Cuando comienza la ejecución de la función, y <code>Box::new()</code> es llamada, esta asigna algo de memoria para el montículo y coloca <code>5</code> allí. La memoria ahora luce así:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>1</td>
<td>y</td>
<td>42</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>2<sup>30</sup></td>
</tr>
</tbody></table>

<p>Tenemos 2<sup>30</sup> en nuestra computadora hipotética con 1GB de RAM. Y debido a que nuestra pila crece desde cero, la forma mas fácil para asignar memoria es desde el otro extremo. Entonces nuestro primer valor esta en el lugar mas alto en la memoria. Y el valor de la estructura en <code>x</code> tiene un  <a href="raw-pointers.html">apuntador plano</a> (raw pointer) a el lugar que hemos asignado en el montículo, entonces el valor de <code>x</code> es 2<sup>30</sup>, la dirección de la memoria que hemos solicitado.</p>

<p>No hemos hablado mucho acerca de que significa en realidad asignar y liberar memoria en estos contextos. Entrar en el profundo detalle de ello esta fuera del alcance de este tutorial, lo importante a resaltar es que el montículo no es una simple pila que crece desde el lado opuesto. Tendremos un ejemplo de esto mas adelante en el libro, pero debido a que el montículo puede ser asignado y liberado en cualquier orden, puede terminar con ‘vacios’. He aquí un diagrama de la distribución de la memoria de un programa que ha estado corriendo por algún tiempo:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>(2<sup>30</sup>) - 1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(2<sup>30</sup>) - 2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(2<sup>30</sup>) - 3</td>
<td></td>
<td>42</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>3</td>
<td>y</td>
<td>(2<sup>30</sup>) - 3</td>
</tr>
<tr>
<td>2</td>
<td>y</td>
<td>42</td>
</tr>
<tr>
<td>1</td>
<td>y</td>
<td>42</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>2<sup>30</sup></td>
</tr>
</tbody></table>

<p>En este caso, hemos asignado cuatro cosas en el montículo, pero hemos liberado dos de ellas. Hay un vacío entre 2<sup>30</sup> y (2<sup>30</sup>) - 3 que no esta siendo usado actualmente. El detalle especifico acerca de como y porque esto sucede depende de la estrategia usada para manejar el montículo. Diferentes programas pueden usar diferentes ‘asignadores de memoria’ (‘memory allocators’), que son bibliotecas encargadas de manejar la asignación de memoria por ti. Los programas en Rust usan <a href="http://www.canonware.com/jemalloc/">jemalloc</a> para dicho propósito.</p>

<p>De cualquier modo, y de vuelta a nuestro ejemplo. Debido a que esta memoria esta en el montículo, puede permanecer viva mas tiempo que la función que crea la caja (box). Sin embargo, en este caso, esto no sucede. <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> cuando la función termina, necesitamos liberar el registro de activación de <code>main()</code>. <code>Box&lt;T&gt;</code>, sin embargo, tienen un truco bajo la manga: <a href="drop.html">Drop</a>. La implementación de <code>Drop</code> para <code>Box</code> libera la memoria que ha sido asignada cuando la caja es creada. Grandioso! Así que cuando <code>x</code> se va (sale de contexto), primero libera la memoria asignada desde el montículo:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>y</td>
<td>42</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>??????</td>
</tr>
</tbody></table>

<p>Luego el registro de activación se va, liberando toda nuestra memoria.</p>

<h1 id="argumentos-y-prestamo-(borrowing)" class='section-header'><a
                           href="#argumentos-y-prestamo-(borrowing)">Argumentos y prestamo (borrowing)</a></h1>
<p>Hemos llevado a cabo algunos ejemplos básicos con la pila y el montículo, pero que hay acerca de los argumentos a funciones y el préstamo (borrowing)? He aquí un pequeño programa Rust:</p>
<span class='rusttest'>fn foo(i: &amp;i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &amp;x;

    foo(y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>i</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='number'>42</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;

    <span class='ident'>foo</span>(<span class='ident'>y</span>);
}
</pre>

<p>Cuando entramos a <code>main()</code>, la memoria luce de la siguiente manera:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>y</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>5</td>
</tr>
</tbody></table>

<p><code>x</code> es un simple <code>5</code>, y <code>y</code> es una referencia a <code>x</code>. Entonces, el valor de <code>y</code> es la dirección de memoria en la que <code>x</code> vive, que en este caso es <code>0</code>.</p>

<p>Que sucede cuando llamamos a <code>foo()</code> pasando a <code>y</code> como argumento?</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>3</td>
<td>z</td>
<td>42</td>
</tr>
<tr>
<td>2</td>
<td>i</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>y</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>5</td>
</tr>
</tbody></table>

<p>Los registros de activación no son solo para variables locales, son también para argumentos. En este caso, necesitamos tener ambos <code>i</code>, nuestro argumento, y <code>z</code> nuestra variable local. <code>i</code> es una copia del argumento, <code>y</code>. Debido a que el valor de <code>y</code> es <code>0</code> entonces ese es el valor de <code>i</code>.</p>

<p>Esta es una razón por la cual tomar prestada una variable no libera ninguna memoria: el valor de la referencia es solo un apuntador a una dirección de memoria. Si nos deshiciéramos de la memoria subyacente, las cosas no irían del todo bien.</p>

<h1 id="un-ejemplo-complejo" class='section-header'><a
                           href="#un-ejemplo-complejo">Un ejemplo complejo</a></h1>
<p>Bien, vayamos a través de este programa complejo paso-a-paso:</p>
<span class='rusttest'>fn foo(x: &amp;i32) {
    let y = 10;
    let z = &amp;y;

    baz(z);
    bar(x, z);
}

fn bar(a: &amp;i32, b: &amp;i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &amp;d;

    baz(e);
}

fn baz(f: &amp;i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &amp;h;

    foo(j);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;
    <span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>y</span>;

    <span class='ident'>baz</span>(<span class='ident'>z</span>);
    <span class='ident'>bar</span>(<span class='ident'>x</span>, <span class='ident'>z</span>);
}

<span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>a</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>, <span class='ident'>b</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>d</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>5</span>);
    <span class='kw'>let</span> <span class='ident'>e</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>d</span>;

    <span class='ident'>baz</span>(<span class='ident'>e</span>);
}

<span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>g</span> <span class='op'>=</span> <span class='number'>100</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>h</span> <span class='op'>=</span> <span class='number'>3</span>;
    <span class='kw'>let</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>20</span>);
    <span class='kw'>let</span> <span class='ident'>j</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>h</span>;

    <span class='ident'>foo</span>(<span class='ident'>j</span>);
}
</pre>

<p>Primero, llamamos a <code>main()</code>:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>2</td>
<td>j</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>i</td>
<td>2<sup>30</sup></td>
</tr>
<tr>
<td>0</td>
<td>h</td>
<td>3</td>
</tr>
</tbody></table>

<p>Asignamos memoria para <code>j</code>, <code>i</code>, y <code>h</code>. <code>i</code> esta en el montículo, es por ello que su valor apunta hacia el.</p>

<p>A continuation, al final de <code>main()</code>, <code>foo()</code> es llamada:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>5</td>
<td>z</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>y</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>j</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>i</td>
<td>2<sup>30</sup></td>
</tr>
<tr>
<td>0</td>
<td>h</td>
<td>3</td>
</tr>
</tbody></table>

<p>Es asignado espacio para <code>x</code>, <code>y</code>, y <code>z</code>. El argumento <code>x</code> tiene el mismo valor que <code>j</code>, debido a que eso fue lo que le proporcionamos a la función. Es un apuntador a la dirección <code>0</code>, puesto que <code>j</code> apunta a <code>h</code>.</p>

<p>Seguidamente, <code>foo()</code> llama a <code>baz()</code>, pasándole <code>z</code>:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>7</td>
<td>g</td>
<td>100</td>
</tr>
<tr>
<td>6</td>
<td>f</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>z</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>y</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>j</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>i</td>
<td>2<sup>30</sup></td>
</tr>
<tr>
<td>0</td>
<td>h</td>
<td>3</td>
</tr>
</tbody></table>

<p>Hemos asignado memoria para <code>f</code> y <code>g</code>. <code>baz()</code> es muy corta, así que cuando termina, nos deshacemos de su registro de activación:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>5</td>
<td>z</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>y</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>j</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>i</td>
<td>2<sup>30</sup></td>
</tr>
<tr>
<td>0</td>
<td>h</td>
<td>3</td>
</tr>
</tbody></table>

<p>Después, <code>foo()</code> llama a <code>bar()</code> con <code>x</code> y <code>z</code>:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>(2<sup>30</sup>) - 1</td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>10</td>
<td>e</td>
<td>9</td>
</tr>
<tr>
<td>9</td>
<td>d</td>
<td>(2<sup>30</sup>) - 1</td>
</tr>
<tr>
<td>8</td>
<td>c</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>b</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>z</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>y</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>j</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>i</td>
<td>2<sup>30</sup></td>
</tr>
<tr>
<td>0</td>
<td>h</td>
<td>3</td>
</tr>
</tbody></table>

<p>Terminamos asignando otro valor en el montículo, así que tenemos que restar uno a 2<sup>30</sup>. Es mas fácil escribir eso que <code>1,073,741,823</code>. En cualquier caso, seteamos las variables como ya es usual.</p>

<p>Al final de <code>bar()</code>, esta llama a <code>baz()</code>:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>(2<sup>30</sup>) - 1</td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>12</td>
<td>g</td>
<td>100</td>
</tr>
<tr>
<td>11</td>
<td>f</td>
<td>9</td>
</tr>
<tr>
<td>10</td>
<td>e</td>
<td>9</td>
</tr>
<tr>
<td>9</td>
<td>d</td>
<td>(2<sup>30</sup>) - 1</td>
</tr>
<tr>
<td>8</td>
<td>c</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>b</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>z</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>y</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>j</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>i</td>
<td>2<sup>30</sup></td>
</tr>
<tr>
<td>0</td>
<td>h</td>
<td>3</td>
</tr>
</tbody></table>

<p>Con esto, estamos en nuestro punto mas profundo! Wow! Felicitaciones por haber seguido todo esto y haber llegado tan lejos.</p>

<p>Luego <code>baz()</code> termina, nos deshacemos de <code>f</code> y <code>g</code>:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>(2<sup>30</sup>) - 1</td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>10</td>
<td>e</td>
<td>9</td>
</tr>
<tr>
<td>9</td>
<td>d</td>
<td>(2<sup>30</sup>) - 1</td>
</tr>
<tr>
<td>8</td>
<td>c</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>b</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>z</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>y</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>j</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>i</td>
<td>2<sup>30</sup></td>
</tr>
<tr>
<td>0</td>
<td>h</td>
<td>3</td>
</tr>
</tbody></table>

<p>A continuación, retornamos de <code>bar()</code>. <code>d</code> en este caso es un <code>Box&lt;T&gt;</code>, entonces también libera a lo que apunta: (2<sup>30</sup>) - 1.</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>5</td>
<td>z</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>y</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>j</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>i</td>
<td>2<sup>30</sup></td>
</tr>
<tr>
<td>0</td>
<td>h</td>
<td>3</td>
</tr>
</tbody></table>

<p>Después, <code>foo()</code> retorna:</p>

<table><thead>
<tr>
<th>Dirección</th>
<th>Nombre</th>
<th>Valor</th>
</tr>
</thead><tbody>
<tr>
<td>2<sup>30</sup></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>2</td>
<td>j</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>i</td>
<td>2<sup>30</sup></td>
</tr>
<tr>
<td>0</td>
<td>h</td>
<td>3</td>
</tr>
</tbody></table>

<p>Entonces, finalmente <code>main()</code> retorna, lo cual limpia el resto. Cuando <code>i</code> es liberada (a través de <code>Drop</code>) esta limpiara también lo restante en el montículo.</p>

<h1 id="que-hacen-otros-lenguajes?" class='section-header'><a
                           href="#que-hacen-otros-lenguajes?">Que hacen otros lenguajes?</a></h1>
<p>La mayoría de los lenguajes con un recolector de basura asignan desde el montículo por defecto. Esto significa que todos los valores están dentro de cajas (boxed). Existen un numero de razones por la cuales esto se hace de esta manera, pero están fuera del alcance de este tutorial. También, existen algunas optimizaciones que hacen que esto no sea 100% verdad todo el tiempo. En vez de confiar en la pila y <code>Drop</code> para limpiar la memoria, el recolector de basura es el encargado de administrar el montículo.</p>

<h1 id="cual-usar?" class='section-header'><a
                           href="#cual-usar?">Cual usar?</a></h1>
<p>Si la pila es mas rápida y mas fácil de usar, porque necesitamos el montículo? Una gran razón es que la asignación desde la pila significa que solo tienes semántica LIFO para reclamar almacenamiento. La asignación desde el montículo es estrictamente mas general, permitiendo que el almacenamiento pueda ser tomado y retornado a el pool en orden arbitrario, pero con un costo en complejidad.</p>

<p>Generalmente, deberías preferir asignación desde la pila, es por ello que Rust asigna desde la pila por defecto. El modelo LIFO de la pila es mas simple, a nivel fundamental. Esto tiene dos grandes impactos: eficiencia en tiempo de ejecución e impacto semántico.</p>

<h2 id="eficiencia-en-tiempo-de-ejecucion." class='section-header'><a
                           href="#eficiencia-en-tiempo-de-ejecucion.">Eficiencia en tiempo de Ejecucion.</a></h2>
<p>Administrar la memoria para la pila es trivial: La maquina simplemente incrementa un solo valor, el llamado &quot;apuntador a la pila&quot; (“stack pointer”). La administración de memoria para el montículo no lo es: La memoria asignada desde el montículo es liberada en puntos arbitrarios, y cada bloque de memoria asignada desde el montículo pude ser de un tamaño arbitrario, el administrador de memoria generalmente debe trabajar mucho mas duro para identificar memoria que pueda ser reusada.</p>

<p>Si quisieras sumergirte mas en este tópico con mayor detalle, <a href="http://www.cs.northwestern.edu/%7Epdinda/icsclass/doc/dsa.pdf">este paper</a> es una muy buena introducción.</p>

<h2 id="impacto-semantico" class='section-header'><a
                           href="#impacto-semantico">Impacto semantico</a></h2>
<p>Stack-allocation impacts the Rust language itself, and thus the developer’s mental model. The LIFO semantics is what drives how the Rust language handles automatic memory management. Even the deallocation of a uniquely-owned heap-allocated box can be driven by the stack-based LIFO semantics, as discussed throughout this chapter. The flexibility (i.e. expressiveness) of non LIFO-semantics means that in general the compiler cannot automatically infer at compile-time where memory should be freed; it has to rely on dynamic protocols, potentially from outside the language itself, to drive deallocation (reference counting, as used by Rc<T> and Arc<T>, is one example of this).</p>

<p>La asignación desde la pila impacta a Rust como lenguaje, y con ello el modelo mental del desarrollador. La semántica LIFO es lo que conduce como el lenguaje Rust maneja el manejo automático de memoria. Incluso la liberación de una caja asignada desde el montículo con un único dueño puede ser manejada por la semántica LIFO, tal y como se ha discutido en este capitulo. La flexibilidad (e.j. expresividad) de la semántica no-LIFO significa que en general el compilador no puede inferir de manera automática y en tiempo de compilación donde la memoria debería ser liberada; tiene que apoyarse en protocolos dinámicos, potencialmente externos a el lenguaje, para efectuar liberación de memoria (conteo de referencias, como el usado en <code>Rc&lt;T&gt;</code> y <code>Arc&lt;T&gt;</code>, es un ejemplo).</p>

<p>Cuando se lleva al extremo, el mayor poder expresivo de la asignación desde el montículo viene a costo de bien sea soporte significativo en tiempo de ejecución  (e.j. en la forma de un recolector de basura) o esfuerzo significativo por parte del programador (en la forma de llamadas manuales explícitas que requieren verificación no proporcionada por el compilador de Rust).</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Podemos hacer que la memoria permanezca viva mas tiempo transfiriendo la pertenencia (ownership), algunas veces llamado ‘moviendo fuera de la caja’ (‘moving out of the box’). Ejemplos mas complejos serán cubiertos mas adelante.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
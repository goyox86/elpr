<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Manejo de Errores</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a class='active' href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patrones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Asignadores de Memoria Personalizados</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='bibliography.html'><b>8.</b> Bibliografia</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Manejo de Errores</h1>
    <blockquote>
<p>Los planes mejor establecidos por ratones y hombres a menudo se tuercen.
&quot;Tae a Moose&quot;, Robert Burns</p>
</blockquote>

<p>Algunas veces, las cosas simplemente salen mal. Es importante tener un plan para cuando lo inevitable suceda. Rust posee un soporte rico para el manejo de errores que podrían (seamos honestos: ocurrirán) ocurrir en tus programas.</p>

<p>Existen dos tipos de errores que pueden ocurrir en tus programas: fallas y pánicos. Hablaremos de las diferencias entre los dos, y luego discutiremos como manejar cada uno. Después discutiremos como promover fallas a pánicos.</p>

<h1 id='falla-vs-pánico' class='section-header'><a href='#falla-vs-pánico'>Falla vs. Pánico</a></h1>
<p>Rust usa dos términos para diferenciar entre las dos formas de error: falla, y pánico. Una <em>falla</em> es un error del cual nos podemos recuperar de alguna manera. Un <em>pánico</em> es un error irrecuperable.</p>

<p>Que queremos decir con &quot;recuperar&quot;? Bueno, en la mayoría de los casos, la posibilidad de un error es esperada. Por ejemplo, considera la función <code>parse</code>:</p>
<span class='rusttest'>fn main() {
    &quot;5&quot;.parse();
}</span><pre class='rust rust-example-rendered'>
<span class='string'>&quot;5&quot;</span>.<span class='ident'>parse</span>();</pre>

<p>Este método convierte una cadena de caracteres a otro tipo. Pero debido a que es una cadena de caracteres, no se puede estar seguro de que la conversion efectivamente tenga éxito. Por ejemplo, a que debería ser convertido esto?:</p>
<span class='rusttest'>fn main() {
    &quot;hola5mundo&quot;.parse();
}</span><pre class='rust rust-example-rendered'>
<span class='string'>&quot;hola5mundo&quot;</span>.<span class='ident'>parse</span>();</pre>

<p>Lo anterior no funciona. Sabemos que el método <code>parse()</code> solo tendrá éxito para algunas entradas. Es un comportamiento esperado. Es por ello que llamamos a este error una <em>falla</em>.</p>

<p>Por otro lado, algunas veces, hay errores que son inesperados, o de los cuales no nos podemos recuperar. Un ejemplo clásico es un <code>assert!</code>:</p>
<span class='rusttest'>fn main() {
    let x = 5;
    assert!(x == 5);
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>x</span> <span class='op'>==</span> <span class='number'>5</span>);</pre>

<p>Usamos <code>assert!</code> para declarar que algo es cierto (true). Si la declaración no es verdad, entonces algo esta muy mal. Suficientemente mal como para no poder continuar la ejecución en el estado actual. Otro ejemplo es el uso de la macro <code>unreachable!()</code>:</p>
<span class='rusttest'>use Evento::NuevoLanzamiento;

enum Evento {
    NuevoLanzamiento,
}

fn probabilidad(_: &amp;Evento) -&gt; f64 {
    // la implementación real seria mas compleja, por supuesto
    0.95
}

fn probabilidad_descriptiva(evento: Evento) -&gt; &amp;&#39;static str {
    match probabilidad(&amp;evento) {
        1.00 =&gt; &quot;cierto&quot;,
        0.00 =&gt; &quot;imposible&quot;,
        0.00 ... 0.25 =&gt; &quot;muy poco probable&quot;,
        0.25 ... 0.50 =&gt; &quot;poco probable&quot;,
        0.50 ... 0.75 =&gt; &quot;probable&quot;,
        0.75 ... 1.00 =&gt; &quot;muy probable&quot;,
    }
}

fn main() {
     println!(&quot;{}&quot;, probabilidad_descriptiva(NuevoLanzamiento));
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>Evento</span>::<span class='ident'>NuevoLanzamiento</span>;

<span class='kw'>enum</span> <span class='ident'>Evento</span> {
    <span class='ident'>NuevoLanzamiento</span>,
}

<span class='kw'>fn</span> <span class='ident'>probabilidad</span>(_: <span class='kw-2'>&amp;</span><span class='ident'>Evento</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='comment'>// la implementación real seria mas compleja, por supuesto</span>
    <span class='number'>0.95</span>
}

<span class='kw'>fn</span> <span class='ident'>probabilidad_descriptiva</span>(<span class='ident'>evento</span>: <span class='ident'>Evento</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span> {
    <span class='kw'>match</span> <span class='ident'>probabilidad</span>(<span class='kw-2'>&amp;</span><span class='ident'>evento</span>) {
        <span class='number'>1.00</span> <span class='op'>=&gt;</span> <span class='string'>&quot;cierto&quot;</span>,
        <span class='number'>0.00</span> <span class='op'>=&gt;</span> <span class='string'>&quot;imposible&quot;</span>,
        <span class='number'>0.00</span> ... <span class='number'>0.25</span> <span class='op'>=&gt;</span> <span class='string'>&quot;muy poco probable&quot;</span>,
        <span class='number'>0.25</span> ... <span class='number'>0.50</span> <span class='op'>=&gt;</span> <span class='string'>&quot;poco probable&quot;</span>,
        <span class='number'>0.50</span> ... <span class='number'>0.75</span> <span class='op'>=&gt;</span> <span class='string'>&quot;probable&quot;</span>,
        <span class='number'>0.75</span> ... <span class='number'>1.00</span> <span class='op'>=&gt;</span> <span class='string'>&quot;muy probable&quot;</span>,
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
     <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>probabilidad_descriptiva</span>(<span class='ident'>NuevoLanzamiento</span>));
}</pre>

<p>Lo anterior resultara en un error:</p>

<pre><code class="language-text">error: non-exhaustive patterns: `_` not covered [E0004]
</code></pre>

<p>Si bien sabemos que hemos cubierto todos los casos posibles, Rust no puede saberlo. No sabe cual es la probabilidad entre 0.0 y 1.0. Es por ello que agregamos otro caso:</p>
<span class='rusttest'>use Evento::NuevoLanzamiento;

enum Evento {
    NuevoLanzamiento,
}

fn probabilidad(_: &amp;Evento) -&gt; f64 {
    // la implementación real seria mas compleja, por supuesto
    0.95
}

fn probabilidad_descriptiva(evento: Evento) -&gt; &amp;&#39;static str {
    match probabilidad(&amp;evento) {
        1.00 =&gt; &quot;cierto&quot;,
        0.00 =&gt; &quot;imposible&quot;,
        0.00 ... 0.25 =&gt; &quot;muy poco probable&quot;,
        0.25 ... 0.50 =&gt; &quot;poco probable&quot;,
        0.50 ... 0.75 =&gt; &quot;probable&quot;,
        0.75 ... 1.00 =&gt; &quot;muy probable&quot;,
        _ =&gt; unreachable!()
    }
}

fn main() {
    println!(&quot;{}&quot;, probabilidad_descriptiva(NuevoLanzamiento));
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>Evento</span>::<span class='ident'>NuevoLanzamiento</span>;

<span class='kw'>enum</span> <span class='ident'>Evento</span> {
    <span class='ident'>NuevoLanzamiento</span>,
}

<span class='kw'>fn</span> <span class='ident'>probabilidad</span>(_: <span class='kw-2'>&amp;</span><span class='ident'>Evento</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='comment'>// la implementación real seria mas compleja, por supuesto</span>
    <span class='number'>0.95</span>
}

<span class='kw'>fn</span> <span class='ident'>probabilidad_descriptiva</span>(<span class='ident'>evento</span>: <span class='ident'>Evento</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span> {
    <span class='kw'>match</span> <span class='ident'>probabilidad</span>(<span class='kw-2'>&amp;</span><span class='ident'>evento</span>) {
        <span class='number'>1.00</span> <span class='op'>=&gt;</span> <span class='string'>&quot;cierto&quot;</span>,
        <span class='number'>0.00</span> <span class='op'>=&gt;</span> <span class='string'>&quot;imposible&quot;</span>,
        <span class='number'>0.00</span> ... <span class='number'>0.25</span> <span class='op'>=&gt;</span> <span class='string'>&quot;muy poco probable&quot;</span>,
        <span class='number'>0.25</span> ... <span class='number'>0.50</span> <span class='op'>=&gt;</span> <span class='string'>&quot;poco probable&quot;</span>,
        <span class='number'>0.50</span> ... <span class='number'>0.75</span> <span class='op'>=&gt;</span> <span class='string'>&quot;probable&quot;</span>,
        <span class='number'>0.75</span> ... <span class='number'>1.00</span> <span class='op'>=&gt;</span> <span class='string'>&quot;muy probable&quot;</span>,
        _ <span class='op'>=&gt;</span> <span class='macro'>unreachable</span><span class='macro'>!</span>()
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>probabilidad_descriptiva</span>(<span class='ident'>NuevoLanzamiento</span>));
}</pre>

<p>Nunca deberíamos alcanzar el caso <code>_</code>, debido a esto hacemos uso de la macro para indicarlo. <code>unreachable!()</code> produce un tipo diferente de error que <code>Result</code>. Rust llama a ese tipo de errores <em>pánicos</em>.</p>

<h1 id='manejando-errores-con-option-y-result' class='section-header'><a href='#manejando-errores-con-option-y-result'>Manejando errores con <code>Option</code> y <code>Result</code></a></h1>
<p>La manera mas simple de indicar que una función puede fallar es usando el tipo <code>Option&lt;T&gt;</code>. Por ejemplo, el método find en las cadenas de caracteres intenta localizar un patrón en la cadena, retorna un <code>Option</code>:</p>
<span class='rusttest'>fn main() {
    let s = &quot;foo&quot;;
    
    assert_eq!(s.find(&#39;f&#39;), Some(0));
    assert_eq!(s.find(&#39;z&#39;), None);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39;f&#39;</span>), <span class='prelude-val'>Some</span>(<span class='number'>0</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39;z&#39;</span>), <span class='prelude-val'>None</span>);</pre>

<p>Esto es apropiado para casos simples, pero no nos da mucha información en el caso de una falla. Que tal si quisiéramos saber el <em>porque</em> la función falló? Para ello, podemos usar el tipo <code>Result&lt;T, E&gt;</code>. Que luce así:</p>
<span class='rusttest'>fn main() {
    enum Result&lt;T, E&gt; {
       Ok(T),
       Err(E)
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span> {
   <span class='prelude-val'>Ok</span>(<span class='ident'>T</span>),
   <span class='prelude-val'>Err</span>(<span class='ident'>E</span>)
}</pre>

<p>Esta enum es proporcionada por Rust, es por ello que no necesitas definirla si deseas hacer uso de ella. La variante <code>Ok(T)</code> representa éxito, y la variante <code>Err(E)</code> representa una falla. Retornar un <code>Result</code> en lugar de un <code>Option</code> es recomendable para la mayoría de los casos no triviales:</p>

<p>He aquí un ejemplo del uso de <code>Result</code>:</p>
<span class='rusttest'>#[derive(Debug)]
enum Version { Version1, Version2 }

#[derive(Debug)]
enum ErrorParseo { LongitudCabeceraInvalida, VersionInvalida }

fn parsear_version(cabecera: &amp;[u8]) -&gt; Result&lt;Version, ErrorParseo&gt; {
    if cabecera.len() &lt; 1 {
        return Err(ErrorParseo::LongitudCabeceraInvalida);
    }
    match cabecera[0] {
        1 =&gt; Ok(Version::Version1),
        2 =&gt; Ok(Version::Version2),
        _ =&gt; Err(ErrorParseo::LongitudCabeceraInvalida)
    }
}

fn main() {
    let version = parsear_version(&amp;[1, 2, 3, 4]);
    match version {
    Ok(v) =&gt; {
      println!(&quot;trabajando con la version: {:?}&quot;, v);
    }
    Err(e) =&gt; {
      println!(&quot;error parseando cebecera: {:?}&quot;, e);
    }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>Version</span> { <span class='ident'>Version1</span>, <span class='ident'>Version2</span> }

<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>ErrorParseo</span> { <span class='ident'>LongitudCabeceraInvalida</span>, <span class='ident'>VersionInvalida</span> }

<span class='kw'>fn</span> <span class='ident'>parsear_version</span>(<span class='ident'>cabecera</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Version</span>, <span class='ident'>ErrorParseo</span><span class='op'>&gt;</span> {
    <span class='kw'>if</span> <span class='ident'>cabecera</span>.<span class='ident'>len</span>() <span class='op'>&lt;</span> <span class='number'>1</span> {
        <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>ErrorParseo</span>::<span class='ident'>LongitudCabeceraInvalida</span>);
    }
    <span class='kw'>match</span> <span class='ident'>cabecera</span>[<span class='number'>0</span>] {
        <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(<span class='ident'>Version</span>::<span class='ident'>Version1</span>),
        <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(<span class='ident'>Version</span>::<span class='ident'>Version2</span>),
        _ <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='ident'>ErrorParseo</span>::<span class='ident'>LongitudCabeceraInvalida</span>)
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>version</span> <span class='op'>=</span> <span class='ident'>parsear_version</span>(<span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>]);
    <span class='kw'>match</span> <span class='ident'>version</span> {
    <span class='prelude-val'>Ok</span>(<span class='ident'>v</span>) <span class='op'>=&gt;</span> {
      <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;trabajando con la version: {:?}&quot;</span>, <span class='ident'>v</span>);
    }
    <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> {
      <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;error parseando cebecera: {:?}&quot;</span>, <span class='ident'>e</span>);
    }
    }
}</pre>

<p>Esta función hace uso de un enum, <code>ErrorParseo</code>, para enumerar los errores que pueden ocurrir.</p>

<p>El trait <a href="../std/fmt/trait.Debug.html"><code>Debug</code></a> es el que nos permite imprimir el valor del enum usando la operación de formato <code>{:?}</code>.</p>

<h1 id='errores-no-recuperables-con-panic' class='section-header'><a href='#errores-no-recuperables-con-panic'>Errores no recuperables con <code>panic!</code></a></h1>
<p>En el caso de un error inesperado del cual no se pueda recuperar, la macro <code>panic!</code> se utiliza para inducir un pánico. Dicho pánico terminara abruptamente el hilo actual de ejecución proporcionando un mensaje de error:</p>
<span class='rusttest'>fn main() {
    panic!(&quot;boom&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;boom&quot;</span>);</pre>

<p>resulta en</p>

<pre><code class="language-text">thread &#39;&lt;main&gt;&#39; panicked at &#39;boom&#39;, hello.rs:2
</code></pre>

<p>cuando lo ejecutas.</p>

<p>Debido a que estas situaciones son relativamente raras, usa los pánicos con moderación.</p>

<h1 id='promoviendo-fallas-a-pánicos' class='section-header'><a href='#promoviendo-fallas-a-pánicos'>Promoviendo fallas a pánicos</a></h1>
<p>En ciertas circunstancias, aun sabiendo que una función puede fallar, podríamos querer tratar la falla como un pánico. Por ejemplo, <code>io::stdin().read_line(&amp;mut buffer)</code> retorna un <code>Result&lt;usize&gt;</code>, cuando hay un error leyendo la linea. Esto nos permite manejar y posiblemente recuperarnos en caso de error.</p>

<p>Si no queremos manejar el error, y en su lugar simplemente abortar el programa, podemos usar el método <code>unwrap()</code>:</p>
<span class='rusttest'>fn main() {
    io::stdin().read_line(&amp;mut buffer).unwrap();
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buffer</span>).<span class='ident'>unwrap</span>();</pre>

<p><code>unwrap()</code> hará un pánico (<code>panic!</code>) si el <code>Result</code> es <code>Err</code>. Esto básicamente dice &quot;Dame el valor, y si algo sale mal, simplemente aborta la ejecución&quot;. Esto es menos confiable que hacer match en el error y tratar de recuperarnos, pero al mismo tiempo es significativamente mas corto. Algunas veces, la terminación abrupta es apropiada.</p>

<p>Hay una manera que de hacer lo anterior que es un poco mejor que <code>unwrap()</code>:</p>
<span class='rusttest'>fn main() {
    let mut bufer = String::new();
    let bytes_leidos = io::stdin().read_line(&amp;mut bufer)
                          .ok()
                          .expect(&quot;Fallo al leer linea&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>bufer</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='kw'>let</span> <span class='ident'>bytes_leidos</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>bufer</span>)
                      .<span class='ident'>ok</span>()
                      .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo al leer linea&quot;</span>);</pre>

<p><code>ok()</code> convierte el <code>Result</code> en un <code>Option</code>, y <code>expect()</code> hace lo mismo que <code>unwrap()</code>, pero recibe un mensaje como argumento. Este mensaje es pasado a el <code>panic!</code> subyacente, proporcionando un mejor mensaje de error.</p>

<h1 id='usando-try' class='section-header'><a href='#usando-try'>Usando <code>try!</code></a></h1>
<p>Cuando escribimos código que llama a muchas funciones que retornan el tipo <code>Result</code>, el manejo de errores se puede tornar tedioso. La macro <code>try!</code> esconde algo de el código repetitivo correspondiente a la propagación de errores en la pila de llamadas.</p>

<p><code>try!</code> reemplaza:</p>
<span class='rusttest'>fn main() {
    use std::fs::File;
    use std::io;
    use std::io::prelude::*;
    
    struct Info {
        nombre: String,
        edad: i32,
        grado: i32,
    }
    
    fn escribir_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
        let mut archivo = File::create(&quot;mis_mejores_amigos.txt&quot;).unwrap();
    
        if let Err(e) = writeln!(&amp;mut archivo, &quot;nombre: {}&quot;, info.nombre) {
            return Err(e)
        }
        if let Err(e) = writeln!(&amp;mut archivo, &quot;edad: {}&quot;, info.edad) {
            return Err(e)
        }
        if let Err(e) = writeln!(&amp;mut archivo, &quot;grado: {}&quot;, info.rgrado) {
            return Err(e)
        }
    
        return Ok(());
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>prelude</span>::<span class='op'>*</span>;

<span class='kw'>struct</span> <span class='ident'>Info</span> {
    <span class='ident'>nombre</span>: <span class='ident'>String</span>,
    <span class='ident'>edad</span>: <span class='ident'>i32</span>,
    <span class='ident'>grado</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>escribir_info</span>(<span class='ident'>info</span>: <span class='kw-2'>&amp;</span><span class='ident'>Info</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>archivo</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;mis_mejores_amigos.txt&quot;</span>).<span class='ident'>unwrap</span>();

    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=</span> <span class='macro'>writeln</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>archivo</span>, <span class='string'>&quot;nombre: {}&quot;</span>, <span class='ident'>info</span>.<span class='ident'>nombre</span>) {
        <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>)
    }
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=</span> <span class='macro'>writeln</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>archivo</span>, <span class='string'>&quot;edad: {}&quot;</span>, <span class='ident'>info</span>.<span class='ident'>edad</span>) {
        <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>)
    }
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=</span> <span class='macro'>writeln</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>archivo</span>, <span class='string'>&quot;grado: {}&quot;</span>, <span class='ident'>info</span>.<span class='ident'>rgrado</span>) {
        <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>)
    }

    <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(());
}</pre>

<p>Con:</p>
<span class='rusttest'>fn main() {
    use std::fs::File;
    use std::io;
    use std::io::prelude::*;
    
    struct Info {
        nombre: String,
        edad: i32,
        grado: i32,
    }
    
    fn escribir_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
        let mut archivo = File::create(&quot;mis_mejores_amigos.txt&quot;).unwrap();
    
        try!(writeln!(&amp;mut archivo, &quot;nombre: {}&quot;, info.nombre));
        try!(writeln!(&amp;mut archivo, &quot;edad: {}&quot;, info.edad));
        try!(writeln!(&amp;mut archivo, &quot;grado: {}&quot;, info.grado));
    
        return Ok(());
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>prelude</span>::<span class='op'>*</span>;

<span class='kw'>struct</span> <span class='ident'>Info</span> {
    <span class='ident'>nombre</span>: <span class='ident'>String</span>,
    <span class='ident'>edad</span>: <span class='ident'>i32</span>,
    <span class='ident'>grado</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>escribir_info</span>(<span class='ident'>info</span>: <span class='kw-2'>&amp;</span><span class='ident'>Info</span>) <span class='op'>-&gt;</span> <span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>archivo</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;mis_mejores_amigos.txt&quot;</span>).<span class='ident'>unwrap</span>();

    <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>writeln</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>archivo</span>, <span class='string'>&quot;nombre: {}&quot;</span>, <span class='ident'>info</span>.<span class='ident'>nombre</span>));
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>writeln</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>archivo</span>, <span class='string'>&quot;edad: {}&quot;</span>, <span class='ident'>info</span>.<span class='ident'>edad</span>));
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>writeln</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>archivo</span>, <span class='string'>&quot;grado: {}&quot;</span>, <span class='ident'>info</span>.<span class='ident'>grado</span>));

    <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(());
}</pre>

<p>Envolver una expresión con <code>try!</code> resultara en el valor (<code>Ok</code>) exitoso desenvuelto, a menos que el resultado sea <code>Err</code>, caso en el cual <code>Err</code> es retornado de manera temprana por la función que envuelve al try.</p>

<p>Es importante hacer mención a el hecho de que solo puedes usar <code>try!</code> desde una función que retorna un <code>Result</code>, lo que se traduce en que no puedes usar <code>try!</code> dentro de <code>main()</code>, debido a que <code>main()</code> no retorna nada.</p>

<p><code>try!</code> hace uso de <a href="../std/convert/trait.From.html"><code>From&lt;Error&gt;</code></a> (ingles) para determinar que retornar en el caso de error.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>
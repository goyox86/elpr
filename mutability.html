<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Mutabilidad</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a class='active' href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patrones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Mutabilidad</h1>
    <p>Mutabilidad, es la habilidad que una cosa posee para ser cambiada, funciona un poco diferente en Rust que en otros lenguajes. El primer aspecto de la mutabilidad es que no esta habilitada por defecto:</p>
<span class='rusttest'>fn main() {
    let x = 5;
    x = 6; // error!
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>6</span>; <span class='comment'>// error!</span></pre>

<p>Podemos introducir mutabilidad con la palabra reservada <code>mut</code>:</p>
<span class='rusttest'>fn main() {
    let mut x = 5;
    
    x = 6; // no hay problema!
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>6</span>; <span class='comment'>// no hay problema!</span></pre>

<p>Esto es un enlace a variable mutable. Cuando un enlace a variable es mutable, significa que tienes permitido cambiar a lo que el enlace apunta. Entonces, en el ejemplo anterior, no esta cambiando el valor en <code>x</code>, en cambio, el enlace cambio de un <code>i32</code> a otro.</p>

<p>Si deseas cambiar a que apunta el enlace a variable, necesitaras una <a href="references-and-borrowing.html">referencia mutable</a>:</p>
<span class='rusttest'>fn main() {
    let mut x = 5;
    let y = &amp;mut x;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>;</pre>

<p><code>y</code> es un enlace a variable inmutable a una referencia mutable, lo que significa que no puedes asociar <code>y</code> a otra cosa (<code>y = &amp;mut z</code>), pero puedes mutar lo que sea a lo que <code>y</code> esta asociado (<code>*y = 5</code>). Una diferencia muy sutil.</p>

<p>Por supuesto, si necesitas ambas cosas:</p>
<span class='rusttest'>fn main() {
    let mut x = 5;
    let mut y = &amp;mut x;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>;</pre>

<p>Ahora <code>y</code> puede ser asociado a otro valor, y el valor que esta referenciando puede ser cambiado.</p>

<p>Es importante notar que <code>mut</code> es parte de un <a href="patterns.html">patron</a>, de manera tal que puedas hacer cosas como:</p>
<span class='rusttest'>fn main() {
    let (mut x, y) = (5, 6);
    
    fn foo(mut x: i32) {
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='kw-2'>mut</span> <span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=</span> (<span class='number'>5</span>, <span class='number'>6</span>);

<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>i32</span>) {</pre>

<h1 id='mutabilidad-interior-vs-mutabilidad-exterior' class='section-header'><a href='#mutabilidad-interior-vs-mutabilidad-exterior'>Mutabilidad Interior vs. Mutabilidad Exterior</a></h1>
<p>Sin embargo, cuando decimos que algo es ‘immutable’ en Rust, esto no significa que no pueda ser cambiado: lo que decimos es que algo tiene ‘mutabilidad exterior’. Considera, por ejemplo, <a href="../std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>:</p>
<span class='rusttest'>fn main() {
    use std::sync::Arc;
    
    let x = Arc::new(5);
    let y = x.clone();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>Arc</span>;

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='number'>5</span>);
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>clone</span>();</pre>

<p>Cuando llamamos a <code>clone()</code>, el <code>Arc&lt;T&gt;</code> necesita actualizar el contador de referencias. A pesar de que no hemos usado ningún <code>mut</code> aquí, <code>x</code> es un enlace inmutable, tampoco tomamos <code>&amp;mut 5</code> o alguna mas. Entonces, que esta pasando?</p>

<p>Para entender esto, debemos volver al núcleo de la filosofía que guía a Rust, seguridad en el manejo de memoria, y el mecanismo a través del cual Rust la garantiza, el sistema de <a href="ownership.html">pertenencia</a>, y mas específicamente, el <a href="references-and-borrowing.html#borrowing">préstamo</a>:</p>

<blockquote>
<p>Puedes tener uno u otro de estos dos tipos de prestamo, pero no los dos al mismo tiempo:</p>

<ul>
<li>una o mas referencias (<code>&amp;T</code>) a un recurso,</li>
<li>exactamente una referencia mutable (<code>&amp;mut T</code>).</li>
</ul>
</blockquote>

<p>Entonces, esa es la definición real de ‘inmutabilidad’: es seguro tener dos apuntadores? En el caso de <code>Arc&lt;T&gt;</code>’s, si: la mutación esta completamente contenida dentro de la estructura en si misma. No esta disponible al usuario. Por esta razón, retorna <code>clone()</code> <code>&amp;T</code>s. Si proporcionase <code>&amp;mut T</code>s, seria un problema.</p>

<p>Otros tipos como los del modulo <a href="../std/cell/index.html"><code>std::cell</code></a>, poseen lo opuesto: mutabilidad interior. Por ejemplo:</p>
<span class='rusttest'>fn main() {
    use std::cell::RefCell;
    
    let x = RefCell::new(42);
    
    let y = x.borrow_mut();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>RefCell</span>;

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>RefCell</span>::<span class='ident'>new</span>(<span class='number'>42</span>);

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>borrow_mut</span>();</pre>

<p>RefCel proporciona referencias <code>&amp;mut</code> a lo que contienen a traves del metodo <code>borrow_mut()</code>. No es esto peligroso? Que tal si hacemos:</p>
<span class='rusttest'>fn main() {
    use std::cell::RefCell;
    
    let x = RefCell::new(42);
    
    let y = x.borrow_mut();
    let z = x.borrow_mut();
    (y, z);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>RefCell</span>;

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>RefCell</span>::<span class='ident'>new</span>(<span class='number'>42</span>);

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>borrow_mut</span>();
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>borrow_mut</span>();</pre>

<p>Esto, en efecto, hará pánico en tiempo de ejecución. Esto es lo que <code>RefCell</code> hace: aplica las reglas de préstamo de Rust en tiempo de ejecución, y hace <code>panic!</code>os si dichas reglas son violadas. Lo anterior nos permite acercarnos a otro aspecto de las reglas de mutabilidad de Rust. Hablemos acerca de ello primero.</p>

<h2 id='mutabilidad-a-nivel-de-campos' class='section-header'><a href='#mutabilidad-a-nivel-de-campos'>Mutabilidad a nivel de campos</a></h2>
<p>La mutabilidad es una propiedad de un préstamo (<code>&amp;mut</code>) o un enlace a variable (<code>let mut</code>). Esto se traduce en que, por ejemplo, no puedes tener un <a href="structs.html"><code>struct</code></a> con algunos campos mutables y otros inmutables:</p>
<span class='rusttest'>fn main() {
    struct Punto {
        x: i32,
        mut y: i32, // nope
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Punto</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='kw-2'>mut</span> <span class='ident'>y</span>: <span class='ident'>i32</span>, <span class='comment'>// nope</span>
}</pre>

<p>La mutabilidad de un struct esta en su enlace a variable:</p>
<span class='rusttest'>fn main() {
    struct Punto {
        x: i32,
        y: i32,
    }
    
    let mut a = Punto { x: 5, y: 6 };
    
    a.x = 10;
    
    let b = Punto { x: 5, y: 6};
    
    b.x = 10; // error: cannot assign to immutable field `b.x`
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Punto</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>Punto</span> { <span class='ident'>x</span>: <span class='number'>5</span>, <span class='ident'>y</span>: <span class='number'>6</span> };

<span class='ident'>a</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10</span>;

<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>Punto</span> { <span class='ident'>x</span>: <span class='number'>5</span>, <span class='ident'>y</span>: <span class='number'>6</span>};

<span class='ident'>b</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10</span>; <span class='comment'>// error: cannot assign to immutable field `b.x`</span></pre>

<p>Sin embargo, usando <a href="../std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a>, puedes emular mutabilidad a nivel de campos:</p>
<span class='rusttest'>fn main() {
    use std::cell::Cell;
    
    struct Punto {
        x: i32,
        y: Cell&lt;i32&gt;,
    }
    
    let punto = Punto { x: 5, y: Cell::new(6) };
    
    punto.y.set(7);
    
    println!(&quot;y: {:?}&quot;, punto.y);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>Cell</span>;

<span class='kw'>struct</span> <span class='ident'>Punto</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>,
}

<span class='kw'>let</span> <span class='ident'>punto</span> <span class='op'>=</span> <span class='ident'>Punto</span> { <span class='ident'>x</span>: <span class='number'>5</span>, <span class='ident'>y</span>: <span class='ident'>Cell</span>::<span class='ident'>new</span>(<span class='number'>6</span>) };

<span class='ident'>punto</span>.<span class='ident'>y</span>.<span class='ident'>set</span>(<span class='number'>7</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;y: {:?}&quot;</span>, <span class='ident'>punto</span>.<span class='ident'>y</span>);</pre>

<p>Esto imprimirá <code>y: Cell { value: 7 }</code>. Hemos actualizado <code>y</code> de manera satisfactoria.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
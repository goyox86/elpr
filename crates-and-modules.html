<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Crates y Modulos</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a class='active' href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Crates y Modulos</h1>
    <p>Cuando un proyecto comienza a crecer, se considera buena practica de ingeniería de software dividirlo en un grupo de componentes mas pequeños que posteriormente serán unidos. También es importante tener una interfaz bien definida, de manera que una parte de la funcionalidad sea privada, y otra publica. Para facilitar esto, Rust posee un sistema de módulos.</p>

<h1 id='terminologia-basica-crates-y-modulos' class='section-header'><a href='#terminologia-basica-crates-y-modulos'>Terminologia basica: Crates y Modulos</a></h1>
<p>Rust posee dos términos distintos relacionados con el sistema de módulos: ‘crate’ y ‘modulo’. Un crate es un sinónimo para ‘biblioteca’ or ‘paquete’ en otros lenguajes. De allí el nombre “Cargo” del manejador de paquetes de Rust: haces disponibles tus crates a los demás con Cargo. Los crates pueden producir un ejecutables o una biblioteca, dependiendo del proyecto.</p>

<p>Cada crate posee un <em>modulo raiz</em> implícito que contiene el código para dicho crate. Puedes definir un árbol de sub-modulos bajo el módulo raíz. Los módulos te permiten particionar tu codigo dentro del crate.</p>

<p>Como ejemplo, creemos un crate <em>frases</em>, que nos proveerá varias frases en diferentes idiomas. Para mantener las cosas simples, nos apegaremos solo a ‘saludos’ y ‘despedidas’ como los dos tipos de frases, así como Ingles y Japonés (日本語) para los dos idiomas en los que las frases estarán representadas. Tendremos la siguiente distribución de módulos:</p>

<pre><code class="language-text">                                      +-----------+
                                  +---|  saludos  |
                                  |   +-----------+
                   +----------+   |
               +---|  ingles  |---+
               |   +----------+   |   +-----------+
               |                  +---| despedidas |
+----------+   |                      +-----------+
|  frases  |---+
+----------+   |                      +-----------+
               |                  +---|  saludos  |
               |   +-----------+  |   +-----------+
               +---|  japonés  |--+
                   +-----------+  |
                                  |   +------------+
                                  +---| despedidas |
                                      +------------+
</code></pre>

<p>En este ejemplo, <code>frases</code> es el nombre de nuestro crate. El resto son módulos. Puedes observar que los módulos forman un árbol, partiendo desde la <em>raíz</em>, que a su vez es la raíz del árbol <code>frases</code> en si.</p>

<p>Ahora que tenemos un plan, definamos estos módulos en código. Para comenzar, generemos un proyecto con Cargo:</p>

<pre><code class="language-bash">$ cargo new frases
$ cd frases
</code></pre>

<p>Si recuerdas, lo anterior genera un proyecto simple:</p>

<pre><code class="language-bash">$ tree .
.
├── Cargo.toml
└── src
    └── lib.rs

1 directory, 2 files
</code></pre>

<p><code>src/lib.rs</code> es la raíz de nuestro crate, correspondiendo con <code>frases</code> en nuestro diagrama anterior.
above.</p>

<h1 id='definiendo-módulos' class='section-header'><a href='#definiendo-módulos'>Definiendo Módulos</a></h1>
<p>Para definir cada uno de nuestros módulos, usamos la palabra reservada <code>mod</code>. Hagamos que nuestro <code>src/lib.rs</code> se vea así:</p>
<span class='rusttest'>fn main() {
    mod ingles {
        mod saludos {
        }
    
        mod despedidas {
        }
    }
    
    mod japones {
        mod saludos {
        }
    
        mod despedidas {
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>ingles</span> {
    <span class='kw'>mod</span> <span class='ident'>saludos</span> {
    }

    <span class='kw'>mod</span> <span class='ident'>despedidas</span> {
    }
}

<span class='kw'>mod</span> <span class='ident'>japones</span> {
    <span class='kw'>mod</span> <span class='ident'>saludos</span> {
    }

    <span class='kw'>mod</span> <span class='ident'>despedidas</span> {
    }
}</pre>

<p>Después de la palabra reservada <code>mod</code> debes proporcionar el nombre del modulo. Los nombres de de modulo siguen las mismas convenciones que los demás identificadores en Rust: <code>snake_case_en_minusculas</code>. El contenido de cada modulo esta delimitado por llaves (<code>{}</code>).</p>

<p>Dentro de un determinado <code>mod</code>, puedes declarar sub-<code>mod</code>s. Podemos referirnos a los sub-modulos con una notación dos puntos dobles (<code>::</code>): nuestros cuatro módulos anidados son <code>ingles::saludos</code>, <code>ingles::despedidas</code>, <code>japones::saludos</code>, y <code>japones::despedidas</code>. Debido a que estos sub-modulos están dentro del espacio de nombres del modulo padre, los nombres no entran en conflicto: <code>ingles::saludos</code> y <code>japones::saludos</code> son distintos incluso cuando sus nombres son ambos <code>saludos</code>.</p>

<p>Debido a que este crate no posee una función <code>main()</code>, y se llama <code>lib.rs</code>, Cargo construirá este crate como una biblioteca:</p>

<pre><code class="language-bash">$ cargo build
   Compiling frases v0.0.1 (file:///home/tu/proyectos/frases)
$ ls target/debug
build  deps  examples  libfrases-a7448e02a0468eaa.rlib  native
</code></pre>

<p><code>libfrases-hash.rlib</code> es el crate compilado. Antes de ver como usar este crate desde otro, dividámoslo en multiples archivos.</p>

<h1 id='crates-con-multiple-archivos' class='section-header'><a href='#crates-con-multiple-archivos'>Crates con multiple archivos</a></h1>
<p>Si cada crate fuera un solo archivo, dichos archivos serian bastante grandes. Es mas fácil dividir los crates en multiples archivos. Rust soporta esto de dos maneras.</p>

<p>En lugar de declarar un modulo así:</p>
<span class='rusttest'>fn main() {
    mod ingles {
        // el contenido del modulo va aquí
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>ingles</span> {
    <span class='comment'>// el contenido del modulo va aquí</span>
}</pre>

<p>Podemos declararlo de esta forma:</p>
<span class='rusttest'>fn main() {
    mod ingles;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>ingles</span>;</pre>

<p>Si hacemos eso, Rust esperara encontrar bien un archivo <code>ingles.rs</code> o un archivo <code>ingles/mod.rs</code> con el contenido de nuestro modulo.</p>

<p>Nota que todos en estos archivos, no necesitas re-declarar el modulo: con la declaración inicial <code>mod</code> es suficiente.</p>

<p>Usando estas dos técnicas, podemos partir nuestro crate en dos directorios y siete archivos:</p>

<pre><code class="language-bash">$ tree .
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── ingles
│   │   ├── despedidas.rs
│   │   ├── saludos.rs
│   │   └── mod.rs
│   ├── japones
│   │   ├── despedidas.rs
│   │   ├── saludos.rs
│   │   └── mod.rs
│   └── lib.rs
└── target
    └── debug
        ├── build
        ├── deps
        ├── examples
        ├── libfrases-a7448e02a0468eaa.rlib
        └── native
</code></pre>

<p><code>src/lib.rs</code> es la raíz de nuestro crate, y luce así:</p>
<span class='rusttest'>fn main() {
    mod ingles;
    mod japones;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>ingles</span>;
<span class='kw'>mod</span> <span class='ident'>japones</span>;</pre>

<p>Estas dos declaraciones le dicen a Rust que busque bien sea <code>src/ingles.rs</code> y <code>src/japones.rs</code>, o <code>src/ingles/mod.rs</code> y <code>src/japones/mod.rs</code>, dependiendo de nuestra preferencia. En este caso, debido a que nuestros módulos poseen sub-modulos hemos seleccionado la segunda. Ambos <code>src/ingles/mod.rs</code> y <code>src/japones/mod.rs</code>se ven lucen de esta manera:</p>
<span class='rusttest'>fn main() {
    mod saludos;
    mod despedidas;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>saludos</span>;
<span class='kw'>mod</span> <span class='ident'>despedidas</span>;</pre>

<p>De nuevo, estas declaraciones hacen que Rust busque bien sea por <code>src/ingles/saludos.rs</code> y <code>src/japones/saludos.rs</code> o <code>src/ingles/despedidas/mod.rs</code> and <code>src/japones/despedidas/mod.rs</code>. Debido a que los sub-modulos no poseen sus propios sub-modulos, hemos optado por usar el enfoque <code>src/ingles/saludos.rs</code> and <code>src/japones/despedidas.rs</code>. Uff!</p>

<p>Ambos <code>src/ingles/saludos.rs</code> y <code>src/japones/despedidas.rs</code> están vacíos por el momento. Agreguemos algunas funciones.</p>

<p>Coloca esto en <code>src/ingles/saludos.rs</code>:</p>
<span class='rusttest'>fn main() {
    fn hola() -&gt; String {
        &quot;Hello!&quot;.to_string()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>hola</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;Hello!&quot;</span>.<span class='ident'>to_string</span>()
}</pre>

<p>Put this in <code>src/ingles/despedidas.rs</code>:</p>
<span class='rusttest'>fn main() {
    fn adios() -&gt; String {
        &quot;Goodbye.&quot;.to_string()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>adios</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;Goodbye.&quot;</span>.<span class='ident'>to_string</span>()
}</pre>

<p>Put this in <code>src/japones/saludos.rs</code>:</p>
<span class='rusttest'>fn main() {
    fn hello() -&gt; String {
        &quot;こんにちは&quot;.to_string()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>hello</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;こんにちは&quot;</span>.<span class='ident'>to_string</span>()
}</pre>

<p>Por supuesto, puedes copiar y pegar el Japones desde esta pagina web, o simplemente escribe alguna otra cosa. No es importante que en efecto coloques ‘konnichiwa’ para aprender acerca del sistema de módulos de Rust.</p>

<p>Coloca lo siguiente en <code>src/japones/despedidas.rs</code>:</p>
<span class='rusttest'>fn main() {
    fn adios() -&gt; String {
        &quot;さようなら&quot;.to_string()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>adios</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;さようなら&quot;</span>.<span class='ident'>to_string</span>()
}</pre>

<p>(‘Sayōnara’, por si eres curioso.)</p>

<p>Ahora que tenemos algo de funcionalidad en nuestro crate, intentemos usarlos desde otro.</p>

<h1 id='importing-external-crates' class='section-header'><a href='#importing-external-crates'>Importing External Crates</a></h1>
<p>Ya tenemos un crate biblioteca. Creemos un crate ejecutable que importe y use nuestra biblioteca.</p>

<p>Crea un archivo <code>src/main.rs</code> y coloca esto en el (no compilara todavía):</p>
<span class='rusttest'>extern crate frases;

fn main() {
    println!(&quot;Hola en Ingles: {}&quot;, frases::ingles::saludos::hola());
    println!(&quot;Adios en Ingles: {}&quot;, frases::ingles::despedidas::adios());

    println!(&quot;Hola en Japones: {}&quot;, frases::japones::saludos::hola());
    println!(&quot;Adios en Japones: {}&quot;, frases::japones::despedidas::adios());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>frases</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Ingles: {}&quot;</span>, <span class='ident'>frases</span>::<span class='ident'>ingles</span>::<span class='ident'>saludos</span>::<span class='ident'>hola</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adios en Ingles: {}&quot;</span>, <span class='ident'>frases</span>::<span class='ident'>ingles</span>::<span class='ident'>despedidas</span>::<span class='ident'>adios</span>());

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Japones: {}&quot;</span>, <span class='ident'>frases</span>::<span class='ident'>japones</span>::<span class='ident'>saludos</span>::<span class='ident'>hola</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adios en Japones: {}&quot;</span>, <span class='ident'>frases</span>::<span class='ident'>japones</span>::<span class='ident'>despedidas</span>::<span class='ident'>adios</span>());
}</pre>

<p>La declaración <code>extern crate</code> le informa a Rust que necesitamos compilar y enlazar al crate <code>frases</code>. Podemos entonces usar el modulo <code>frases</code> aqui. Como mencionamos anteriormente, puedes hacer uso de dos puntos dobles para hacer referencia a los sub-modulos y las funciones dentro de ellos.</p>

<p>Nota: cuando se importa un crate que tiene guiones en su nombre &quot;como-este&quot;, lo cual no es un identificador valido en Rust, sera convertido cambiándole los guiones a guiones bajos, así que escribirías algo como <code>extern crate como_este;</code></p>

<p>También, Cargo assume que <code>src/main.rs</code> es la raíz de un crate binario, en lugar de un crate biblioteca. Nuestro paquete ahora tiene dos crate: <code>src/lib.rs</code> y <code>src/main.rs</code>. Este patron es muy común en crates ejecutables: la mayoría de la funcionalidad esta en un crate biblioteca, y el crate ejecutable usa dicha biblioteca. De esta forma, otros programas pueden también hacer uso de la biblioteca, aunado a que ofrece un buena separación de responsabilidades.</p>

<p>Lo anterior todavía no funciona. Obtenemos cuatro errores que lucen similares a estos:</p>

<pre><code class="language-bash">$ cargo build
   Compiling frases v0.0.1 (file:///home/tu/proyectos/frases)
src/main.rs:4:38: 4:72 error: function `hola` is private
src/main.rs:4     println!(&quot;Hola en Ingles: {}&quot;, frases::ingles::saludos::hola());
                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:58 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
frases/src/main.rs:4:5: 4:76 note: expansion site
</code></pre>

<p>Por defecto todo es privado en Rust. Hablemos de esto con mayor detalle.</p>

<h1 id='exportando-una-interfaz-publica' class='section-header'><a href='#exportando-una-interfaz-publica'>Exportando una Interfaz Publica</a></h1>
<p>Rust te permite controlar de manera precisa cuales aspectos de tu interfaz son públicos, y private es el defacto. Para hacer a algo publico, debes hacer uso de la palabra reservada <code>pub</code>. Enfoquemonos primero en el modulo <code>ingles</code>, para ello, reduzcamos nuestro <code>src/main.rs</code> a:</p>
<span class='rusttest'>extern crate frases;

fn main() {
    println!(&quot;Hola en Ingles: {}&quot;, frases::ingles::saludos::hola());
    println!(&quot;Adios en Ingles: {}&quot;, frases::ingles::despedidas::adios());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>frases</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Ingles: {}&quot;</span>, <span class='ident'>frases</span>::<span class='ident'>ingles</span>::<span class='ident'>saludos</span>::<span class='ident'>hola</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adios en Ingles: {}&quot;</span>, <span class='ident'>frases</span>::<span class='ident'>ingles</span>::<span class='ident'>despedidas</span>::<span class='ident'>adios</span>());
}</pre>

<p>En nuestro <code>src/lib.rs</code>, agreguemos <code>pub</code> a la declaración del modulo <code>ingles</code>:</p>
<span class='rusttest'>fn main() {
    pub mod ingles;
    mod japones;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>ingles</span>;
<span class='kw'>mod</span> <span class='ident'>japones</span>;</pre>

<p>Y en nuestro <code>src/ingles/mod.rs</code>, hagamos a ambos <code>pub</code>:</p>
<span class='rusttest'>fn main() {
    pub mod saludos;
    pub mod despedidas;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>saludos</span>;
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>despedidas</span>;</pre>

<p>En nuestro <code>src/ingles/saludos.rs</code>, agreguemos <code>pub</code> a nuestra declaración <code>fn</code>:</p>
<span class='rusttest'>fn main() {
    pub fn hola() -&gt; String {
        &quot;Hola!&quot;.to_string()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>hola</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;Hola!&quot;</span>.<span class='ident'>to_string</span>()
}</pre>

<p>Y también en <code>src/ingles/despedidas.rs</code>:</p>
<span class='rusttest'>fn main() {
    pub fn adios() -&gt; String {
        &quot;Adios.&quot;.to_string()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>adios</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;Adios.&quot;</span>.<span class='ident'>to_string</span>()
}</pre>

<p>Ahora, nuestro crate compila, con unas pocas advertencias acerca de no haber usado las funciones en <code>japones</code>:</p>

<pre><code class="language-bash">$ cargo run
   Compiling frases v0.0.1 (file:///home/tu/proyectos/frases)
src/japones/saludos.rs:1:1: 3:2 warning: function is never used: `hola`, #[warn(dead_code)] on by default
src/japones/saludos.rs:1 fn hola() -&gt; String {
src/japones/saludos.rs:2     &quot;こんにちは&quot;.to_string()
src/japones/saludos.rs:3 }
src/japones/despedidas.rs:1:1: 3:2 warning: function is never used: `adios`, #[warn(dead_code)] on by default
src/japones/despedidas.rs:1 fn adios() -&gt; String {
src/japones/despedidas.rs:2     &quot;さようなら&quot;.to_string()
src/japones/despedidas.rs:3 }
     Running `target/debug/frases`
Hola en Ingles: Hello!
Adios en Ingles: Goodbye.
</code></pre>

<p><code>pub</code> también aplica a las <code>struct</code>s y sus campos miembro. Y Rust teniendo siempre su tendencia hacia la seguridad, el hacer una <code>struct</code> public no hará a sus miembros public automáticamente: debes marcarlos individualmente como <code>pub</code>.</p>

<p>Ahora que nuestras funciones son public, podemos hacer uso de ellas. Grandioso! Sin embargo, escribir <code>frases::ingles::saludos::hola()</code> es largo y repetitivo. Rust posee otra palabra reservada para importar nombres en el ámbito actual, de manera que puedas hacer referencia a ellos con nombres mas cortos, Hablemos acerca de <code>use</code>.</p>

<h1 id='importando-modulos-con-use' class='section-header'><a href='#importando-modulos-con-use'>Importando Modulos con <code>use</code></a></h1>
<p>Rust posee una palabra reservada, <code>use</code>, que te permite importar nombres en tu ámbito local. Cambiemos nuestro <code>src/main.rs</code> para que luzca de la siguiente manera:</p>
<span class='rusttest'>extern crate frases;

use frases::ingles::saludos;
use frases::ingles::despedidas;

fn main() {
    println!(&quot;Hola en Ingles: {}&quot;, saludos::hola());
    println!(&quot;Adios en Ingles: {}&quot;, despedidas::adios());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>frases</span>;

<span class='kw'>use</span> <span class='ident'>frases</span>::<span class='ident'>ingles</span>::<span class='ident'>saludos</span>;
<span class='kw'>use</span> <span class='ident'>frases</span>::<span class='ident'>ingles</span>::<span class='ident'>despedidas</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Ingles: {}&quot;</span>, <span class='ident'>saludos</span>::<span class='ident'>hola</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adios en Ingles: {}&quot;</span>, <span class='ident'>despedidas</span>::<span class='ident'>adios</span>());
}</pre>

<p>Las dos lineas <code>use</code> importan cada modulo en el ámbito local, de manera tal que podamos referirnos a las funciones con nombres mucho mas cortos. Por convención, cuando se importan funciones, se considera una buena practica importar el modulo, en lugar de la función directamente. En otras palabras, puedes <em>hacer</em> esto:</p>
<span class='rusttest'>extern crate frases;

use frases::ingles::saludos::hola;
use frases::ingles::despedidas::adios;

fn main() {
  println!(&quot;Hola en Ingles: {}&quot;, hola());
  println!(&quot;Adios en Ingles: {}&quot;, adios());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>frases</span>;

<span class='kw'>use</span> <span class='ident'>frases</span>::<span class='ident'>ingles</span>::<span class='ident'>saludos</span>::<span class='ident'>hola</span>;
<span class='kw'>use</span> <span class='ident'>frases</span>::<span class='ident'>ingles</span>::<span class='ident'>despedidas</span>::<span class='ident'>adios</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
  <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Ingles: {}&quot;</span>, <span class='ident'>hola</span>());
  <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adios en Ingles: {}&quot;</span>, <span class='ident'>adios</span>());
}</pre>

<p>Pero no es idiomático. Hacerlo de esta forma tiene altas probabilidades de introducir un conflicto de nombres. En nuestro pequeño programa, no es gran cosa, pero a medida que crece, se va convirtiendo en un problema. Si tenemos nombres conflictivos, Rust generara un error de compilación. Por ejemplo, de haber hecho publicas las funciones de <code>japones</code> y haber intentado:</p>
<span class='rusttest'>extern crate frases;

use frases::ingles::saludos::hola;
use frases::japones::saludos::hola;

fn main() {
    println!(&quot;Hola en Ingles: {}&quot;, hola());
    println!(&quot;Hola en Japones: {}&quot;, hola());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>frases</span>;

<span class='kw'>use</span> <span class='ident'>frases</span>::<span class='ident'>ingles</span>::<span class='ident'>saludos</span>::<span class='ident'>hola</span>;
<span class='kw'>use</span> <span class='ident'>frases</span>::<span class='ident'>japones</span>::<span class='ident'>saludos</span>::<span class='ident'>hola</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Ingles: {}&quot;</span>, <span class='ident'>hola</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Japones: {}&quot;</span>, <span class='ident'>hola</span>());
}</pre>

<p>Rust proporcionaría un error en tiempo de compilación:</p>

<pre><code class="language-text">   Compiling frases v0.0.1 (file:///home/tu/frases)
src/main.rs:4:5: 4:40 error: a value named `hola` has already been imported in this module [E0252]
src/main.rs:4 use frases::japones::saludos::hola;
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `frases`.
</code></pre>

<p>Si estuviéramos importando multiples nombres del mismo modulo, no necesitamos escribirlo dos veces. En lugar de:</p>
<span class='rusttest'>fn main() {
    use phrases::ingles::saludos;
    use phrases::ingles::despedidas;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>ingles</span>::<span class='ident'>saludos</span>;
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>ingles</span>::<span class='ident'>despedidas</span>;</pre>

<p>Podemos usar esta version mas corta:</p>
<span class='rusttest'>fn main() {
    use phrases::ingles::{saludos, despedidas};
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>ingles</span>::{<span class='ident'>saludos</span>, <span class='ident'>despedidas</span>};</pre>

<h2 id='re-exportando-con-pub-use' class='section-header'><a href='#re-exportando-con-pub-use'>Re-exportando con <code>pub use</code></a></h2>
<p>No solo usamos <code>use</code> para acortar identificadores. Puedes también usarlos dentro de tu crate para re-exportar una función dentro de otro modulo. Esto te permite presentar una interfaz externa que necesariamente no mapee de directamente a la organización interna de tu código.</p>

<p>Veamos un ejemplo. modifica tu <code>src/main.rs</code> para que se lea así:</p>
<span class='rusttest'>extern crate frases;

use frases::ingles::{saludos, despedidas};
use frases::japones;

fn main() {
    println!(&quot;Hola en Ingles: {}&quot;, saludos::hola());
    println!(&quot;Adios en Ingles: {}&quot;, despedidas::adios());

    println!(&quot;Hola en Japones: {}&quot;, japones::hola());
    println!(&quot;Adios en Japones: {}&quot;, japones::adios());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>frases</span>;

<span class='kw'>use</span> <span class='ident'>frases</span>::<span class='ident'>ingles</span>::{<span class='ident'>saludos</span>, <span class='ident'>despedidas</span>};
<span class='kw'>use</span> <span class='ident'>frases</span>::<span class='ident'>japones</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Ingles: {}&quot;</span>, <span class='ident'>saludos</span>::<span class='ident'>hola</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adios en Ingles: {}&quot;</span>, <span class='ident'>despedidas</span>::<span class='ident'>adios</span>());

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Japones: {}&quot;</span>, <span class='ident'>japones</span>::<span class='ident'>hola</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adios en Japones: {}&quot;</span>, <span class='ident'>japones</span>::<span class='ident'>adios</span>());
}</pre>

<p>Entonces, modifica tu <code>src/lib.rs</code> para hacer el modulo <code>japones</code> publico:</p>
<span class='rusttest'>fn main() {
    pub mod ingles;
    pub mod japones;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>ingles</span>;
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>japones</span>;</pre>

<p>A continuación, haz las dos funciones publicas, primero en <code>src/japones/saludos.rs</code>:</p>
<span class='rusttest'>fn main() {
    pub fn hola() -&gt; String {
        &quot;こんにちは&quot;.to_string()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>hola</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;こんにちは&quot;</span>.<span class='ident'>to_string</span>()
}</pre>

<p>Y luego en <code>src/japones/despedidas.rs</code>:</p>
<span class='rusttest'>fn main() {
    pub fn adios() -&gt; String {
        &quot;さようなら&quot;.to_string()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>adios</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;さようなら&quot;</span>.<span class='ident'>to_string</span>()
}</pre>

<p>Finalmente, modifica tu <code>src/japones/mod.rs</code> de esta forma:</p>
<span class='rusttest'>fn main() {
    pub use self::saludos::hola;
    pub use self::despedidas::adios;
    
    mod saludos;
    mod despedidas;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>saludos</span>::<span class='ident'>hola</span>;
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>despedidas</span>::<span class='ident'>adios</span>;

<span class='kw'>mod</span> <span class='ident'>saludos</span>;
<span class='kw'>mod</span> <span class='ident'>despedidas</span>;</pre>

<p>La declaración <code>pub use</code> trae la función a el ámbito en esta parte de nuestra jerarquía de modulos. Debido que hemos hecho <code>pub use</code> dentro de nuestro modulo <code>japones</code>, ahora tenemos una función <code>frases::japones::hola()</code> y una función <code>frases::japones::adios()</code>, aun cuando el código para ellas vive en <code>frases::japones::saludos::hola()</code> y frases::japones::despedidas::adios()`. Nuestra organización interna no define nuestra interfaz externa.</p>

<p>Acá tenemos un <code>pub use</code> para cada función que deseamos traer en el ámbito de <code>japones</code>. Alternativamente pudimos haber usado la sintaxis alternativa de comodín para incluir todo desde <code>saludos</code> en el ámbito actual: <code>pub use self::saludos::*</code></p>

<p>Que hay acerca de el <code>self</code>? Bueno, por defecto, las declaraciones <code>use</code> son rutas absolutas, partiendo desde la raíz de tu crate. <code>self</code>, a diferencia, hace esa ruta relativa a tu lugar actual dentro de la jerarquía. Hay una ultima forma especial de usar <code>use</code>: puedes usar <code>use super::</code> para alcanzar un nivel superior en la jerarquía desde tu posición actual. Algunas personas gustan ver a <code>self</code> como <code>.</code> y <code>super</code> como <code>..</code> similarmente los usados por los shells para mostrar los directorios actual y padre respectivamente.</p>

<p>Fuera de <code>use</code>, las rutas son relativas: <code>foo::bar()</code> se refiere a una función dentro de <code>foo</code> en relación a en donde estamos. Si posee un prefijo <code>::</code>, como en <code>::foo::bar()</code>, entonces se refiere a un <code>foo</code> diferente, una ruta absoluta desde la raíz de tu crate.</p>

<p>El ultimo código que escribimos, compilara y se ejecutara sin problemas:</p>

<pre><code class="language-bash">$ cargo run
   Compiling frases v0.0.1 (file:///home/tu/proyectos/frases)
     Running `target/debug/frases`
Hola in Ingles: Hello!
Adios in Ingles: Goodbye.
Hola in Japones: こんにちは
Adios in Japones: さようなら
</code></pre>

<h2 id='importes-complejos' class='section-header'><a href='#importes-complejos'>Importes complejos</a></h2>
<p>Rust ofrece un numero de opciones avanzadas que pueden hacer tus sentencias <code>extern crate</code> mas compactas y convenientes. He aquí un ejemplo:</p>
<span class='rusttest'>extern crate frases as dichos;

use dichos::japones::saludos as saludos_ja;
use dichos::japones::despedidas::*;
use dichos::ingles::{self, saludos as saludos_en, despedidas as despedidas_en};

fn main() {
    println!(&quot;Hola en Ingles; {}&quot;, saludos_en::hola());
    println!(&quot;Y en Japones: {}&quot;, saludos_ja::hola());
    println!(&quot;Goodbye in Ingles: {}&quot;, ingles::despedidas::adios());
    println!(&quot;Otra vez: {}&quot;, despedidas_en::adios());
    println!(&quot;Y en Japones: {}&quot;, adios());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>frases</span> <span class='kw'>as</span> <span class='ident'>dichos</span>;

<span class='kw'>use</span> <span class='ident'>dichos</span>::<span class='ident'>japones</span>::<span class='ident'>saludos</span> <span class='kw'>as</span> <span class='ident'>saludos_ja</span>;
<span class='kw'>use</span> <span class='ident'>dichos</span>::<span class='ident'>japones</span>::<span class='ident'>despedidas</span>::<span class='op'>*</span>;
<span class='kw'>use</span> <span class='ident'>dichos</span>::<span class='ident'>ingles</span>::{<span class='self'>self</span>, <span class='ident'>saludos</span> <span class='kw'>as</span> <span class='ident'>saludos_en</span>, <span class='ident'>despedidas</span> <span class='kw'>as</span> <span class='ident'>despedidas_en</span>};

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola en Ingles; {}&quot;</span>, <span class='ident'>saludos_en</span>::<span class='ident'>hola</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Y en Japones: {}&quot;</span>, <span class='ident'>saludos_ja</span>::<span class='ident'>hola</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Goodbye in Ingles: {}&quot;</span>, <span class='ident'>ingles</span>::<span class='ident'>despedidas</span>::<span class='ident'>adios</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Otra vez: {}&quot;</span>, <span class='ident'>despedidas_en</span>::<span class='ident'>adios</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Y en Japones: {}&quot;</span>, <span class='ident'>adios</span>());
}</pre>

<p>Que esta pasando?</p>

<p>Primero, ambos <code>extern crate</code> y <code>use</code> permiten renombrar lo que esta siendo importado. Entonces el crate todavía se llama &quot;frases&quot;, pero aquí nos referiremos a el como &quot;dichos&quot;. Similarmente, el primer <code>use</code> trae el modulo <code>japones::saludos</code> desde el crate, pero lo hace disponible a través del nombre <code>saludos_ja</code> en lugar de simplemente <code>saludos</code>. Lo anterior puede ayudar a evitar ambigüedad cuando se importan nombres similares desde distintos lugares.</p>

<p>El segundo <code>use</code> posee un asterisco para traer <em>todos</em> los símbolos desde el modulo <code>dichos::japones::despedidas</code>. Como podrás ver mas tarde podemos referirnos al <code>adios</code> Japones sin calificadores de modulo. Este tipo de glob debe ser usando con cautela.</p>

<p>El tercer <code>use</code> requiere un poco mas de explicación. Esta usando &quot;expansion de llaves&quot; para comprimir tres sentencias <code>use</code> en una (este tipo de sintaxis puede serte familiar si has escrito scripts del shell de Linux). La forma descomprimida de esta sentencia seria:</p>
<span class='rusttest'>fn main() {
    use dichos::ingles;
    use dichos::ingles::saludos as saludos_en;
    use dichos::ingles::despedidas as despedidas_en;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>dichos</span>::<span class='ident'>ingles</span>;
<span class='kw'>use</span> <span class='ident'>dichos</span>::<span class='ident'>ingles</span>::<span class='ident'>saludos</span> <span class='kw'>as</span> <span class='ident'>saludos_en</span>;
<span class='kw'>use</span> <span class='ident'>dichos</span>::<span class='ident'>ingles</span>::<span class='ident'>despedidas</span> <span class='kw'>as</span> <span class='ident'>despedidas_en</span>;</pre>

<p>Como puedes ver, las llaves comprimen las sentencias <code>use</code> para varios items bajo la misma ruta, y en este contexto <code>self</code> hace referencia a dicha ruta. Nota: Las llaves no pueden ser anidadas o mezcladas con globbing de asteriscos.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Juego de Adivinanzas</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a class='active' href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Monticulo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilacion Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentacion</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribucion</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> Ciclos for</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> Ciclos while</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> Referencias y Prestamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Sintaxis de Metodos</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Genericos</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Rasgos</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Objetos de Razgo</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Sintaxis de Llamada a Funciones Universal</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates y Modulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Conversion entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Tipos sin Tamano</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Inverstigacion Academica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Juego de Adivinanzas</h1>
    <p>Para nuestro primer proyecto, implementaremos un problema clásico de programación para principiantes: un juego de adivinanzas. Como funciona el juego: Nuestro programa generara un numero entero aleatorio entre uno y cien. Nos pedira que introduzcamos una corazonada. Despues de haber proporcionado nuestro numero, este nos dirá si estuvimos muy por debajo y muy por encima. Una vez que adivinemos el numero correcto, nos felicitara. Suena bien?</p>

<h1 id="configuración-inicial" class='section-header'><a
                           href="#configuración-inicial">Configuración Inicial</a></h1>
<p>Creemos un nuevo proyecto. Anda a tu directorio de proyectos. Recuerdas como creamos nuestra estructura de directorios y un <code>Cargo.toml</code> para <code>hola_mundo</code>? Cargo posse un comando que hace eso por nosotros. Probemoslo:</p>

<pre><code class="language-bash">$ cd ~/proyectos
$ cargo new adivinanzas --bin
$ cd adivinanzas
</code></pre>

<p>Pasamos el nombre de nuestro proyecto a <code>cargo new</code>, junto con el flag <code>--bin</code>, debido a que estamos creando un binario, en vez de una biblioteca.</p>

<p>Echa un vistazo al <code>Cargo.toml</code> generado:</p>

<pre><code class="language-toml">[package]

name = &quot;adivinanzas&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Tu Nombre &lt;tu@ejemplo.com&gt;&quot;]
</code></pre>

<p>Cargo obtiene esta información  de tu entorno. Si no esta correcta, corrigela.</p>

<p>Finalmente, Cargo ha generado un ‘Hola, mundo!’ para nosotros. Echa un vistazo a <code>src/main.rs</code>:</p>
<span class='rusttest'>fn main() {
    println!(&quot;Hello, world!&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world!&quot;</span>);
}
</pre>

<p>Tratemos de compilar lo que Cargo nos ha proporcionado:</p>

<pre><code class="language-{bash}">$ cargo build
   Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
</code></pre>

<p>Excelente! Abre tu <code>src/main.rs</code> otra vez. Estaremos escribiendo todo nuestro codigo en este archivo.</p>

<p>Antes de continuar, dejame mostrarte un comando mas de Cargo: <code>run</code>. <code>cargo run</code> es una especie de <code>cargo build</code>, pero con la diferencia de que tambien ejecuta el binario producido. Probemoslo:</p>

<pre><code class="language-bash">$ cargo run
   Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
     Running `target/debug/adivinanzas`
Hola, mundo!
</code></pre>

<p>Grandioso! El comando <code>run</code> es muy útil cuando necesitas iterar rapido en un proyecto. Nuestro juego es uno de esos proyectos, necesitaremos probar rapidamente cada iteración antes de movernos a la siguiente.</p>

<h1 id="procesando-un-intento-de-adivinanza" class='section-header'><a
                           href="#procesando-un-intento-de-adivinanza">Procesando un Intento de Adivinanza</a></h1>
<p>Probemoslo! La primera cosa que necesitamos hacer para nuestro juego de adivinanzas es permitir a nuestro jugador ingresar un intento de adivinanza. Coloca esto en tu <code>src/main.rs</code>:</p>
<span class='rusttest'>use std::io;

fn main() {
    println!(&quot;Adivina el numero!&quot;);

    println!(&quot;Por favor introduce tu corazonada.&quot;);

    let mut corazonada = String::new();

    io::stdin().read_line(&amp;mut corazonada)
        .ok()
        .expect(&quot;Fallo al leer linea&quot;);

    println!(&quot;Tu corazonada fue: {}&quot;, corazonada);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adivina el numero!&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Por favor introduce tu corazonada.&quot;</span>);

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>corazonada</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo al leer linea&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Tu corazonada fue: {}&quot;</span>, <span class='ident'>corazonada</span>);
}
</pre>

<p>Hay un monton aqui! Tratemos de ir a traves de ello, pieza por pieza.</p>
<span class='rusttest'>fn main() {
    use std::io;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
</pre>

<p>Necesitaremos recibir entrada del usuario, para luego imprimir el resultado como salida. Debido a esto necesitamos la biblioteca <code>io</code> de la biblioteca estandar. Rust solo importa unas pocas cosas para todos los programas, este conjunto de cosas se denomina <a href="../std/prelude/index.html">‘preludio’</a>. Si no esta en el preludio tendrás que llamarlo directamente a traves de <code>use</code>.</p>
<span class='rusttest'>fn main() {
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
</pre>

<p>Como has visto con anterioridad, la función <code>main()</code> es el punto de entrada a tu programa. La sintaxis <code>fn</code> declara una nueva función, los <code>()</code>s indican que no hay argumentos y  <code>{</code> comienza el cuerpo de la función. Debido a que no incluimos un tipo de retorno, se asume ser <code>()</code> una <a href="primitive-types.html#tuples">tupla</a> vacía.</p>
<span class='rusttest'>fn main() {
        println!(&quot;Adivina el numero!&quot;);
    
        println!(&quot;Por favor introduce tu corazonada.&quot;);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adivina el numero!&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Por favor introduce tu corazonada.&quot;</span>);
</pre>

<p>Anteriormente aprendimos que <code>println!()</code> es una <a href="macros.html">macro</a> que imprime una <a href="strings.html">cadena de caracteres</a> a la pantalla.</p>
<span class='rusttest'>fn main() {
        let mut corazonada = String::new();
    
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>corazonada</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
</pre>

<p>Ahora nos estamos poniendo interesantes! Hay un montón de cosas pasando en esta pequeña linea. La primera cosas a notar es que es una <a href="variable-bindings.html">sentencia let</a>, usada para crear variables. Tiene la forma:</p>
<span class='rusttest'>fn main() {
    let foo = bar;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='ident'>bar</span>;
</pre>

<p>Esto creara una nueva variable llamada <code>foo</code>, y la enlazara al valor <code>bar</code>. En muchos lenguajes, esto es llamado una ‘variable’ pero las variables de Rust tienen un par de trucos bajo la manga.</p>

<p>Por ejemplo, son <a href="mutability.html">immutables</a> por defecto. Es por ello que nuestro ejemplo usa <code>mut</code>: esto hace un binding mutable, en vez de inmutable. <code>let</code> no solo toma un nombre del lado izquierdo, <code>let</code> acepta un ‘<a href="patterns.html">patrón</a>’. Usaremos los patrones un poco mas tarde. Es suficiente por ahora usar:</p>
<span class='rusttest'>fn main() {
    let foo = 5; // inmutable.
    let mut bar = 5; // mutable
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// inmutable.</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>bar</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// mutable</span>
</pre>

<p>Ah,  <code>//</code> inicia un comentario, hasta el final de la linea. Rust ignora todo en <a href="comments.html">comentarios</a></p>

<p>Entonces sabemos que <code>let mut corazonada</code> introducirá un binding mutable llamado <code>corazonada</code>, pero tenemos que ver al otro lado del <code>=</code> para saber a que esta siendo asociado: <code>String::new()</code>.</p>

<p><code>String</code> es un tipo de cadena de caracter, proporcionado por la biblioteca estandar. Un  <a href="../std/string/struct.String.html"><code>String</code></a> es un segmento de texto codificado en UTF-8 capaz de crecer.</p>

<p>La sintaxis <code>::new()</code> usa <code>::</code> porque es una ‘función asociada’ de un tipo particular. Es decir esta asociada con <code>String</code> en si mismo, en vez de con una instacia en particular de <code>String</code>. Algunos lenguajes llaman a esto un ‘metodo estatico’.</p>

<p>Esta funcion es llamada <code>new()</code>, porque crea un nuevo <code>String</code> vacio. Encontraras una función <code>new()</code> en muchos tipos, debido a que es un nombre común para la creación de un nuevo valor de algun tipo.</p>

<p>Continuemos:</p>
<span class='rusttest'>fn main() {
        io::stdin().read_line(&amp;mut corazonada)
            .ok()
            .expect(&quot;Fallo lectura de linea&quot;);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo lectura de linea&quot;</span>);
</pre>

<p>Otro monton! Vallamos pieza por pieza. La primera linea tiene dos partes. He aqui la primera:</p>
<span class='rusttest'>fn main() {
    io::stdin()
    
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>io</span>::<span class='ident'>stdin</span>()
</pre>

<p>Recuerdas como usamos <code>use</code> en <code>std::io</code> en la primera linea de nuestro programa? Ahora estamos llamando una función asociada en <code>std::io</code>. De no haber usado <code>use std::io</code>, pudimos haber escrito esta linea como <code>std::io::stdin()</code>.</p>

<p>Esta función en particular retorna un handle a la entrada estándar de tu terminal. Mas especificamente, un <a href="../std/io/struct.Stdin.html">std::io::Stdin</a>.</p>

<p>La siguiente parte usara dicho handle para obtener entrada del usuario:</p>
<span class='rusttest'>fn main() {
    .read_line(&amp;mut corazonada)
    
}</span><pre class='rust rust-example-rendered'>
.<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
</pre>

<p>Aqui, llamamos el metodo <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line()</code></a> en nuestro handle. Los <a href="method-syntax.html">metodos</a> son similares a las funciones asociadas, pero solo estan disponibles en una instancia en particular de un tipo, en vez de en el tipo en si. También estamos pasando un argumento a <code>read_line()</code>: <code>&amp;mut corazonada</code>.</p>

<p>Recuerdas cuando creamos <code>corazonada</code>? Dijimos que era mutable. Sin embargo <code>read_line</code> no acepta un <code>String</code> como argumento: acepta un <code>&amp;mut String</code>. Rust posee una caracteristica llamada ‘<a href="references-and-borrowing.html">referencias</a>’ (‘references’), la cual permite tener multiples referencias a una pieza de data, de esta manera se reduce la necesidad de copiado. Las referencias son una caracteristica compleja, debido a que uno de los puntos de venta mas fuertes de Rust es acerca de cuan fácil y seguro es usar referencias. Por ahora no necesitamos saber mucho de esos detalles para finalizar nuestro programa. Todo lo que necesitamos saber por el momento es que al igual que los bindings <code>let</code> las referencias son inmutables por defecto. Como consecuencia necesitamos escribir <code>&amp;mut corazonada</code> en vez de <code>&amp;corazonada</code>.</p>

<p>Porque <code>read_line()</code> acepta una referencia mutable a una cadena de caracteres. Su trabajo es tomar lo que el usuario ingresa en la entrada estandar, y colocarlo en una cadena de caracteres. Debido a ello toma dicha cadena como argumento, y debido a que debe de agregar la entrada del usuario, este necesita ser mutable.</p>

<p>Todavia no hemos terminado con esta linea. Si bien es una sola linea de texto, es solo la primera parte de una linea logica de código completa:</p>
<span class='rusttest'>fn main() {
            .ok()
            .expect(&quot;Fallo lectura de linea&quot;);
    
}</span><pre class='rust rust-example-rendered'>
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo lectura de linea&quot;</span>);
</pre>

<p>Cuando llamas a un metodo con la sintaxis <code>.foo()</code> puedes introducir un salto de linea y otro espacio. Esto te ayuda a dividir lineas largas. Pudimos haber escrito:</p>
<span class='rusttest'>fn main() {
        io::stdin().read_line(&amp;mut corazonada).ok().expect(&quot;Fallo lectura de linea&quot;);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>).<span class='ident'>ok</span>().<span class='ident'>expect</span>(<span class='string'>&quot;Fallo lectura de linea&quot;</span>);
</pre>

<p>Pero eso es mas difícil de leer. Así que lo hemos dividido en tres lineas para tres llamadas a metodo. Ya hemos hablado de <code>read_line()</code>, pero que acerca de <code>ok()</code> y <code>expect()</code>? Bueno, ya mencionamos que <code>read_line()</code> coloca la entrada del usuario en el <code>&amp;mut String</code> que le proprocionamos. Pero tambien retorna un valor: en este caso un <a href="../std/io/type.Result.html"><code>io::Result</code></a>. Rust posee un numero de tipos llamados <code>Result</code> en su biblioteca estandar: un <a href="../std/result/enum.Result.html"><code>Result</code></a> generico, y versiones especificas para sub-bibliotecas, como <code>io::Result</code>.</p>

<p>El proposito de esos <code>Result</code> es codificar información de manejo de errores. Valores del tipo <code>Result</code> tienen metodos definidos en ellos. En este caso <code>io::Result</code> posee un metodo <code>ok()</code>, que se traduce en ‘queremos asumir que este valor es un valor exitoso. Sino, descarta la información acerca del error’. Porque descartar la información acerca del error?, para un programa básico, queremos simplemente imprimir un error generico, cualquier problema que signifique que no podamos continuar. El <a href="../std/result/enum.Result.html#method.ok">metodo <code>ok()</code></a> retorna un valor que tiene otro metodo definito en el: <code>expect()</code>. El <a href="../std/option/enum.Option.html#method.expect"><code>metodo expect()</code></a> toma el valor en el cual es llamado y si no es un valor exitoso, hace panico <a href="error-handling.html"><code>panic!</code></a> con un mensaje que le hemos proporcionado. Un <code>panic!</code> como este causara que el programa tenga una salida abrupta (crash), mostrando dicho mensaje.</p>

<p>Si quitamos las llamadas a esos  dos metodos, nuestro programa compilara, pero obtendremos una advertencia:</p>

<pre><code class="language-bash">$ cargo build
  Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
src/main.rs:10:5: 10:44 warning: unused result which must be used, #[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut corazonada);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>

<p>Rust nos advierte que no hemos usado el valor <code>Result</code>. Esta advertencia viene de una anotación especial que tiene <code>io::Result</code>. Rust esta tratando de decirte que no has manejado un posible error. La manera correcta de suprimir el error es, en efecto escribir el código para el manejo de erroes. Por suerte, si solo queremos terminar la ejecución del programa de haber un problema, podemos usar estos dos pequeños metodos. Si pudieramos recuperarnos del error de alguna manera, hariamos algo diferente, pero dejemos eso para un proyecto futuro.</p>

<p>Solo nos queda una linea de este primer ejemplo:</p>
<span class='rusttest'>fn main() {
        println!(&quot;Tu corazonada fue: {}&quot;, corazonada);
    }
    
}</span><pre class='rust rust-example-rendered'>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Tu corazonada fue: {}&quot;</span>, <span class='ident'>corazonada</span>);
}
</pre>

<p>Esta linea imprime la cadena de caracteres en la que guardamos nuestra entrada. Los <code>{}</code>s son marcadores de posición, es por ello que pasamos <code>adivinanza</code> como argumento.  De haber habido multiples <code>{}</code>s, debiamos haber pasado multiples argumentos:</p>
<span class='rusttest'>fn main() {
    let x = 5;
    let y = 10;
    
    println!(&quot;x y y: {} y {}&quot;, x, y);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x y y: {} y {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>);
</pre>

<p>Fácil.</p>

<p>De cualquier modo, ese es el tour. Podemos ejecutarlo con <code>cargo run</code>:</p>

<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/tu/proyectos/adivinanzas)
     Running `target/debug/adivinanzas`
Adivina el numero!
Por favor introduce tu corazonada.
6
Tu corazonada fue: 6
</code></pre>

<p>En hora buena! Nuestra primera parte ha terminado: podemos obtener entrada del teclado e imprimirla de vuelta.</p>

<h1 id="generando-un-numero-secreto" class='section-header'><a
                           href="#generando-un-numero-secreto">Generando un numero secreto</a></h1>
<p>A continuación necesitamos generar un numero secreto. Rust todavía no incluye una funcionalidad de numeros aleatorios en la biblioteca estándar. Sin embargo, el equipo de Rust provee un <a href="https://crates.io/crates/rand">crate <code>rand</code></a>. Un ‘crate’ es un paquete de código Rust. Nosotros hemos estado construyendo un ‘crate binaro’, el cual es un ejecutable. <code>rand</code> es un ‘crate biblioteca’, que contiene codigo a ser usado por otros programas.</p>

<p>Usar crates externos es donde Cargo realmente brilla. Antes que podamos escribir código que haga uso de <code>rand</code>, debemos modificar nuestro archivo <code>Cargo.toml</code>. Abrelo, y agrega estas lineas al final:</p>

<pre><code class="language-toml">[dependencies]

rand=&quot;0.3.0&quot;
</code></pre>

<p>La sección <code>[dependencies]</code> de <code>Cargo.toml</code> es como la sección <code>[package]</code>: todo lo que le sigue es parte de ella, hasta que la siguiente sección comience. Cargo usa la sección de dependencias para saber en cuales crates externos dependemos, asi como las versiones requeridas. En este caso hemos usado la versión <code>0.3.0</code>. Cargo entiende <a href="http://semver.org">Versionado Semantico</a>, que es un estandar para las escritura de numeros de versión. Si quisieramos usar la ultima version podriamos haber usado <code>*</code> o un rango de versiones. La <a href="http://doc.crates.io/crates-io.html">documentación de Cargo</a>  contiene mas detalles.</p>

<p>Ahora, sin cambiar nada en nuestro código, construyamos nuestro proyecto:</p>

<pre><code class="language-bash">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
</code></pre>

<p>(Podrias ver versiones diferentes, por supuesto.)</p>

<p>Un montón de salida mas! Ahora que tenemos una dependencia externa, Cargo descarga del registro las ultimas versiones de todo, lo cual puede copiar datos desde <a href="https://crates.io">Crates.io</a>. Crates.io es donde las personas del ecosistema Rust publican sus proyectos open source para que otros los usen.</p>

<p>Despues de actualizar el registro, Cargo chequea nuestras dependencias (en <code>[dependencies]</code>) y las descarga de no tenerlas todavía. En este caso solo dijimos que queriamos depender en <code>rand</code>, y tambien obtuvimos una copia de <code>libc</code>. Esto es debido a que <code>rand</code> depende a su vez de <code>libc</code> para funcionar. Despues de descargar las dependencias, Cargo las compila, para despues compilar nuestro código.</p>

<p>Si ejecutamos  <code>cargo build</code>, obtendremos una salida diferente:</p>

<pre><code class="language-bash">$ cargo build
</code></pre>

<p>Asi es, no hay salida! Cargo sabe que nuestro proyecto ha sido construido, asi como todas sus dependencias, asi que no nay razón para hacer todo el proceso otra vez. Sin nada que hacer, simplemente termina la ejecucion. Si abrimos <code>src/main.rs</code> otra vez, hacemos un cambio trivial, salvamos los cambios, solamente veriamos una linea:</p>

<pre><code class="language-bash">$ cargo build
    Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
</code></pre>

<p>Entonces, le hemos dicho a Cargo que queriamos cualquier versión <code>0.3.x</code> de <code>rand</code>, y este descargo la ultima versión para el momento de la escritura de este tutorial, <code>v0.3.8</code>. Pero que pasa cuando la siguiente versión <code>v0.3.9</code> sea publicada con un importante bugfix? Si bien recibir bugfixes es importante, que pasa si <code>0.3.9</code> contiene una regresion que rompe nuestro codigo?</p>

<p>La respuesta a este problema es el archivo <code>Cargo.lock</code>, archivo que encontraras en tu directorio de proyecto. Cuando construyes tu proyecto por primera vez, cargo determina todas las versiones que coinciden con tus criterios y las escribe en el archivo <code>Cargo.lock</code>. Cuando construyes tu proyecto en el futuro, Cargo notara que un archivo <code>Cargo.lock</code> existe, y usara las versiones especificadas en el mismo, en vez de hacer todo el trabajo de determinar las versiones otra vez. Esto te permite tener una construcción reproducible de manera automatica. En otras palabras, nos quedaremos en <code>0.3.8</code> hasta que subamos de version de manera explicita, de igual manera lo hará la gente con la que hemos compartido nuestro código, gracias al archivo <code>Cargo.lock</code>.</p>

<p>Pero que pasa cuando <em>queremos</em> usar <code>v0.3.9</code>? Cargo posee otro comando, <code>update</code>, que se traduce en ‘ignora el bloqueo y determina todas las ultimas versiones que coincidan con lo que hemos especficado. De funcionar esto, escribe esas versiones al archivo de bloqueo <code>Cargo.lock</code>’. Pero, por defecto, Cargo solo buscara versiones mayores a <code>0.3.0</code>
y menores a <code>0.4.0</code>. Si queremos movernos a <code>0.4.x</code>, necesitariamos actualizar el archivo <code>Cargo.toml</code> directamente. Cuando lo hacemos, la siguente vez que ejecutemos <code>cargo build</code>, Cargo actualizara el indice y re-evaluara nuestros requerimentos acerca de <code>rand</code>.</p>

<p>Hay mucho mas que decir acerca de <a href="http://doc.crates.io">Cargo</a> y <a href="http://doc.crates.io/crates-io.html">su ecosistema</a>, pero por ahora, eso es todo lo que necesitamos saber. Cargo hace realmente fácil reusar bibliotecas, y los Rusteros tienden a escribir proyectos pequenos los cuales estan construidos por un conjunto de paquetes mas pequeños.</p>

<p>Hagamos <em>uso</em> ahora de <code>rand</code>. He aqui nuestro siguiente paso:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Adivina el numero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;El numero secreto es: {}&quot;, numero_secreto);

    println!(&quot;Por favor introduce tu corazonada.&quot;);

    let mut corazonada = String::new();

    io::stdin().read_line(&amp;mut corazonada)
        .ok()
        .expect(&quot;Fallo al leer linea&quot;);

    println!(&quot;Tu corazonada fue: {}&quot;, corazonada);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adivina el numero!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>numero_secreto</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;El numero secreto es: {}&quot;</span>, <span class='ident'>numero_secreto</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Por favor introduce tu corazonada.&quot;</span>);

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>corazonada</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo al leer linea&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Tu corazonada fue: {}&quot;</span>, <span class='ident'>corazonada</span>);
}
</pre>

<p>La primera cosa que hemos hecho es cambiar la primera linea. Ahora dice <code>extern crate rand</code>. Debido a que declaramos <code>rand</code> en nuestra sección <code>[dependencies]</code>, podemos usar <code>extern crate</code> para hacerle saber a Rust que estaremos haciendo uso de <code>rand</code>. Esto es equivalente a un <code>use rand;</code>, de manera que podamos hacer uso de lo que sea dentro del crate <code>rand</code> a traves del prefijo <code>rand::</code>.</p>

<p>Después, hemos agregado otra linea <code>use</code>: <code>use rand::Rng</code>. En unos momentos estaremos haciendo uso de un metodo, y esto requiere que <code>Rng</code> este disponible para que funcione. La idea basica es la siguiente: los metodos estan dentro de algo llamado ‘traits’ (Rasgos), y para que el metodo funcione necesita que el trait este disponible. Para mayores detalles dirigete a la sección <a href="traits.html">Rasgos</a> (Traits).</p>

<p>Hay dos lineas mas en el medio:</p>
<span class='rusttest'>fn main() {
        let numero_secreto = rand::thread_rng().gen_range(1, 101);
    
        println!(&quot;El numero secreto es: {}&quot;, numero_secreto);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>let</span> <span class='ident'>numero_secreto</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;El numero secreto es: {}&quot;</span>, <span class='ident'>numero_secreto</span>);
</pre>

<p>Hacemos uso de la función <code>rand::thread_rng()</code> para obtener una copia del generador de numeros aleatorios, el cual es local al <a href="concurrency.html">hilo</a> de ejecucion en el cual estamos. Debido a que hemos hecho disponible a <code>rand::Rng</code> a traves de <code>use rand::Rng</code>, este tiene un metodo <code>gen_range()</code> disponible. Este metodo acepta dos argumentos, y genera un numero aleatorio entre estos. Es inclusivo en el limite inferior, pero es exclusivo en el limite superior, por eso necesitamos <code>1</code> y <code>101</code> para obtener un numero entre uno y cien.</p>

<p>La segunda linea solo imprime el numero secreto. Esto es útil mietras desarrollamos nuestro programa, de manera tal que podamos probarlo. Estaremos eliminando esta linea para la version final. No es un juego si imprime la respuesta justo cuando lo inicias!</p>

<p>Trata de ejecutar el programa unas pocas veces:</p>

<pre><code class="language-bash">$ cargo run
   Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
     Running `target/debug/adivinanzas`
Adivina el numero!
El numero secreto es: 7
Por favor introduce tu corazonada.
4
Tu corazonada fue: 4
$ cargo run
     Running `target/debug/adivinanzas`
Adivina el numero!
El numero secreto es: 83
Por favor introduce tu corazonada.
5
Tu corazonada fue: 5
</code></pre>

<p>Gradioso! A continuacion: comparemos nuestra adivinanza con el numero secreto.</p>

<h1 id="comparando-adivinanzas" class='section-header'><a
                           href="#comparando-adivinanzas">Comparando adivinanzas</a></h1>
<p>Ahora que tenemos entrada del usuario, comparemos la adivinanza con nuestro numero secreto. He aqui nuestro siguiente paso, aunque todavia no funciona completamente:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Adivina el numero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;El numero secreto es: {}&quot;, numero_secreto);

    println!(&quot;Por favor introduce tu corazonada.&quot;);

    let mut corazonada = String::new();

    io::stdin().read_line(&amp;mut corazonada)
        .ok()
        .expect(&quot;Fallo al leer linea&quot;);

    println!(&quot;Tu corazonada fue: {}&quot;, corazonada);

    match corazonada.cmp(&amp;numero_secreto) {
        Ordering::Less    =&gt; println!(&quot;Muy pequeño!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muy grande!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Haz ganado!&quot;),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adivina el numero!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>numero_secreto</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;El numero secreto es: {}&quot;</span>, <span class='ident'>numero_secreto</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Por favor introduce tu corazonada.&quot;</span>);

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>corazonada</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo al leer linea&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Tu corazonada fue: {}&quot;</span>, <span class='ident'>corazonada</span>);

    <span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>numero_secreto</span>) {
        <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy pequeño!&quot;</span>),
        <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy grande!&quot;</span>),
        <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Haz ganado!&quot;</span>),
    }
}
</pre>

<p>Algunas piezas acá. La primera es otro <code>use</code>.  Hemos hecho disponible un tipo llamado <code>std::cmp::Ordering</code>. Despues, cinco nuevas lineas al fondo que lo usan:</p>
<span class='rusttest'>fn main() {
    match corazonada.cmp(&amp;numero_secreto) {
        Ordering::Less    =&gt; println!(&quot;Muy pequeño!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muy grande!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Haz ganado!&quot;),
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>numero_secreto</span>) {
    <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy pequeño!&quot;</span>),
    <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy grande!&quot;</span>),
    <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Haz ganado!&quot;</span>),
}
</pre>

<p>El metodo <code>cmp()</code> puede ser llamado an cualquier cosa que pueda ser comparada, este toma una referencia a la cosa con la cual quieras comparar. Retorna el tipo <code>Ordering</code> que hicimos disponible anteriormente. Hemos usado una sentencia <a href="match.html"><code>match</code></a> para determinar exactamente que tipo de <code>Ordering</code> es. <code>Ordering</code> es un <a href="enums.html"><code>enum</code></a>, abreviacion para ‘enumeration’, las cuales lucen de la siguiente manera:</p>
<span class='rusttest'>fn main() {
    enum Foo {
        Bar,
        Baz,
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Bar</span>,
    <span class='ident'>Baz</span>,
}
</pre>

<p>Con esta definición, cualquier cosa de tipo <code>Foo</code> puede ser bien sea un <code>Foo::Bar</code> o un <code>Foo::Baz</code>. Usamos el <code>::</code> para indicar el espacio de nombres para una variante <code>enum</code> en particular.</p>

<p>La enum <a href="../std/cmp/enum.Ordering.html"><code>Ordering</code></a> tiene tres posibles variantes:  <code>Less</code>, <code>Equal</code>,
and <code>Greater</code> (menor, igual y mayor respectivamente). La sentencia <code>match</code> toma un valor de un tipo, y te permite crear un ‘brazo’ para cada valor posible. Debido a que tenemos tres posibles tipos de <code>Ordering</code>, tenemos tres brazos:</p>
<span class='rusttest'>fn main() {
    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Muy pequeño!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muy grande!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Haz ganado!&quot;),
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>guess</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>secret_number</span>) {
    <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy pequeño!&quot;</span>),
    <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy grande!&quot;</span>),
    <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Haz ganado!&quot;</span>),
}
</pre>

<p>Si es <code>Less</code>, imprimimos <code>Too small!</code>, si es <code>Greater</code>, <code>Too big!</code>, y si es
<code>Equal</code>, <code>Haz ganado!</code>. <code>match</code> es realmente util, y es usado con fercuencia en Rust.</p>

<p>Anteriormente mencione que todavia no funciona. Pongamoslo a prueba:</p>

<pre><code class="language-bash">$ cargo build
   Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&amp;collections::string::String`,
    found `&amp;_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match corazonada.cmp(&amp;numero_secreto) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `adivinanzas`.
</code></pre>

<p>Oops! Un gran error. Lo principal en el es que tenemos ‘tipos incompatibles’ (‘mismatched types’). Rust posee un fuerte, sistema de tipos estatico. Sin embargo, también tiene inferencia de tipos. Cuando escribimos  <code>let corazonada = String::new()</code>, Rust fue capaz de inferir que <code>corazonada</code> debia ser un <code>String</code>, y por ello no nos hizo escribir el tipo. Con nuestro <code>numero_secreto</code>, hay un numero de tipos que pueden tener un valor entre uno y cien: <code>i32</code>, un numero de treinta y dos bits, <code>u32</code>, un numero sin signo de treinta y dos bits, o <code>i64</code> un numero de sesenta y cuatro bits u otros. Hasta ahora, eso no ha importado, debido a que Rust por defecto usa <code>i32</code>. Sin embargo, en este caso, Rust no sabe como comparar <code>corazonada</code> con <code>numero_secreto</code>. Ambos necesitan ser del mismo tipo. A la final, queremos convertir el <code>String</code> que leimos como entrada en un tipo real de numero, para efectos de la comparación. Podemos hacer eso con tres lineas mas. He aqui nuestro nuevo programa:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Adivina el numero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;El numero secreto es: {}&quot;, numero_secreto);

    println!(&quot;Por favor introduce tu corazonada.&quot;);

    let mut corazonada = String::new();

    io::stdin().read_line(&amp;mut corazonada)
        .ok()
        .expect(&quot;Fallo al leer linea&quot;);

    let corazonada: u32 = corazonada.trim().parse()
        .ok()
        .expect(&quot;Por favor introduce un numero!&quot;);

    println!(&quot;Tu corazonada fue: {}&quot;, corazonada);

    match corazonada.cmp(&amp;numero_secreto) {
        Ordering::Less    =&gt; println!(&quot;Muy pequeño!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muy grande!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Haz ganado!&quot;),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adivina el numero!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>numero_secreto</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;El numero secreto es: {}&quot;</span>, <span class='ident'>numero_secreto</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Por favor introduce tu corazonada.&quot;</span>);

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>corazonada</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo al leer linea&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>corazonada</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>corazonada</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Por favor introduce un numero!&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Tu corazonada fue: {}&quot;</span>, <span class='ident'>corazonada</span>);

    <span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>numero_secreto</span>) {
        <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy pequeño!&quot;</span>),
        <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy grande!&quot;</span>),
        <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Haz ganado!&quot;</span>),
    }
}
</pre>

<p>Las tres nuevas lineas:</p>
<span class='rusttest'>fn main() {
        let corazonada: u32 = corazonada.trim().parse()
            .ok()
            .expect(&quot;Por favor introduce un numero!&quot;);
    
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>let</span> <span class='ident'>corazonada</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>corazonada</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
        .<span class='ident'>ok</span>()
        .<span class='ident'>expect</span>(<span class='string'>&quot;Por favor introduce un numero!&quot;</span>);
</pre>

<p>Espera un momento, pensé que ya teniamos una <code>corazonada</code>? La tenemos, pero
Rust nos permite sobreescribir (‘shadow’) la <code>corazonada</code> previa con una nueva.
Esto es usado con frecuencia en esta misma situación, en donde <code>corazonada</code> es un <code>String</code>, pero queremos convertirlo a un <code>u32</code>. Este shadowing nos permite reusar el nombre <code>corazonada</code> en vez de forzarnos a idear dos nombres únicos como <code>corazonada_str</code> y <code>corazonada</code>, u otros.</p>

<p>Estamos asociando <code>corazonada</code> a una expresión que luce como algo que escribimos anteriormente:</p>
<span class='rusttest'>fn main() {
    guess.trim().parse()
    
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>guess</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
</pre>

<p>Seguido por una invocación a <code>ok().expect()</code>. Aquí <code>corazonada</code> hace referencia a la vieja versión, la que era un <code>String</code> que contenía nuestra entrada de usuario en ella. El metodo <code>trim()</code> en los <code>String</code>s elimina cualquier espacio en blanco al principio y al final de nuestras cadenas de caracteres. Esto es importante, debido a que tuvimos que presionar la tecla ‘retorno’ para satisfacer a <code>read_line()</code>. Esto significa que si escribimos <code>5</code> y presionamos ‘retorno’ <code>corazonada</code> luce como así: <code>5\n</code>. El <code>\n</code> representa ‘nueva linea’ (‘newline’), la tecla enter. <code>trim()</code> se deshace de esto, dejando nuestra cadena de caracteres solo con el <code>5</code>. El <a href="../std/primitive.str.html#method.parse">metodo <code>parse()</code> en las cadenas caracteres</a> parsea una cadena de caracteres en algún tipo de numero. Debido a que puede parsear una variedad de numeros, debemos darle a Rust una pista del tipo exacto de numero que deseamos. De ahí la parte <code>let corazonada: u32</code>. Los dos puntos (<code>:</code>)  despues de <code>corazonada</code> le dicen a Rust que vamos a anotar el tipo. <code>u32</code> es un entero sin signo de treinta y dos bits. Rust posee <a href="primitive-types.html#numeric-types">una variedad de tipos numero integrados</a>, pero nosotros hemos escojido <code>u32</code>.  Es una buena opción por defecto para un numero positivo pequeño.</p>

<p>Al igual que <code>read_line()</code>, nuestra llamada a <code>parse()</code> podria causar un error. Que tal si nuestra cadena de caracteres contiene <code>Aߑ���?</code> No habría  forma de convertir eso en un numero. Es por ello que haremos lo mismo que hicimos con <code>read_line()</code>: usar los metodos <code>ok()</code> y <code>expect()</code> para terminar abruptamente si hay algun error.</p>

<p>Probemos nuestro programa!</p>

<pre><code class="language-bash">$ cargo run
   Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
     Running `target/adivinanzas`
Adivina el numero!
El numero secreto es: 58
Por favor introduce tu corazonada.
  76
Tu corazonada fue: 76
Muy grande!
</code></pre>

<p>Excelente! Puedes ver que incluso he agregado espacios antes de mi intento, y aun así el programa determino que intente 76. Ejecuta el programa unas pocas veces, y verifica que adivinar el numero funciona, asi como intentar un numero muy pequeno.</p>

<p>Ahora tenemos la mayoria del juego funcionando, pero solo podemos intentar adivinar una vez. Tratemos de cambiar eso agregando ciclos!</p>

<h1 id="iteración" class='section-header'><a
                           href="#iteración">Iteración</a></h1>
<p>La palabra clave <code>loop</code> nos proporciona un ciclo infinito. Agreguemosla:</p>

<p>Adivina el numero!
El numero secreto es: 58
Por favor introduce tu adivinanza.
  76
Tu corazonada fue: 76
Muy grande!</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Adivina el numero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;El numero secreto es: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Por favor introduce tu corazonada.&quot;);

        let mut corazonada = String::new();

        io::stdin().read_line(&amp;mut corazonada)
            .ok()
            .expect(&quot;Fallo al leer linea&quot;);

        let corazonada: u32 = corazonada.trim().parse()
            .ok()
            .expect(&quot;Por favor introduce un numero!&quot;);

        println!(&quot;Haz corazonada: {}&quot;, corazonada);

        match corazonada.cmp(&amp;numero_secreto) {
            Ordering::Less    =&gt; println!(&quot;Muy pequeño!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muy grande!&quot;),
            Ordering::Equal   =&gt; println!(&quot;Haz ganado!&quot;),
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adivina el numero!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>numero_secreto</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;El numero secreto es: {}&quot;</span>, <span class='ident'>numero_secreto</span>);

    <span class='kw'>loop</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Por favor introduce tu corazonada.&quot;</span>);

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>corazonada</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

        <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo al leer linea&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>corazonada</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>corazonada</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;Por favor introduce un numero!&quot;</span>);

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Haz corazonada: {}&quot;</span>, <span class='ident'>corazonada</span>);

        <span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>numero_secreto</span>) {
            <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy pequeño!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy grande!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Haz ganado!&quot;</span>),
        }
    }
}
</pre>

<p>Pruebalo. Pero espera, no acabamos de agregar un ciclo infinito? Sip. Recuerdas nuestra discusión acerca de <code>parse()</code>? Si damos una respuesta no numérica, retornaremos (<code>return</code>) y finalizaremos la ejecución. Observa:</p>

<pre><code class="language-bash">$ cargo run
   Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
     Running `target/adivinanzas`
Adivina el numero!
El numero secreto es: 59
Por favor introduce tu corazonada.
45
Tu corazonada fue: 45
Muy pequeño!
Por favor introduce tu corazonada.
60
Tu corazonada fue: 60
Muy grande!
Por favor introduce tu corazonada.
59
Tu corazonada fue: 59
Haz ganado!
Por favor introduce tu corazonada.
quit
thread &#39;&lt;main&gt;&#39; panicked at &#39;Please type a number!&#39;
</code></pre>

<p>Ja! <code>quit</code> en efecto termina la ejecución. Asi como cualquier otra entrada que no sea un numero. Bueno, esto es suboptimo por decir lo menos. Primero salgamos cuando ganemos:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Adivina el numero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;El numero secreto es: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Por favor introduce tu corazonada.&quot;);

        let mut corazonada = String::new();

        io::stdin().read_line(&amp;mut corazonada)
            .ok()
            .expect(&quot;Fallo al leer linea&quot;);

        let corazonada: u32 = corazonada.trim().parse()
            .ok()
            .expect(&quot;Por favor introduce un numero!&quot;);

        println!(&quot;Tu corazonada fue: {}&quot;, corazonada);

        match corazonada.cmp(&amp;numero_secreto) {
            Ordering::Less    =&gt; println!(&quot;Muy pequeño!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muy grande!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Haz ganado!&quot;);
                break;
            }
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adivina el numero!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>numero_secreto</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;El numero secreto es: {}&quot;</span>, <span class='ident'>numero_secreto</span>);

    <span class='kw'>loop</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Por favor introduce tu corazonada.&quot;</span>);

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>corazonada</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

        <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo al leer linea&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>corazonada</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>corazonada</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>()
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;Por favor introduce un numero!&quot;</span>);

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Tu corazonada fue: {}&quot;</span>, <span class='ident'>corazonada</span>);

        <span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>numero_secreto</span>) {
            <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy pequeño!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy grande!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Haz ganado!&quot;</span>);
                <span class='kw'>break</span>;
            }
        }
    }
}
</pre>

<p>Al agregar la linea <code>break</code> despues del &quot;Haz ganado!&quot;, romperemos el ciclo cuando ganemos. Salir del ciclo también significa salir del programa, debido a que es la ultima cosa en <code>main()</code>. Solo nos queda una sola mejora por hacer: cuando alguien introduzca un valor no numérico, no queremos terminar la ejecución, queremos simplemente ignorarlo. Podemos hacerlo de la siguiente manera:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Adivina el numero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;El numero secreto es: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Por favor introduce tu corazonada.&quot;);

        let mut corazonada = String::new();

        io::stdin().read_line(&amp;mut corazonada)
            .ok()
            .expect(&quot;Fallo al leer linea&quot;);

        let corazonada: u32 = match corazonada.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Tu corazonada fue: {}&quot;, corazonada);

        match corazonada.cmp(&amp;numero_secreto) {
            Ordering::Less    =&gt; println!(&quot;Muy pequeño!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muy grande!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Haz ganado!&quot;);
                break;
            }
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adivina el numero!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>numero_secreto</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;El numero secreto es: {}&quot;</span>, <span class='ident'>numero_secreto</span>);

    <span class='kw'>loop</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Por favor introduce tu corazonada.&quot;</span>);

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>corazonada</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

        <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo al leer linea&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>corazonada</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>() {
            <span class='prelude-val'>Ok</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
            <span class='prelude-val'>Err</span>(_) <span class='op'>=&gt;</span> <span class='kw'>continue</span>,
        };

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Tu corazonada fue: {}&quot;</span>, <span class='ident'>corazonada</span>);

        <span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>numero_secreto</span>) {
            <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy pequeño!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy grande!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Haz ganado!&quot;</span>);
                <span class='kw'>break</span>;
            }
        }
    }
}
</pre>

<p>Estas son las lineas que han cambiado:</p>
<span class='rusttest'>fn main() {
    let corazonada: u32 = match corazonada.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>corazonada</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>() {
    <span class='prelude-val'>Ok</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
    <span class='prelude-val'>Err</span>(_) <span class='op'>=&gt;</span> <span class='kw'>continue</span>,
};
</pre>

<p>Es asi como pasamos de ‘terminar abruptamente en un error’ a ‘efectivamente manejar el error’, a través del cambio de <code>ok().expect()</code> a una sentencia <code>match</code>. El <code>Result</code> retornado por <code>parse()</code> es un enum justo como <code>Ordering</code>, pero en este caso cada variante tiene data asociada: <code>Ok</code> es exito, y <code>Err</code> es una falla. Cada uno contiene mas información: el entero parseado en el caso exitoso, o un tipo de error. En este caso hacemos <code>match</code> en<code>Ok(num)</code>, el cual asigna el valor interno del <code>Ok</code> a el nombre <code>num</code>, y seguidamente retorna en el lado derecho. En el caso de <code>Err</code>, no nos importa que tipo de error es, es por ello que usamos <code>_</code> en lugar de un nombre. Esto ignora el error y <code>continue</code> nos mueve a la siguiente iteración del ciclo (<code>loop</code>).</p>

<p>Ahora deberiamos estar bien! Probemos:</p>

<pre><code class="language-bash">$ cargo run
   Compiling adivinanzas v0.1.0 (file:///home/tu/proyectos/adivinanzas)
     Running `target/adivinanzas`
Adivina el numero!
El numero secreto es: 61
Por favor introduce tu corazonada.
10
Tu corazonada fue: 10
Muy pequeño!
Por favor introduce tu corazonada.
99
Tu corazonada fue: 99
Muy pequeño!
Por favor introduce tu corazonada.
foo
Por favor introduce tu corazonada.
61
Tu corazonada fue: 61
Haz ganado!
</code></pre>

<p>Genial! Con una ultima mejora, finalizamos el juego de las advinanzas. Te imaginas cual es? Es correcto, no queremos imprimir el numero secreto. Era bueno para las pruebas, pero arruina nuestro juego. He aqui nuestro código fuente final:</p>
<span class='rusttest'>extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Adivina el numero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Por favor introduce tu corazonada.&quot;);

        let mut corazonada = String::new();

        io::stdin().read_line(&amp;mut corazonada)
            .ok()
            .expect(&quot;Fallo al leer linea&quot;);

        let corazonada: u32 = match corazonada.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Tu corazonada fue: {}&quot;, corazonada);

        match corazonada.cmp(&amp;numero_secreto) {
            Ordering::Less    =&gt; println!(&quot;Muy pequeño!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muy grande!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Haz ganado!&quot;);
                break;
            }
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Adivina el numero!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>numero_secreto</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>thread_rng</span>().<span class='ident'>gen_range</span>(<span class='number'>1</span>, <span class='number'>101</span>);

    <span class='kw'>loop</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Por favor introduce tu corazonada.&quot;</span>);

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>corazonada</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

        <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>corazonada</span>)
            .<span class='ident'>ok</span>()
            .<span class='ident'>expect</span>(<span class='string'>&quot;Fallo al leer linea&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>corazonada</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>() {
            <span class='prelude-val'>Ok</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
            <span class='prelude-val'>Err</span>(_) <span class='op'>=&gt;</span> <span class='kw'>continue</span>,
        };

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Tu corazonada fue: {}&quot;</span>, <span class='ident'>corazonada</span>);

        <span class='kw'>match</span> <span class='ident'>corazonada</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>numero_secreto</span>) {
            <span class='ident'>Ordering</span>::<span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy pequeño!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Muy grande!&quot;</span>),
            <span class='ident'>Ordering</span>::<span class='ident'>Equal</span>   <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Haz ganado!&quot;</span>);
                <span class='kw'>break</span>;
            }
        }
    }
}
</pre>

<h1 id="completado!" class='section-header'><a
                           href="#completado!">Completado!</a></h1>
<p>En este punto, has terminado satisfactoriamente el juego de las adivinanza! Felicitaciones!</p>

<p>Este primer proyecto te enseno un montón: <code>let</code>, <code>match</code>, metodos, funciones asociadas, usar crates externos, y mas. Nuestro siguiente proyecto demostrara aun mas.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
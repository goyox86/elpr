<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Cadenas de Caracteres</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Monticulo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribucion</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Prestamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Metodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a class='active' href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genericos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Modulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversion entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamano</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Inverstigacion Academica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Cadenas de Caracteres</h1>
    <p>Las cadenas de caracteres son un concepto importante a dominar para cualquier programador. El sistema de manejo de cadenas de caracteres en Rust es un poco distinto al de otros lenguajes, debido a su foco en programación de sistemas. Siempre que poseas una estructura de datos de tamaño variable, las cosas pueden ponerse un poco difíciles, y las cadenas de caracteres son una estructura de datos que puede variar en tamaño. Dicho esto, las cadenas de caracteres de Rust también funcionan de manera diferente que en algunos otros lenguajes de programación de sistemas, como C.</p>

<p>Entremos en los detalles. Una ‘cadena de caracteres’ (‘string’) es una secuencia de valores escalares Unicode codificada como un flujo de bytes UTF-8. Todas las cadenas de caracteres están garantizadas a ser una codificación valida de secuencias UTF-8. Adicionalmente, y a diferencia de otros lenguajes de sistemas, las cadenas de caracteres no son terminadas en null y pueden contener bytes null.</p>

<p>Rust posee dos tipos principales de cadenas de caracteres: <code>&amp;str</code> y <code>String</code>. Hablemos primero acerca de <code>&amp;str</code>. Estos son denominados ‘pedazos de cadenas de caracteres’ (‘string slices’). Los literales String son del tipo &amp;&#39;static str`:</p>
<span class='rusttest'>fn main() {
    let saludo = &quot;Hola.&quot;; // saludo: &amp;&#39;static str
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>saludo</span> <span class='op'>=</span> <span class='string'>&quot;Hola.&quot;</span>; <span class='comment'>// saludo: &amp;&#39;static str</span></pre>

<p>Esta cadena de caracteres es asignada estáticamente, significando que es almacenada dentro de nuestro programa compilado, y existe por la duración completa de su ejecución. El enlace <code>saludo</code> es una referencia a una cadena asignada estéticamente. Los pedazos de cadenas de caracteres poseen un tamaño fijo, y no pueden ser mutados.</p>

<p>Por otro lado, un <code>String</code>, es una cadena de caracteres asignada desde el montículo. Dicha cadena puede crecer, y también esta garantizada ser UTF-8. Los <code>String</code> son creados comúnmente a través de la conversión de un pedazo de cadena de carácter usando el método <code>to_string</code>.</p>
<span class='rusttest'>fn main() {
    let mut s = &quot;Hola&quot;.to_string(); // mut s: String
    println!(&quot;{}&quot;, s);
    
    s.push_str(&quot;, mundo.&quot;);
    println!(&quot;{}&quot;, s);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hola&quot;</span>.<span class='ident'>to_string</span>(); <span class='comment'>// mut s: String</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);

<span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;, mundo.&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);</pre>

<p>Los <code>String</code>s haran coercion a un <code>&amp;str</code> con un <code>&amp;</code>:</p>
<span class='rusttest'>fn recibe_pedazo(pedazo: &amp;str) {
    println!(&quot;Recibí: {}&quot;, pedazo);
}

fn main() {
    let s = &quot;Hola&quot;.to_string();
    recibe_pedazo(&amp;s);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>recibe_pedazo</span>(<span class='ident'>pedazo</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Recibí: {}&quot;</span>, <span class='ident'>pedazo</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hola&quot;</span>.<span class='ident'>to_string</span>();
    <span class='ident'>recibe_pedazo</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>);
}</pre>

<p>Esta coerción no ocurre para las funciones que aceptan uno de los traits <code>&amp;str</code>’s en lugar de <code>&amp;str</code>. Por ejemplo, <a href="../std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a> posee un parámetro de tipo <code>ToSocketAddrs</code>. Un <code>&amp;str</code> esta bien pero un <code>String</code> debe ser explícitamente convertido usando <code>&amp;*</code>.</p>
<span class='rusttest'>fn main() {
    use std::net::TcpStream;
    
    TcpStream::connect(&quot;192.168.0.1:3000&quot;); // parametro &amp;str
    
    let cadena_direccion = &quot;192.168.0.1:3000&quot;.to_string();
    TcpStream::connect(&amp;*cadena_direccion); // convirtiendo cadena_direccion a &amp;str
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>net</span>::<span class='ident'>TcpStream</span>;

<span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='string'>&quot;192.168.0.1:3000&quot;</span>); <span class='comment'>// parametro &amp;str</span>

<span class='kw'>let</span> <span class='ident'>cadena_direccion</span> <span class='op'>=</span> <span class='string'>&quot;192.168.0.1:3000&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>cadena_direccion</span>); <span class='comment'>// convirtiendo cadena_direccion a &amp;str</span></pre>

<p>Ver un <code>String</code> como un <code>&amp;str</code> es barato, pero convertir el <code>&amp;str</code> a un <code>String</code> involucra asignación de memoria. No hay razón para hacer eso a menos que sea necesario!</p>

<h2 id="indexado" class='section-header'><a
                           href="#indexado">Indexado</a></h2>
<p>Debido a que las cadenas de caracteres son UTF-8 validos, no soportan indexado:</p>
<span class='rusttest'>fn main() {
    let s = &quot;hola&quot;;
    
    println!(&quot;La primera letra de s es {}&quot;, s[0]); // ERROR!!!
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;hola&quot;</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;La primera letra de s es {}&quot;</span>, <span class='ident'>s</span>[<span class='number'>0</span>]); <span class='comment'>// ERROR!!!</span></pre>

<p>Usualmente, el acceso a un vector con <code>[]</code> es muy rápido. Pero, puesto a que cada carácter codificado en una cadena UTF-8 puede tener multiples bytes, debes recorrer toda la cadena para encontrar la nᵗʰ letra de una cadena. Esta es una operación significativamente mas cara, y no queremos generar confusiones. Incluso, ‘letra’ no es exactamente algo definido en Unicode. Podemos escoger ver a una cadena de caracteres como bytes individuales, o como codepoints:</p>
<span class='rusttest'>fn main() {
    let hachiko = &quot;忠犬ハチ公&quot;;
    
    for b in hachiko.as_bytes() {
        print!(&quot;{}, &quot;, b);
    }
    
    println!(&quot;&quot;);
    
    for c in hachiko.chars() {
        print!(&quot;{}, &quot;, c);
    }
    
    println!(&quot;&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hachiko</span> <span class='op'>=</span> <span class='string'>&quot;忠犬ハチ公&quot;</span>;

<span class='kw'>for</span> <span class='ident'>b</span> <span class='kw'>in</span> <span class='ident'>hachiko</span>.<span class='ident'>as_bytes</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}, &quot;</span>, <span class='ident'>b</span>);
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;&quot;</span>);

<span class='kw'>for</span> <span class='ident'>c</span> <span class='kw'>in</span> <span class='ident'>hachiko</span>.<span class='ident'>chars</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}, &quot;</span>, <span class='ident'>c</span>);
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;&quot;</span>);</pre>

<p>Lo anterior imprime:</p>

<pre><code class="language-text">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,
忠, 犬, ハ, チ, 公,
</code></pre>

<p>Como puedes ver, hay mas bytes que caracteres (<code>char</code>s).</p>

<p>Puedes obtener algo similar a un indice de esta forma:</p>
<span class='rusttest'>fn main() {
    let hachiko = &quot;忠犬ハチ公&quot;;
    let perro = hachiko.chars().nth(1); // algo como hachiko[1]
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>perro</span> <span class='op'>=</span> <span class='ident'>hachiko</span>.<span class='ident'>chars</span>().<span class='ident'>nth</span>(<span class='number'>1</span>); <span class='comment'>// algo como hachiko[1]</span></pre>

<p>Esto enfatiza que tenemos que caminar desde el principio de la lista de <code>chars</code>.</p>

<h2 id="cortado-(slicing)" class='section-header'><a
                           href="#cortado-(slicing)">Cortado (Slicing)</a></h2>
<p>Puedes obtener un pedazo de una cadena de caracteres con la sintaxis de cortado:</p>
<span class='rusttest'>fn main() {
    let perro = &quot;hachiko&quot;;
    let hachi = &amp;perro[0..5];
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>perro</span> <span class='op'>=</span> <span class='string'>&quot;hachiko&quot;</span>;
<span class='kw'>let</span> <span class='ident'>hachi</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>perro</span>[<span class='number'>0</span>..<span class='number'>5</span>];</pre>

<p>Pero nota que estos son desplazamientos de <em>byte</em>, no desplazamientos de <em>character</em>. Entonces, lo siguiente fallara en tiempo de ejecución:</p>
<span class='rusttest'>fn main() {
    let perro = &quot;忠犬ハチ公&quot;;
    let hachi = &amp;perro[0..2];
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>perro</span> <span class='op'>=</span> <span class='string'>&quot;忠犬ハチ公&quot;</span>;
<span class='kw'>let</span> <span class='ident'>hachi</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>perro</span>[<span class='number'>0</span>..<span class='number'>2</span>];</pre>

<p>con este error:</p>

<pre><code class="language-text">thread &#39;&lt;main&gt;&#39; panicked at &#39;index 0 and/or 2 in `忠犬ハチ公` do not lie on
character boundary&#39;
</code></pre>

<h2 id="concatenación" class='section-header'><a
                           href="#concatenación">Concatenación</a></h2>
<p>Si posees un <code>String</code>, puedes concatenarle un <code>&amp;str</code> al final:</p>
<span class='rusttest'>fn main() {
    let hola = &quot;Hola &quot;.to_string();
    let mundo = &quot;mundo!&quot;;
    
    let hola_mundo = hola + mundo;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hola</span> <span class='op'>=</span> <span class='string'>&quot;Hola &quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>mundo</span> <span class='op'>=</span> <span class='string'>&quot;mundo!&quot;</span>;

<span class='kw'>let</span> <span class='ident'>hola_mundo</span> <span class='op'>=</span> <span class='ident'>hola</span> <span class='op'>+</span> <span class='ident'>mundo</span>;</pre>

<p>Pero si tienes dos <code>String</code>s, necesitas un <code>&amp;</code>:</p>
<span class='rusttest'>fn main() {
    let hola = &quot;Hola &quot;.to_string();
    let mundo = &quot;mundo!&quot;.to_string();
    
    let hola_mundo = hola + &amp;world;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hola</span> <span class='op'>=</span> <span class='string'>&quot;Hola &quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>mundo</span> <span class='op'>=</span> <span class='string'>&quot;mundo!&quot;</span>.<span class='ident'>to_string</span>();

<span class='kw'>let</span> <span class='ident'>hola_mundo</span> <span class='op'>=</span> <span class='ident'>hola</span> <span class='op'>+</span> <span class='kw-2'>&amp;</span><span class='ident'>world</span>;</pre>

<p>Esto es porque <code>&amp;String</code> puede hacer coercion automática a un <code>&amp;str</code>. Esta característica es denominada ‘<a href="deref-coercions.html">coerciones <code>Deref</code></a>’.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
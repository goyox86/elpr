<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Tipos Primitivos</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¬°Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¬°Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Fil√≥sofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Mont√≠culo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilaci√≥n Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentaci√≥n</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribuci√≥n</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a class='active' href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Pr√©stamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de M√©todos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Gen√©ricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y M√≥dulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversi√≥n entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tama√±o</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intr√≠nsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigaci√≥n Acad√©mica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Tipos Primitivos</h1>
    <p>Rust posee un conjunto de tipos que son considerados ‚Äòprimitivos‚Äô. Esto significa que est√°n integrados en el lenguaje. Rust esta estructurado de tal manera que la biblioteca est√°ndar tambi√©n provee una numero de tipos √∫tiles basados en los primitivos, pero estos son los mas primitivos.</p>

<h1 id='booleanos' class='section-header'><a href='#booleanos'>Booleanos</a></h1>
<p>Rust posee un tipo booleano integrado, denominado <code>bool</code>. Tiene dos posibles valores  <code>true</code> y <code>false</code>:</p>
<span class='rusttest'>fn main() {
    let x = true;
    
    let y: bool = false;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='boolval'>true</span>;

<span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>bool</span> <span class='op'>=</span> <span class='boolval'>false</span>;</pre>

<p>Un uso com√∫n de los booleanos es en <a href="if.html">condicionales <code>if</code></a>.</p>

<p>Puedes encontrar mas documentaci√≥n para los <code>bool</code>eanos <a href="../std/primitive.bool.html">en la documentaci√≥n de la biblioteca est√°ndar</a> (ingles).</p>

<h1 id='char' class='section-header'><a href='#char'><code>char</code></a></h1>
<p>El tipo <code>char</code> representa un unico valor escalar Unicode. Puedes crear <code>char</code>s con comillas simples: (<code>&#39;</code>)</p>
<span class='rusttest'>fn main() {
    let x = &#39;x&#39;;
    let dos_corazones = &#39;üíï&#39;;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&#39;x&#39;</span>;
<span class='kw'>let</span> <span class='ident'>dos_corazones</span> <span class='op'>=</span> <span class='string'>&#39;üíï&#39;</span>;</pre>

<p>A diferencia de otros lenguajes, esto significa que <code>char</code> en Rust no es un solo byte, sino cuatro.</p>

<p>Puedes encontrar mas documentaci√≥n para los <code>char</code>s <a href="../std/primitive.char.html">en la documentaci√≥n de la biblioteca est√°ndar</a> (ingles).</p>

<h1 id='tipos-num√©ricos' class='section-header'><a href='#tipos-num√©ricos'>Tipos num√©ricos</a></h1>
<p>Rust posee una variedad de tipos num√©ricos en unas pocas categor√≠as: con signo y sin signo, fijos y variables, de punto flotante y enteros.</p>

<p>Dichos tipos consisten de dos partes: la categor√≠a, y el tama√±o. Por ejemplo, <code>u16</code> es un tipo sin signo con un tama√±o de diecis√©is bits. Mas bits te permiten almacenar n√∫meros mas grandes.</p>

<p>Si un literal de numero no posee nada que cause la inferencia de su tipo, se usan tipos por defecto:</p>
<span class='rusttest'>fn main() {
    let x = 42; // x tiene el tipo i32
    
    let y = 1.0; // y tiene el tipo f64
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>42</span>; <span class='comment'>// x tiene el tipo i32</span>

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>1.0</span>; <span class='comment'>// y tiene el tipo f64</span></pre>

<p>He aqu√≠ una lista de los diferentes tipos num√©ricos, con enlaces a su documentaci√≥n en la biblioteca est√°ndar (ingles):</p>

<ul>
<li><a href="../std/primitive.i8.html">i8</a></li>
<li><a href="../std/primitive.i16.html">i16</a></li>
<li><a href="../std/primitive.i32.html">i32</a></li>
<li><a href="../std/primitive.i64.html">i64</a></li>
<li><a href="../std/primitive.u8.html">u8</a></li>
<li><a href="../std/primitive.u16.html">u16</a></li>
<li><a href="../std/primitive.u32.html">u32</a></li>
<li><a href="../std/primitive.u64.html">u64</a></li>
<li><a href="../std/primitive.isize.html">isize</a></li>
<li><a href="../std/primitive.usize.html">usize</a></li>
<li><a href="../std/primitive.f32.html">f32</a></li>
<li><a href="../std/primitive.f64.html">f64</a></li>
</ul>

<p>Veamos cada una de las diferentes categor√≠as.</p>

<h2 id='con-signo-y-sin-signo' class='section-header'><a href='#con-signo-y-sin-signo'>Con signo y sin signo</a></h2>
<p>Los tipos de enteros vienen en dos variedades: con signo y sin signo. Para entender la diferencia, consideremos un numero con cuatro bits de tama√±o. Un numero de cuatro bits con signo te permitir√≠a almacenar los n√∫meros desde <code>-8</code> a <code>+7</code>. Los n√∫meros con signo usan la ‚Äúrepresentaci√≥n del complemento a dos‚Äù. Un numero de cuatros bits sin signo, debido a que no necesita guardar los valores negativos, puede almacenar valores desde <code>0</code> hasta <code>+15</code>.</p>

<p>Los tipos sin signo usan una <code>u</code> para su categoria, y los tipos con signo usan <code>i</code>. La <code>i</code> es de <code>integer</code> (entero). Entonces, <code>u8</code> es un numero de ocho bits sin signo, y un <code>i8</code> es un numero de ocho bits con signo.</p>

<h2 id='tipos-de-tama√±o-fijo' class='section-header'><a href='#tipos-de-tama√±o-fijo'>Tipos de tama√±o fijo</a></h2>
<p>Los tipos de tama√±o fijo poseen un numero especifico de bits en su representaci√≥n. Los tama√±os validos son <code>8</code>, <code>16</code>, <code>32</code>, and <code>64</code>. Entonces <code>u32</code> es un entero sin signo de 32 bits, e <code>i64</code> es un entero con signo de 64 bits.</p>

<h2 id='tipos-de-tama√±o-variable' class='section-header'><a href='#tipos-de-tama√±o-variable'>Tipos de tama√±o variable</a></h2>
<p>Rust tambi√©n provee tipos para los cuales el tama√±o depende del tama√±o del apuntador en la maquina subyacente. Dichos tipos poseen la categor√≠a ‚Äòsize‚Äô, y vienen en variantes con y sin signo. Esto resulta en dos tipos <code>isize</code> y <code>usize</code>.</p>

<h2 id='tipos-de-punto-flotante' class='section-header'><a href='#tipos-de-punto-flotante'>Tipos de punto flotante</a></h2>
<p>Rust tambi√©n posee dos tipos de punto flotante: <code>f32</code> y <code>f64</code>. Estos corresponden a los n√∫meros IEEE-754 de simple y doble precision.</p>

<h1 id='arreglos' class='section-header'><a href='#arreglos'>Arreglos</a></h1>
<p>Como muchos lenguajes de programaci√≥n, Rust posee tipos lista para representar una secuencia de cosas. El mas b√°sico es el <em>arreglo</em>, una lista de elementos del mismo tipo y de tama√±o fijo. Por defecto los arreglos son inmutables.</p>
<span class='rusttest'>fn main() {
    let a = [1, 2, 3]; // a: [i32; 3]
    let mut m = [1, 2, 3]; // m: [i32; 3]
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]; <span class='comment'>// a: [i32; 3]</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>m</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]; <span class='comment'>// m: [i32; 3]</span></pre>

<p>Los arreglos tienen el tipo <code>[T; N]</code>.  Hablaremos de la notaci√≥n <code>T</code> <a href="generics.html">en la secci√≥n de gen√©ricos</a>. La <code>N</code> es una constante en tiempo de compilaci√≥n, para la longitud del arreglo.</p>

<p>Hay un atajo para la inicializaci√≥n de cada uno de los elementos del arreglo a el mismo valor. En este ejemplo, cada elemento de <code>a</code> sera inicializado a <code>0</code>:</p>
<span class='rusttest'>fn main() {
    let a = [0; 20]; // a: [i32; 20]
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>; <span class='number'>20</span>]; <span class='comment'>// a: [i32; 20]</span></pre>

<p>Puedes obtener el numero de elementos del arreglo <code>a</code> con <code>a.len()</code></p>
<span class='rusttest'>fn main() {
    let a = [1, 2, 3];
    
    println!(&quot;a tiene {} elementos&quot;, a.len());
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;a tiene {} elementos&quot;</span>, <span class='ident'>a</span>.<span class='ident'>len</span>());</pre>

<p>Puedes acceder un elemento del arreglo en particular con la <em>notaci√≥n de subindices</em>:</p>
<span class='rusttest'>fn main() {
    let nombres = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // names: [&amp;str; 3]
    
    println!(&quot;El segundo nombre es: {}&quot;, nombres[1]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nombres</span> <span class='op'>=</span> [<span class='string'>&quot;Graydon&quot;</span>, <span class='string'>&quot;Brian&quot;</span>, <span class='string'>&quot;Niko&quot;</span>]; <span class='comment'>// names: [&amp;str; 3]</span>

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;El segundo nombre es: {}&quot;</span>, <span class='ident'>nombres</span>[<span class='number'>1</span>]);</pre>

<p>Los subindices comienzan en cero, como en la mayor√≠a de los lenguajes de programaci√≥n, entonces el primer nombre es <code>nombres[0]</code> y es segundo es <code>nombres[1]</code>. El ejemplo anterior imprime: <code>El segundo nombre es: Brian</code>. Si intentas usar un sub√≠ndice que no esta en el arreglo, obtendr√°s un error: el chequeo de los limites en el acceso al arreglo se realiza en tiempo de ejecuci√≥n. El acceso errante como ese es la fuente de muchos bugs en los lenguajes de programaci√≥n de sistemas.</p>

<p>Puedes encontrar mas documentaci√≥n para los <code>array</code>s <a href="../std/primitive.array.html">en la documentaci√≥n de la biblioteca est√°ndar</a> (ingles).</p>

<h1 id='slices' class='section-header'><a href='#slices'>Slices</a></h1>
<p>Un slice es una referencia a (o una ‚Äúvista‚Äù dentro de) otra estructura de datos. Los slices son √∫tiles para permitir acceso seguro y eficiente a una porci√≥n de un arreglo sin involucrar el copiado. Por ejemplo, podr√≠as querer hacer referencia a una sola linea de una archivo que ha sido previamente le√≠do en memoria. Por naturaleza, un slice no es creado directamente, estos son creados para una variable que ya existe. Los slices poseen una longitud, pueden ser mutables o inmutables, y en muchas formas se comportan como los arreglos:</p>
<span class='rusttest'>fn main() {
    let a = [0, 1, 2, 3, 4];
    let middle = &amp;a[1..4]; // Un slice de a: solo los elementos 1, 2, y 3
    let complete = &amp;a[..]; // Un slice conteniendo todos los elementos de a.
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>let</span> <span class='ident'>middle</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>a</span>[<span class='number'>1</span>..<span class='number'>4</span>]; <span class='comment'>// Un slice de a: solo los elementos 1, 2, y 3</span>
<span class='kw'>let</span> <span class='ident'>complete</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>a</span>[..]; <span class='comment'>// Un slice conteniendo todos los elementos de a.</span></pre>

<p>Los slices poseen el tipo <code>&amp;[T]</code>. Hablaremos acerca de <code>T</code> cuando cubramos <a href="generics.html">los genericos</a>.</p>

<p>Puedes encontrar mas documentaci√≥n para los slices <a href="../std/primitive.slice.html">en la documentaci√≥n de la biblioteca est√°ndar</a> (ingles)</p>

<h1 id='str' class='section-header'><a href='#str'><code>str</code></a></h1>
<p>El <code>str</code> de Rust es el tipo de cadena de caracteres mas primitivo. Como un <a href="unsized-types.html">tipo sin tama√±o</a>, y no es muy util en si mismo, pero se vuelve muy util cuando es puesto detr√°s de una referencia, como <a href="strings.html"><code>&amp;str</code></a>. Es por ello que lo dejaremos hasta aqu√≠.</p>

<p>Puedes encontrar mas documentaci√≥n para str <a href="../std/primitive.str.html">en la documentaci√≥n de la biblioteca est√°ndar</a> (ingles)</p>

<h1 id='tuplas' class='section-header'><a href='#tuplas'>Tuplas</a></h1>
<p>Una tupla es una lista ordenada de tama√±o fijo. Como esto:</p>
<span class='rusttest'>fn main() {
    let x = (1, &quot;hola&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hola&quot;</span>);</pre>

<p>Los par√©ntesis y comas forman esta tupla de longitud dos. He aqu√≠ el mismo c√≥digo pero con anotaciones de tipo:</p>
<span class='rusttest'>fn main() {
    let x: (i32, &amp;str) = (1, &quot;hola&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: (<span class='ident'>i32</span>, <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hola&quot;</span>);</pre>

<p>Como puedes ver, el tipo de una tupla es justo como la tupla, pero con cada posici√≥n teniendo el tipo en lugar del valor. Los lectores cuidadosos tambi√©n notaran que las tuplas son heterog√©neas: tenemos un <code>i32</code> y a <code>&amp;str</code> en esta tupla. En los lenguajes de programaci√≥n de sistemas, las cadenas de caracteres son un poco mas complejas que en otros lenguajes. Por ahora solo lee <code>&amp;str</code> como un <em>slice de cadena de caracteres</em>. Aprenderemos mas dentro de poco.</p>

<p>Puedes asignar una tupla a otra, si estas tienen los mismo tipos contenidos y la misma <a href="glossary.html#arity">aridad</a>. La tuples poseen la misma aridad cuando estas tienen el mismo tama√±o.</p>
<span class='rusttest'>fn main() {
    let mut x = (1, 2); // x: (i32, i32)
    let y = (2, 3); // y: (i32, i32)
    
    x = y;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>); <span class='comment'>// x: (i32, i32)</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>3</span>); <span class='comment'>// y: (i32, i32)</span>

<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>y</span>;</pre>

<p>Puedes acceder a los campos de una tupla a trav√©s de un <em>let con destructuracion</em>. He aqu√≠ un ejemplo:</p>
<span class='rusttest'>fn main() {
    let (x, y, z) = (1, 2, 3);
    
    println!(&quot;x es {}&quot;, x);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>, <span class='ident'>z</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x es {}&quot;</span>, <span class='ident'>x</span>);</pre>

<p>Recuerdas <a href="variable-bindings.html">anteriormente</a> cuando dije que el lado izquierdo de una sentencia <code>let</code> era mas poderoso que la simple asignaci√≥n de un binding? Henos aqu√≠. Podemos colocar un patron en el lado izquierdo de un <code>let</code>, y si este concuerda con el lado derecho, podemos asignar multiples bindings a variable de una sola vez. En este caso, el <code>let</code> ‚Äúdestructura‚Äù o ‚Äúparte‚Äù la tupla, y asigna las partes a los tres bindings a variable.</p>

<p>Este patron es muy poderoso, y lo veremos repetido con frecuencia en el futuro.</p>

<p>Puedes eliminar la ambig√ºedad entre una tupla de un solo elemento y un valor encerrado en par√©ntesis usando una coma:</p>
<span class='rusttest'>fn main() {
    (0,); // tupla de un solo elemento
    (0); // cero encerrado en parentesis
    
}</span><pre class='rust rust-example-rendered'>
(<span class='number'>0</span>,); <span class='comment'>// tupla de un solo elemento</span>
(<span class='number'>0</span>); <span class='comment'>// cero encerrado en parentesis</span></pre>

<h2 id='indexado-en-tuplas' class='section-header'><a href='#indexado-en-tuplas'>Indexado en tuplas</a></h2>
<p>Puedes tambi√©n acceder los campos de una tupla con la sintaxis de indexado:</p>
<span class='rusttest'>fn main() {
    let tupla = (1, 2, 3);
    
    let x = tupla.0;
    let y = tupla.1;
    let z = tupla.2;
    
    println!(&quot;x es {}&quot;, x);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>tupla</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>tupla</span>.<span class='number'>0</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>tupla</span>.<span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='ident'>tupla</span>.<span class='number'>2</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x es {}&quot;</span>, <span class='ident'>x</span>);</pre>

<p>Al igual que el indexado en arreglos, este comienza en cero, pero a diferencia de el indexado en arreglos, se usan <code>.</code>, en lugar de <code>[]</code>s.</p>

<p>Puedes encontrar mas documentaci√≥n para tuplas <a href="../std/primitive.tuple.html">en la documentaci√≥n de la biblioteca est√°ndar</a> (ingles)</p>

<h1 id='funciones' class='section-header'><a href='#funciones'>Funciones</a></h1>
<p>Las funciones tambi√©n tienen un tipo! Estas lucen as√≠:</p>
<span class='rusttest'>fn main() {
    fn foo(x: i32) -&gt; i32 { x }
    
    let x: fn(i32) -&gt; i32 = foo;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> }

<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw'>fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>foo</span>;</pre>

<p>En este caso, <code>x</code> es un ‚Äòapuntador‚Äô a una funci√≥n que recibe un <code>i32</code> y retorna un <code>i32</code>.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
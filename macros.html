<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Macros</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Monticulo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilacion Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentacion</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribucion</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> Ciclos for</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> Ciclos while</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> Referencias y Prestamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Sintaxis de Metodos</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Genericos</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Rasgos</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Objetos de Razgo</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Sintaxis de Llamada a Funciones Universal</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates y Modulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Conversion entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Tipos sin Tamano</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Coerciones Deref</a>
</li>
<li><a class='active' href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Inverstigacion Academica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Macros</h1>
    <p>Por ahora, has aprendido sobre muchas las herramientas en Rust para abstraer y
reutilizar el código. Estas unidades de reutilización tienen una rica
estructura semántica. Por ejemplo, las funciones tienen un tipo, los parámetros
de tipo tienen límites de traits, y functiones sobrecargadas deben pertenecer a
un trait particular.</p>

<p>Debido a esta estructura, abstracciones fundamentales de Rust tienen potente
comprobación de exactitud. Pero, el precio es flexibilidad reducida. Si se
identifica visualmente un patrón de código repetido, podría ser dificil o
tedioso para expresar ese patrón como una función genérica, un trait, o
cualquier otra parte de la semántica de Rust.</p>

<p>Macros nos permiten abstraer a un nivel <em>sintáctic</em>. Una invocación de macro es
la abreviatura de una forma sintáctica &quot;expandido&quot;. Esta expansión ocurre
durante la compilación, antes de comprobación estática. Como resultado, las
macros pueden capturar muchos patrones de reutilización de código que las
abstracciones fundamentales de Rust no puede.</p>

<p>El inconveniente es que el código basado en la macro puede ser más difícil de
entender, porque menos de las normas incorporadas aplican. Al igual que una
función ordinaria, una macro de buen comportamiento se puede utilizar sin
entender detalles de implementación. Sin embargo, puede ser difícil diseñar una
macro de buen comportamiento! Además, los errores de compilación en código de
macro son más difíciles de entender, porque describen problemas en el código
expandido, no el formulario de origen que los desarrolladores utilizan.</p>

<p>Estos inconvenientes hacen macros una &quot;herramienta de último recurso&quot;. Eso no
quiere decir que las macros son malos; son parte de Rust porque a veces se
necesitan las macros para código concisa y abstraído. Sólo tenga en cuenta este
equilibrio.</p>

<h1 id="definición-de-una-macro" class='section-header'><a
                           href="#definición-de-una-macro">Definición de una macro</a></h1>
<p>Puede que haya visto la macro <code>vec!</code>, utilizado para inicializar un <a href="arrays-vectors-and-slices.html">vector</a>
con cualquier número de elementos.</p>
<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = vec![1, 2, 3];
    assert_eq!(&amp;[1,2,3], &amp;x);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
</pre>

<p>Esto no puede ser una función ordinaria, porque acepta cualquier número de
argumentos. Pero podemos imaginarlo como abreviatura sintáctica para</p>
<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    };
    assert_eq!(&amp;[1,2,3], &amp;x);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>2</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>3</span>);
    <span class='ident'>temp_vec</span>
};
</pre>

<p>Podemos implementar esta abreviatura, utilizando una macro: <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>
<span class='rusttest'>macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
fn main() {
    assert_eq!(vec![1,2,3], [1, 2, 3]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> {
    ( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> {
        {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
            $(
                <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
            )<span class='op'>*</span>
            <span class='ident'>temp_vec</span>
        }
    };
}
</pre>

<p>¡Whoa!, eso es mucha nueva sintaxis. Examinemos pieza por pieza.</p>
<span class='rusttest'>fn main() {
    macro_rules! vec { ... }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> { ... }
</pre>

<p>Este dice que estamos definiendo una macro llamada <code>vec</code>, tanto
como <code>fn vec</code> definiría una función llamada <code>vec</code>. En prosa,
informalmente escribimos el nombre de una macro con un signo de
exclamación, por ejemplo, <code>vec!</code>. El signo de exclamación es
parte de la sintaxis de invocación y sirve para distinguir una
macro desde una función ordinaria.</p>

<h2 id="emparejamiento-de-patrones" class='section-header'><a
                           href="#emparejamiento-de-patrones">Emparejamiento de patrones</a></h2>
<p>La macro se define a través de una serie de reglas de emparejamiento de patrones.
Por encima, tuvimos</p>
<span class='rusttest'>fn main() {
    ( $( $x:expr ),* ) =&gt; { ... };
    
}</span><pre class='rust rust-example-rendered'>
( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> { ... };
</pre>

<p>Esto es como un brazo de expresión <code>match</code>, pero coincide con árboles de
sintaxis Rust en tiempo de compilación. El punto y coma es opcional en el caso
final (aquí, el único caso). El &quot;patrón&quot; en el lado izquierdo de <code>=&gt;</code> es
conocido como un &#39;matcher&#39;. Estos tienen <a href="../reference.html#macros">su propio pequeño gramática</a> dentro
del language.</p>

<p>El matcher <code>$x:expr</code> coincidirá con cualquier expresión Rust, vinculante esta
árbol sintáctico a la &#39;metavariable&#39; <code>$x</code>. El identificador <code>expr</code> es un
&#39;especificador fragmento&#39;; todas las posibilidades se enumeran más adelante en
este capitulo. Al rodear el matcher con <code>$(...),*</code>, que coincidirá con cero o
más expresiones separadas por comas.</p>

<p>Aparte de la sintaxis especial de matcher, las tokens Rust que aparecen en un
matcher deben coincidir exactamente. Por ejemplo,</p>
<span class='rusttest'>macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!(&quot;mode X: {}&quot;, $e));
    (y =&gt; $e:expr) =&gt; (println!(&quot;mode Y: {}&quot;, $e));
}

fn main() {
    foo!(y =&gt; 3);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='ident'>x</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mode X: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
    (<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mode Y: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);
}
</pre>

<p>imprimirá</p>

<pre><code class="language-text">mode Y: 3
</code></pre>

<p>Con</p>
<span class='rusttest'>fn main() {
    foo!(z =&gt; 3);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>z</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);
</pre>

<p>obtenemos el error del compilador</p>

<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>

<h2 id="expansión" class='section-header'><a
                           href="#expansión">Expansión</a></h2>
<p>El lado derecho de una regla macro es la sintaxis Rust ordinaria, en su mayor
parte. Pero podemos insertar partes de sintaxis capturados por el matcher. Del
ejemplo original:</p>
<span class='rusttest'>fn main() {
    $(
        temp_vec.push($x);
    )*
    
}</span><pre class='rust rust-example-rendered'>
$(
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
)<span class='op'>*</span>
</pre>

<p>Cada expresión emparejado <code>$x</code> producirá una sola expresión <code>push</code> en la
expansión de macros. La repetición se desarrolla en &quot;lockstep&quot; con la
repetición en el matcher (más sobre esto en un momento).</p>

<p>Porque <code>$x</code> ya fue declarado como emparejar una expresión, no repetimos <code>:expr</code>
en el lado derecho. Además, no incluimos una coma separando como parte del
operador de repetición. En cambio, tenemos un punto y coma que termina dentro
del bloque repetido.</p>

<p>Otro detalle: la macro <code>vec</code> tiene <em>dos</em> pares de paréntesis rizado en la mano
derecha. A menudo se combinan de este modo:</p>
<span class='rusttest'>fn main() {
    macro_rules! foo {
        () =&gt; {{
            ...
        }}
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> {{
        ...
    }}
}
</pre>

<p>Los paréntesis exteriores son parte de la sintaxis de <code>macro_rules!</code>. De hecho,
puede utilizar <code>()</code> o <code>[]</code> en su lugar. Ellos simplemente delimitan el lado
derecho como un todo.</p>

<p>Los paréntesis interiores son parte de la sintaxis expandida. Recuerde, la
macro <code>vec!</code> se utiliza en un contexto de expresión. Para escribir una
expresión con varias statements, entre ellas <code>let</code>-bindings, utilizamos un
bloque. Si la macro se expande a una sola expresión, no necesitas esta
capa extra de paréntesis.</p>

<p>Tenga en cuenta que nunca <em>declaramos</em> que la macro produce una expresión. De
hecho, esto no se determina hasta que usamos la macro como una expresión. Con
cuidado, se puede escribir una macro cuya expansión trabaja en varios
contextos. Por ejemplo, la abreviatura de un tipo de datos podría ser válido
como una expresión o un patrón.</p>

<h2 id="repetición" class='section-header'><a
                           href="#repetición">Repetición</a></h2>
<p>El operador de repetición sigue dos reglas principales:</p>

<ol>
<li><code>$(...)*</code> camina a través de una &quot;capa&quot; de repeticiones, para todos los <code>$nombre</code>s
que contiene, al mismo paso, y</li>
<li>cada <code>$nombre</code> debe estar bajo al menos tantos <code>$(...)*</code> como se compara con.
Si es bajo más, que va a ser duplicado, según el caso.</li>
</ol>

<p>Esta macro barroca ilustra la duplicación de las variables de los niveles de
repetición exteriores.</p>
<span class='rusttest'>macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &amp;[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>o_O</span> {
    (
        $(
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>; [ $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ]
        );<span class='op'>*</span>
    ) <span class='op'>=&gt;</span> {
        <span class='kw-2'>&amp;</span>[ $($( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span> <span class='op'>+</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span> ),<span class='op'>*</span>),<span class='op'>*</span> ]
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>]
        <span class='op'>=</span> <span class='macro'>o_O</span><span class='macro'>!</span>(<span class='number'>10</span>; [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
               <span class='number'>20</span>; [<span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, [<span class='number'>11</span>, <span class='number'>12</span>, <span class='number'>13</span>, <span class='number'>24</span>, <span class='number'>25</span>, <span class='number'>26</span>]);
}
</pre>

<p>Esa es la mayor parte de la sintaxis de matcher. Estos ejemplos utilizan
<code>$(...)*</code>, que coincide con &quot;cero o más&quot; elementos sintácticos.
Alternativamente, puedes escribir <code>$(...)+</code> para coincide con &quot;uno o
más&quot;.  Ambas formas incluyen, opcionalmente, un separador, que puede ser
cualquier token excepto <code>+</code> o <code>*</code>.</p>

<p>Este sistema se basa en
&quot;<a href="http://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>&quot;
(PDF).</p>

<h1 id="higiene" class='section-header'><a
                           href="#higiene">Higiene</a></h1>
<p>Algunos lenguajes implementan macros con sustitución de texto simple, lo que
conduce a diversos problemas. Por ejemplo, este programa C imprime <code>13</code> en
lugar de la esperada <code>25</code>.</p>

<pre><code class="language-text">#define CINCO_VECES(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, CINCO_VECES(2 + 3));
    return 0;
}
</code></pre>

<p>Después de la expansión tenemos <code>5 * 2 + 3</code>, y la multiplicación tiene mayor
precedencia que la suma. Si has utilizado macros C mucho, probablemente
sabes los idiomas estándar para evitar este problema, así como cinco o seis
otros. En Rust, no nos preocupamos por ello.</p>
<span class='rusttest'>macro_rules! cinco_veces {
    ($x:expr) =&gt; (5 * $x);
}

fn main() {
    assert_eq!(25, cinco_veces!(2 + 3));
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>cinco_veces</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='number'>5</span> <span class='op'>*</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>25</span>, <span class='macro'>cinco_veces</span><span class='macro'>!</span>(<span class='number'>2</span> <span class='op'>+</span> <span class='number'>3</span>));
}
</pre>

<p>El metavariable <code>$x</code> se analiza como un nodo de expresión individual, y
mantiene su lugar en el árbol de sintaxis, incluso después de la sustitución.</p>

<p>Otro problema común en los sistemas de macro es &quot;captura variable&quot;. Aquí hay
una macro C, utilizando <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">una extensión de GNU C</a> para emular bloques de
expresión de Rust.</p>

<pre><code class="language-text">#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, state, msg); \
    } \
})
</code></pre>

<p>Aquí es un caso simple de usar que va terriblemente mal:</p>

<pre><code class="language-text">const char *state = &quot;reticulante acanaladuras&quot;;
LOG(state)
</code></pre>

<p>Esto expande a</p>

<pre><code class="language-text">const char *state = &quot;reticulante acanaladuras&quot;;
int state = get_log_state();
if (state &gt; 0) {
    printf(&quot;log(%d): %s\n&quot;, state, state);
}
</code></pre>

<p>La segunda variable llamada <code>state</code> ensombrece de la primera.
Esto es un problema porque la expresión de impresión (<code>printf</code>)
debe hacer referencia a los dos.</p>

<p>La macro Rust equivalente tiene el comportamiento deseado.</p>
<span class='rusttest'>fn get_log_state() -&gt; i32 { 3 }
macro_rules! log {
    ($msg:expr) =&gt; {{
        let state: i32 = get_log_state();
        if state &gt; 0 {
            println!(&quot;log({}): {}&quot;, state, $msg);
        }
    }};
}

fn main() {
    let state: &amp;str = &quot;reticulante acanaladuras&quot;;
    log!(state);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>log</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {{
        <span class='kw'>let</span> <span class='ident'>state</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>get_log_state</span>();
        <span class='kw'>if</span> <span class='ident'>state</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;log({}): {}&quot;</span>, <span class='ident'>state</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>);
        }
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>state</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='string'>&quot;reticulante acanaladuras&quot;</span>;
    <span class='macro'>log</span><span class='macro'>!</span>(<span class='ident'>state</span>);
}
</pre>

<p>Esto funciona porque Rust tiene una <a href="http://en.wikipedia.org/wiki/Hygienic_macro">sistema de macros
higiénica</a>. Cada expansión macro ocurre en un &quot;contexto de
sintaxis&quot; distinto, y cada variable está asociada con el
contexto de sintaxis donde fue introducida. Es como si el
variable <code>state</code> dentro <code>main</code> está pintado de un &quot;color&quot;
diferente de la variable <code>state</code> dentro de la macro, y por lo
tanto no contradigan.</p>

<p>Esto también restringe la capacidad de macros para introducir nuevos enlaces en
el sitio de invocación. Código como el siguiente no funcionará:</p>
<span class='rusttest'>macro_rules! foo {
    () =&gt; (let x = 3);
}

fn main() {
    foo!();
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>En lugar necesitas para pasar el nombre de la variable en la invocación, por lo
que tiene el contexto de sintaxis correcta.</p>
<span class='rusttest'>macro_rules! foo {
    ($v:ident) =&gt; (let $v = 3);
}

fn main() {
    foo!(x);
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span>:<span class='ident'>ident</span>) <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span> <span class='op'>=</span> <span class='number'>3</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>x</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>Esto es válido para enlaces <code>let</code> y etiquetas de bucle, pero no para <a href="../reference.html#items">items</a>. Así que el siguiente código hace compilar:</p>
<span class='rusttest'>macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>fn</span> <span class='ident'>x</span>() { });
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='ident'>x</span>();
}
</pre>

<h1 id="macros-recursivas" class='section-header'><a
                           href="#macros-recursivas">Macros recursivas</a></h1>
<p>La expansión de una macro puede incluir más invocaciones macro, incluyendo
invocaciones de la misma macro ser expandido. Estas macros recursivas son
útiles para el procesamiento de entrada con estructura de árbol, como se
ilustra por esta (simplista) taquigrafía HTML:</p>
<span class='rusttest'>#![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, &quot;{}&quot;, $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, &quot;&lt;{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, &quot;&lt;/{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
  // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&amp;mut out,
        html[
            head[title[&quot;Macros guide&quot;]]
            body[h1[&quot;Macros are the best!&quot;]]
        ]);

    assert_eq!(out,
        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>write_html</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, ) <span class='op'>=&gt;</span> (());

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>tt</span>) <span class='op'>=&gt;</span> (<span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;{}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>:<span class='ident'>ident</span> [ $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>:<span class='ident'>tt</span>)<span class='op'>*</span> ] $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {{
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>)<span class='op'>*</span>);
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;/{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>)<span class='op'>*</span>);
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Write</span>;
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>out</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>out</span>,
        <span class='ident'>html</span>[
            <span class='ident'>head</span>[<span class='ident'>title</span>[<span class='string'>&quot;Macros guide&quot;</span>]]
            <span class='ident'>body</span>[<span class='ident'>h1</span>[<span class='string'>&quot;Macros are the best!&quot;</span>]]
        ]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>out</span>,
        <span class='string'>&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);
}
</pre>

<h1 id="depuración-de-código-de-macro" class='section-header'><a
                           href="#depuración-de-código-de-macro">Depuración de código de macro</a></h1>
<p>Para ver los resultados de las macros en expansión, ejecutar
<code>rustc --pretty expanded</code>. La salida representa toda un crate, por lo que también
puede alimentar de nuevo en a <code>rustc</code>, que a veces producir mejores mensajes de
error de la compilación inicial. Tenga en cuenta que la salida de <code>--pretty expanded</code> puede tener un significado diferente si varias variables del mismo
nombre (pero diferentes contextos sintácticos) están en juego en el mismo
ámbito. En este caso <code>--pretty expanded,hygiene</code> le dirá acerca de los
contextos de sintaxis.</p>

<p><code>rustc</code> ofrece dos extensiones de sintaxis que ayudan con el depuración de
macros. Por ahora, son inestables y requieren puertas de características.</p>

<ul>
<li><p><code>log_syntax!(...)</code> imprimirá sus argumentos en la salida estándar, en tiempo
de compilación, y &quot;expandir&quot; para nada.</p></li>
<li><p><code>trace_macros!(true)</code> permitirá un mensaje compilador cada vez que una macro es
expandida. Use <code>trace_macros!(false)</code> adelante en la expansión de apagarlo.</p></li>
</ul>

<h1 id="requisitos-sintácticos" class='section-header'><a
                           href="#requisitos-sintácticos">Requisitos sintácticos</a></h1>
<p>Incluso cuando el código Rust contiene macros un-expandida, se puede
analizar como un completo <a href="glossary.html#abstract-syntax-tree">árbol sintáctico</a>. Esta propiedad puede ser
muy útil para los editores y otras herramientas que procesan código. También
tiene algunas consecuencias para el diseño del sistema de macro de Rust.</p>

<p>Una consecuencia es que Rust debe determinar, cuando se analiza una invocación
macro, si la macro se destaca por</p>

<ul>
<li>cero o más items,</li>
<li>cero o más methods,</li>
<li>una expresión,</li>
<li>un statement, o</li>
<li>un patrón.</li>
</ul>

<p>Una invocación macro dentro de un bloque podía expandir para algunos items, o
para un expresión. Rust utiliza una regla simple para resolver esta ambigüedad.
Una invocación macro que significa items debe ser</p>

<ul>
<li>delimitada por paréntesis rizado, como <code>foo! { ... }</code>, o</li>
<li>terminada por un punto y coma, como <code>foo!(...);</code>.</li>
</ul>

<p>Otra consecuencia del análisis de pre-expansión es que la invocación macro debe
constar de tokens válidos de Rust. Además, paréntesis (ronda, cuadrado, y
rizado) deben equilibrarse dentro de un invocación macro. Por ejemplo,
<code>foo!([)</code> está prohibido. Esto permite Rust saber dónde termina la invocación
macro.</p>

<p>Más formalmente, el cuerpo de invocación macro debe ser una secuencia de
&quot;árboles de token&quot;. Un árbol de token se define de forma recursiva, ya sea como</p>

<ul>
<li>una secuencia de árboles token rodeadas de <code>()</code>, <code>[]</code>, o <code>{}</code>, o</li>
<li>cualquier otra token única.</li>
</ul>

<p>Dentro de un matcher, cada metavariable tiene un &#39;especificador fragmento&#39;,
identificando qué forma sintáctica coincide.</p>

<ul>
<li><code>ident</code>: un identificador. Por ejemplo: <code>x</code>; <code>foo</code>.</li>
<li><code>path</code>: un nombre calificado. Por ejemplo: <code>T::SpecialA</code>.</li>
<li><code>expr</code>: una expresión. Por ejemplo: <code>2 + 2</code>; <code>if true then { 1 } else { 2 }</code>; <code>f(42)</code>.</li>
<li><code>ty</code>: un tipo. Por ejemplo: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
<li><code>pat</code>: un patrón. Por ejemplo: <code>Some(t)</code>; <code>(17, &#39;a&#39;)</code>; <code>_</code>.</li>
<li><code>stmt</code>: una sola statement. Por ejemplo: <code>let x = 3</code>.</li>
<li><code>block</code>: una secuencia de statements. Por ejemplo:
<code>{ log(error, &quot;hi&quot;); return 12; }</code>.</li>
<li><code>item</code>: un <a href="../reference.html#items">item</a>. Por ejemplo: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
<li><code>meta</code>: un &quot;meta item&quot;, como se encuentra en atributos. Por ejemplo: <code>cfg(target_os = &quot;windows&quot;)</code>.</li>
<li><code>tt</code>: un árbol de token única.</li>
</ul>

<p>Existen reglas adicionales con respecto a la siguiente token después de un metavariable:</p>

<ul>
<li><code>expr</code> solamente puede ser seguido por uno de: <code>=&gt; , ;</code></li>
<li><code>ty</code> y <code>path</code> solamente puede ser seguido por uno de: <code>=&gt; , : = &gt; as</code></li>
<li><code>pat</code> solamente puede ser seguido por uno de: <code>=&gt; , = if in</code></li>
<li>Otros variables puede ser seguido de cualquier token.</li>
</ul>

<p>Estas reglas proporcionan cierta flexibilidad para evolucionar la sintaxis de
Rust sin romper macros existentes.</p>

<p>El sistema de macro no se ocupa analizar la ambigüedad. Por ejemplo, la
gramática <code>$($t:ty)* $e:expr</code> siempre dejará de analizar, porque el analizador
se ve obligada a elegir entre analizar <code>$t</code> y analizar <code>$e</code>. Cambio de la
sintaxis de invocación para poner un token distintiva delante puede resolver
el problema. En este caso, se puede escribir <code>$(T $t:ty)* E $e:exp</code>.</p>

<h1 id="alcance-y-importación/exportación-de-macros" class='section-header'><a
                           href="#alcance-y-importación/exportación-de-macros">Alcance y importación/exportación de macros</a></h1>
<p>Las macros se expanden en una etapa temprana en la compilación, antes de la
resolución de nombres. Una desventaja es que alcance funciona de forma
diferente para las macros, en comparación con otras construcciones en el
lenguaje.</p>

<p>Definición y expansión de macros ambos suceden en un solo recorrido de un
crate. Así que una macro se define en el alcance módulo es visible para
cualquier código posterior en el mismo módulo, que incluye el cuerpo de un niño
<code>mod</code> items subsiguientes.</p>

<p>Una macro definida en el cuerpo de una <code>fn</code>, o en cualquier otro lugar, no en
el ámbito de módulo, sólo es visible dentro de ese parte.</p>

<p>Si un módulo tiene el atributo <code>macro_use</code>, sus macros también son visibles en
su módulo padre después del item <code>mod</code> del niño. Si el padre también tiene
<code>macro_use</code>, entonces las macros serán visibles en el abuelo después del item
<code>mod</code> del padre, y así sucesivamente.</p>

<p>El atributo <code>macro_use</code> también puede aparecer en <code>extern crate</code>. En este
contexto, controla qué macros se cargan desde el crate externo, por ejemplo,</p>
<span class='rusttest'>fn main() {
    #[macro_use(foo, bar)]
    extern crate baz;
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_use</span>(<span class='ident'>foo</span>, <span class='ident'>bar</span>)]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>baz</span>;
</pre>

<p>Si el atributo se da simplemente como <code>#[macro_use]</code>, todas las macros se cargan. Si no hay atributo <code>#[macro_use]</code> entonces no hay macros se cargan. Sólo macros definidas con el atributo <code>#[macro_export]</code> pueden cargar.</p>

<p>Para cargar las macros de un cajón sin vincularla a la salida, utilice <code>#[no_link]</code> también.</p>

<p>Un ejemplo:</p>
<span class='rusttest'>macro_rules! m1 { () =&gt; (()) }

// visibles aquí: m1

mod foo {
    // visibles aquí: m1

    #[macro_export]
    macro_rules! m2 { () =&gt; (()) }

    // visibles aquí: m1, m2
}

// visibles aquí: m1

macro_rules! m3 { () =&gt; (()) }

// visibles aquí: m1, m3

#[macro_use]
mod bar {
    // visibles aquí: m1, m3

    macro_rules! m4 { () =&gt; (()) }

    // visibles aquí: m1, m3, m4
}

// visibles aquí: m1, m3, m4
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m1</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// visibles aquí: m1</span>

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='comment'>// visibles aquí: m1</span>

    <span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m2</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// visibles aquí: m1, m2</span>
}

<span class='comment'>// visibles aquí: m1</span>

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m3</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// visibles aquí: m1, m3</span>

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='comment'>// visibles aquí: m1, m3</span>

    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m4</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// visibles aquí: m1, m3, m4</span>
}

<span class='comment'>// visibles aquí: m1, m3, m4</span>
</pre>

<p>Cuando esta biblioteca se carga con <code>#[macro_use] extern crate</code>, se importará solamente <code>m2</code>.</p>

<p>El Referencia de Rust tiene una <a href="../reference.html#macro-related-attributes">lista de atributos relacionados a macros</a>.</p>

<h1 id="la-variable-$crate" class='section-header'><a
                           href="#la-variable-$crate">La variable <code>$crate</code></a></h1>
<p>Una dificultad adicional se produce cuando se utiliza una macro en múltiples crates. Decir que define <code>mibibl</code></p>
<span class='rusttest'>pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) =&gt; ( ::increment($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) =&gt; ( ::mibibl::increment($x) )
}
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>increment</span>(<span class='ident'>x</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_a</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_b</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>mibibl</span>::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}
</pre>

<p><code>inc_a</code> sólo funciona dentro de <code>mibibl</code>, mientras que <code>inc_b</code> sólo funciona
fuera de la biblioteca. Además, <code>inc_b</code> se romperá si importas <code>mibibl</code> con
otro nombre.</p>

<p>Rust no (todavía) tiene un sistema de higiene para las referencias de crates,
pero proporciona una solución sencilla para este problema. Dentro de una macro
importado de un crate llamado <code>foo</code>, la variable macro especial <code>$crate</code>
expandirá a <code>::foo</code>. Por el contrario, cuando una macro se define y luego se
usa en el mismo crate, <code>$crate</code> se expandirá para nada. Esto significa que
podemos escribir</p>
<span class='rusttest'>#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>crate</span>::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}
</pre>

<p>para definir una sola macro que funciona tanto dentro como fuera de nuestra
biblioteca. El nombre de la función expandirá a cualquiera <code>::increment</code> o
<code>::mibibl::increment</code>.</p>

<p>Para mantener este sistema simple y correcta, <code>#[macro_use] extern crate ...</code>
solamente puede aparecer en la raíz de su crate, no dentro de <code>mod</code>. Esto
asegura que <code>$crate</code> es un único identificador.</p>

<h1 id="el-extremo-profundo" class='section-header'><a
                           href="#el-extremo-profundo">El extremo profundo</a></h1>
<p>Las secciones antes mencionadas macros recursivas, pero no dio la historia
completa. Macros recursivas son útiles por otra razón: Cada invocación
recursiva es una otra oportunidad para emparejar los patrónes con los
argumentos de la macro.</p>

<p>Como un ejemplo extremo, es posible, aunque poco recomendable, para implementar la autómata <a href="http://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a> dentro del sistema macro de Rust.</p>
<span class='rusttest'>fn main() {
    macro_rules! bct {
        // cmd 0:  d ... =&gt; ...
        (0, $($ps:tt),* ; $_d:tt)
            =&gt; (bct!($($ps),*, 0 ; ));
        (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
            =&gt; (bct!($($ps),*, 0 ; $($ds),*));
    
        // cmd 1p:  1 ... =&gt; 1 ... p
        (1, $p:tt, $($ps:tt),* ; 1)
            =&gt; (bct!($($ps),*, 1, $p ; 1, $p));
        (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
            =&gt; (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));
    
        // cmd 1p:  0 ... =&gt; 0 ...
        (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
            =&gt; (bct!($($ps),*, 1, $p ; $($ds),*));
    
        // alto en cadena vacía
        ( $($ps:tt),* ; )
            =&gt; (());
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>bct</span> {
    <span class='comment'>// cmd 0:  d ... =&gt; ...</span>
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>0</span> ; ));
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>0</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>));

    <span class='comment'>// cmd 1p:  1 ... =&gt; 1 ... p</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));

    <span class='comment'>// cmd 1p:  0 ... =&gt; 0 ...</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>));

    <span class='comment'>// alto en cadena vacía</span>
    ( $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; )
        <span class='op'>=&gt;</span> (());
}
</pre>

<p>Ejercicio: usar macros para reducir la duplicación en la definición anterior de la macro <code>bct!</code>.</p>

<h1 id="macros-comunes" class='section-header'><a
                           href="#macros-comunes">Macros comunes</a></h1>
<p>Estas son algunas de las macros comunes que verás en el código de Rust.</p>

<h2 id="panic!" class='section-header'><a
                           href="#panic!">panic!</a></h2>
<p>Esta macro hace que el thread actual de pánico. Puede darle un mensaje de pánico.</p>
<span class='rusttest'>fn main() {
    panic!(&quot;qué vergüenza&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;qué vergüenza&quot;</span>);
</pre>

<h2 id="vec!" class='section-header'><a
                           href="#vec!">vec!</a></h2>
<p>La macro <code>vec!</code> se utiliza en todo el libro, por lo que probablemente ha visto
ya. Crea los <code>Vec&lt;T&gt;</code> con facilidad:</p>
<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3, 4, 5];
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
</pre>

<p>También le permite realizar los vectores con valores de repetir. Por ejemplo, un centenar de ceros:</p>
<span class='rusttest'>fn main() {
    let v = vec![0; 100];
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>; <span class='number'>100</span>];
</pre>

<h2 id="assert!-y-assert_eq!" class='section-header'><a
                           href="#assert!-y-assert_eq!">assert! y assert_eq!</a></h2>
<p>Estas dos macros se utilizan en las pruebas. <code>assert!</code> toma un boolean.
<code>assert_eq!</code> toma dos valores y los comprueba por la igualdad. <code>true</code> pasa,
<code>false</code> entra en pánico. Como este:</p>
<span class='rusttest'>fn main() {
    // A-ok!
    
    assert!(true);
    assert_eq!(5, 3 + 2);
    
    // nope :(
    
    assert!(5 &lt; 3);
    assert_eq!(5, 3);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// A-ok!</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='boolval'>true</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='comment'>// nope :(</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='number'>5</span> <span class='op'>&lt;</span> <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span>);
</pre>

<h2 id="try!" class='section-header'><a
                           href="#try!">try!</a></h2>
<p><code>try!</code> se utiliza para el tratamiento de errores. Toma algo que puede devolver un
<code>Result&lt;T, E&gt;</code>, y da <code>T</code> si es un <code>Ok(T)</code> y se <code>return</code> con la
<code>Err(E)</code> si se trata de eso. Como este:</p>
<span class='rusttest'>fn main() {
    use std::fs::File;
    
    fn foo() -&gt; std::io::Result&lt;()&gt; {
        let f = try!(File::create(&quot;foo.txt&quot;));
    
        Ok(())
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>));

    <span class='prelude-val'>Ok</span>(())
}
</pre>

<p>Esto es más limpio que hacer esto:</p>
<span class='rusttest'>fn main() {
    use std::fs::File;
    
    fn foo() -&gt; std::io::Result&lt;()&gt; {
        let f = File::create(&quot;foo.txt&quot;);
    
        let f = match f {
            Ok(t) =&gt; t,
            Err(e) =&gt; return Err(e),
        };
    
        Ok(())
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>f</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>t</span>) <span class='op'>=&gt;</span> <span class='ident'>t</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>),
    };

    <span class='prelude-val'>Ok</span>(())
}
</pre>

<h2 id="unreachable!" class='section-header'><a
                           href="#unreachable!">unreachable!</a></h2>
<p>Esta macro se utiliza cuando se piensa en algo de código nunca debe ejecutar:</p>
<span class='rusttest'>fn main() {
    if false {
        unreachable!();
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>if</span> <span class='boolval'>false</span> {
    <span class='macro'>unreachable</span><span class='macro'>!</span>();
}
</pre>

<p>A veces, el compilador puede hacer que tienes una rama que sabe que nunca,
nunca correr. En estos casos, utilizar esta macro, por lo que si terminas
mal, obtendrá un <code>panic!</code>.</p>
<span class='rusttest'>fn main() {
    let x: Option&lt;i32&gt; = None;
    
    match x {
        Some(_) =&gt; unreachable!(),
        None =&gt; println!(&quot;Sé que x es None!&quot;),
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;

<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> <span class='macro'>unreachable</span><span class='macro'>!</span>(),
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Sé que x es None!&quot;</span>),
}
</pre>

<h2 id="unimplemented!" class='section-header'><a
                           href="#unimplemented!">unimplemented!</a></h2>
<p>Esta macro se puede utilizar cuando estás tratando de typecheck sus
funciones, y no quieren que preocuparse por escribir el cuerpo de la función.
Un ejemplo de esta situación está implementando un trait con métodos múltiples
requeridos, en los que desea hacer frente a uno a la vez. Definir los demás
como <code>unimplemented!</code> hasta que esté listo para escribirlas.</p>

<h1 id="macros-de-procedimiento" class='section-header'><a
                           href="#macros-de-procedimiento">Macros de procedimiento</a></h1>
<p>Si el sistema de macro de Rust no puede hacer lo que necesita, es posible que
desee escribir una <a href="compiler-plugins.html">plugin compilador</a> en su lugar. En
comparación con macros <code>macro_rules!</code>, esto es significativamente más trabajo,
las interfaces son mucho menos estables, y los errores pueden ser mucho más
difíciles de localizar. A cambio se obtiene la flexibilidad de la ejecución de
código arbitrario en Rust en tiempo de compilación. Plugins de extensión de
sintaxis a veces se llaman &quot;procedural macros&quot; (macros de procedimiento) por
este motivo.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>La propia definición de <code>vec!</code> en libcollections difiere de la
       presentada aquí, por razones de eficiencia y reutilización.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
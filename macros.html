<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Macros</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a class='active' href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Macros</h1>
    <p>Por ahora, has aprendido mucho sobre las herramientas que Rust ofrece para abstraer y
reutilizar código. Estas unidades de reutilización poseen una rica
estructura semántica. Por ejemplo, las funciones tienen una firma de tipos, los parámetros
de tipo tienen límites de traits y las funciones sobrecargadas deben pertenecer a
un trait particular.</p>

<p>Esta estructura significa que las principales abstracciones en Rust poseen un
poderoso mecanismo de chequeo en tiempo de compilación. Pero, el precio es una flexibilidad reducida.
Si se identifica visualmente un patrón de código repetido, podría ser difícil o
tedioso expresar ese patrón como una función genérica, un trait, o
cualquier otro elemento de la semántica de Rust.</p>

<p>Las macros nos permiten abstraer a un nivel <em>sintáctico</em>. Una invocación de macro es
la abreviatura de una forma sintáctica &quot;expandida&quot;. Dicha expansión ocurre
durante la compilación, antes de comprobación estática. Como resultado, las
macros pueden capturar muchos patrones de reutilización de código que las
abstracciones fundamentales de Rust no pueden.</p>

<p>El inconveniente es que el código basado en macros puede ser más difícil de
entender, porque menos de las normas internas de Rust aplican. Al igual que una
función ordinaria, una macro bien hecha se puede utilizar sin
entender detalles de implementación. Sin embargo, puede ser difícil diseñar una
macro con un buen comportamiento! Además, los errores de compilación en código de
macros son más difíciles de entender, porque describen problemas en el código
expandido, no a nivel del código fuente que usan los desarrolladores.</p>

<p>Estos inconvenientes hacen de las macros una &quot;herramienta de último recurso&quot;. Lo anterior no
quiere decir que las macros son malas; forman parte de Rust porque a veces son necesarias
para código conciso y abstracto. Simplemente mantén en cuenta este equilibrio.</p>

<h1 id='definiendo-una-macro' class='section-header'><a href='#definiendo-una-macro'>Definiendo una macro</a></h1>
<p>Puede que ya hayas visto la macro <code>vec!</code>, utilizada para inicializar un <a href="arrays-vectors-and-slices.html">vector</a>
con un numero cualquiera de elementos.</p>
<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = vec![1, 2, 3];
    assert_eq!(&amp;[1,2,3], &amp;x);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];</pre>

<p>Esto no puede ser una función ordinaria, porque acepta cualquier número de
argumentos. Pero podemos imaginarlo como una abreviación sintáctica para</p>
<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    };
    assert_eq!(&amp;[1,2,3], &amp;x);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>2</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>3</span>);
    <span class='ident'>temp_vec</span>
};</pre>

<p>Podemos implementar esta abreviatura, utilizando una macro: <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>
<span class='rusttest'>macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
fn main() {
    assert_eq!(vec![1,2,3], [1, 2, 3]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> {
    ( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> {
        {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
            $(
                <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
            )<span class='op'>*</span>
            <span class='ident'>temp_vec</span>
        }
    };
}</pre>

<p>¡Whoa!, un montón de sintaxis nueva. Examinémoslo parte por parte.</p>
<span class='rusttest'>fn main() {
    macro_rules! vec { ... }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> { ... }</pre>

<p>Lo anterior dice que estamos definiendo una macro llamada <code>vec</code>, al igual que
<code>fn vec</code> definiría una función llamada <code>vec</code>. En prosa,
informalmente escribimos el nombre de una macro con un signo de
exclamación, por ejemplo, <code>vec!</code>. Este signo de exclamación es
parte de la sintaxis de invocación y sirve para distinguir una
macro de una función ordinaria.</p>

<h2 id='coincidencia-de-patrones' class='section-header'><a href='#coincidencia-de-patrones'>Coincidencia de patrones</a></h2>
<p>Una macro se define a través de una serie de reglas, las cuales son casos de coincidencia de patrones. Anteriormente vimos</p>
<span class='rusttest'>fn main() {
    ( $( $x:expr ),* ) =&gt; { ... };
    
}</span><pre class='rust rust-example-rendered'>
( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> { ... };</pre>

<p>Esto es similar a un brazo de una expresión <code>match</code>, pero las pruebas para coincidencia
ocurren sobre los árboles de sintaxis Rust en tiempo de compilación. El punto y coma es opcional en el caso
final (aquí, el único caso). El &quot;patrón&quot; en el lado izquierdo del <code>=&gt;</code> es
conocido como un &#39;matcher&#39;. Los matchers tienen <a href="../reference.html#macros">su propia pequeño gramática</a> dentro
del language.</p>

<p>El matcher <code>$x:expr</code> coincidirá con cualquier expresión Rust, asociando ese
árbol sintáctico a la &#39;metavariable&#39; <code>$x</code>. El identificador <code>expr</code> es un
&#39;especificador fragmento&#39;; todas las posibilidades se enumeran en el <a href="advanced-macros.html">capitulo avanzado de macros</a>.
Al rodear el matcher con <code>$(...),*</code>, coincidirá con cero o más expresiones separadas por comas.</p>

<p>Ademas de la sintaxis especial de matchers, los tokens Rust que aparecen en un
matcher deben coincidir de manera exacta. Por ejemplo:</p>
<span class='rusttest'>macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!(&quot;modo X: {}&quot;, $e));
    (y =&gt; $e:expr) =&gt; (println!(&quot;modo Y: {}&quot;, $e));
}

fn main() {
    foo!(y =&gt; 3);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='ident'>x</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;modo X: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
    (<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;modo Y: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);
}</pre>

<p>imprimirá</p>

<pre><code class="language-text">modo Y: 3
</code></pre>

<p>Con</p>
<span class='rusttest'>fn main() {
    foo!(z =&gt; 3);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>z</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);</pre>

<p>obtenemos el error del compilador</p>

<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>

<h2 id='expansión' class='section-header'><a href='#expansión'>Expansión</a></h2>
<p>El lado derecho de una regla macro es sintaxis Rust ordinaria, en su mayor
parte. Pero podemos insertar partes de sintaxis capturadas por el matcher. Del
ejemplo original:</p>
<span class='rusttest'>fn main() {
    $(
        temp_vec.push($x);
    )*
    
}</span><pre class='rust rust-example-rendered'>
$(
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
)<span class='op'>*</span></pre>

<p>Cada expresión coincidente <code>$x</code> producirá una sola expresión <code>push</code> en la
expansión de la macro. La repetición se desarrolla en &quot;lockstep&quot; con la
repetición en el matcher (más sobre esto en un momento).</p>

<p>Debido a que <code>$x</code> ya fue marcado como una coincidencia con una expresión, no repetimos <code>:expr</code>
en el lado derecho. Además, no incluimos una coma separando como parte del
operador de repetición. En cambio, tenemos un punto y coma que termina dentro
del bloque repetido.</p>

<p>Otro detalle: la macro <code>vec</code> tiene <em>dos</em> pares de llaves en el lado
derecho. A menudo se combinan de este modo:</p>
<span class='rusttest'>fn main() {
    macro_rules! foo {
        () =&gt; {{
            ...
        }}
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> {{
        ...
    }}
}</pre>

<p>Las llaves exteriores son parte de la sintaxis de <code>macro_rules!</code>. De hecho,
se puede utilizar <code>()</code> o <code>[]</code> en su lugar. Simplemente delimitan el lado
derecho como un todo.</p>

<p>Las llaves interiores son parte de la sintaxis expandida. Recuerda que la
macro <code>vec!</code> se utiliza en un contexto de expresión. Para escribir una
expresión con varias sentencias, entre ellas enlaces a variable, utilizamos un
bloque. Si la macro se expande a una sola expresión, no necesitas dicha
capa extra de llaves.</p>

<p>Hay que tener también en cuenta que nunca <em>declaramos</em> que la macro produce una expresión. De
hecho, esto no se determina hasta que usamos la macro como una expresión. Con
cuidado, se puede escribir una macro cuya expansión funcione en varios
contextos. Por ejemplo, la abreviatura de un tipo de datos podría ser válida
como una expresión o un patrón.</p>

<h2 id='repetición' class='section-header'><a href='#repetición'>Repetición</a></h2>
<p>El operador de repetición sigue dos reglas principales:</p>

<ol>
<li><code>$(...)*</code> camina a través de una &quot;capa&quot; de repeticiones, para todos los <code>$nombre</code>s
que contiene, al mismo paso, y</li>
<li>cada <code>$nombre</code> debe estar bajo al menos tantos <code>$(...)*</code> como los que fue comparado.
Si esta bajo más, sera duplicado, según el caso.</li>
</ol>

<p>Esta macro barroca ilustra la duplicación de las variables de los niveles de
repetición exteriores.</p>
<span class='rusttest'>macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &amp;[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>o_O</span> {
    (
        $(
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>; [ $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ]
        );<span class='op'>*</span>
    ) <span class='op'>=&gt;</span> {
        <span class='kw-2'>&amp;</span>[ $($( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span> <span class='op'>+</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span> ),<span class='op'>*</span>),<span class='op'>*</span> ]
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>]
        <span class='op'>=</span> <span class='macro'>o_O</span><span class='macro'>!</span>(<span class='number'>10</span>; [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
               <span class='number'>20</span>; [<span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, [<span class='number'>11</span>, <span class='number'>12</span>, <span class='number'>13</span>, <span class='number'>24</span>, <span class='number'>25</span>, <span class='number'>26</span>]);
}</pre>

<p>Esa es la mayor parte de la sintaxis de los matcher. Todos los ejemplos utilizan
<code>$(...)*</code>, que coincide con &quot;cero o más&quot; elementos sintácticos.
Alternativamente, puedes escribir <code>$(...)+</code> que coincide con &quot;uno o
más&quot;.  Ambas formas incluyen, opcionalmente, un separador, que puede ser
cualquier token excepto <code>+</code> o <code>*</code>.</p>

<p>Este sistema se basa en
&quot;<a href="http://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>&quot;
(PDF).</p>

<h1 id='higiene' class='section-header'><a href='#higiene'>Higiene</a></h1>
<p>Algunos lenguajes implementan macros con sustitución de texto simple, lo que
trae como consecuencia diversos problemas. Por ejemplo, este programa C imprime <code>13</code> en
lugar de la esperada <code>25</code>.</p>

<pre><code class="language-text">#define CINCO_VECES(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, CINCO_VECES(2 + 3));
    return 0;
}
</code></pre>

<p>Después de la expansión tenemos <code>5 * 2 + 3</code>, en donde la multiplicación tiene mayor
precedencia que la suma. Si has utilizado muchos macros en C, probablemente
conoces los idiomas estándar para evitar este problema, así como cinco o seis
otros. En Rust, no nos preocupamos por ello.</p>
<span class='rusttest'>macro_rules! cinco_veces {
    ($x:expr) =&gt; (5 * $x);
}

fn main() {
    assert_eq!(25, cinco_veces!(2 + 3));
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>cinco_veces</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='number'>5</span> <span class='op'>*</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>25</span>, <span class='macro'>cinco_veces</span><span class='macro'>!</span>(<span class='number'>2</span> <span class='op'>+</span> <span class='number'>3</span>));
}</pre>

<p>La metavariable <code>$x</code> se analiza como un nodo de expresión individual, y
mantiene su lugar en el árbol de sintaxis, incluso después de la sustitución.</p>

<p>Otro problema común en los sistemas de macro es la &quot;captura de variable&quot;. Aquí hay
una macro C, utilizando <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">una extensión de GNU C</a> para emular bloques de
expresión de Rust.</p>

<pre><code class="language-text">#define LOG(msj) ({ \
    int estado = obtener_estado_log(); \
    if (estado &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, estado, msj); \
    } \
})
</code></pre>

<p>He aquí un caso de uso que va terriblemente mal:</p>

<pre><code class="language-text">const char *estado = &quot;estrías reticuladas&quot;;
LOG(estado)
</code></pre>

<p>Lo anterior se expande a</p>

<pre><code class="language-text">const char *estado = &quot;estrías reticuladas&quot;;
int estado = obtener_estado_log();
if (estado &gt; 0) {
    printf(&quot;log(%d): %s\n&quot;, estado, estado);
}
</code></pre>

<p>La segunda variable llamada <code>estado</code> sobreescribe a la primera.
Esto es un problema porque la expresión de impresión (<code>printf</code>)
debe hacer referencia a ambas.</p>

<p>La macro Rust equivalente tiene el comportamiento deseado.</p>
<span class='rusttest'>fn obtener_estado_log() -&gt; i32 { 3 }
macro_rules! log {
    ($msj:expr) =&gt; {{
        let estado: i32 = obtener_estado_log();
        if estado &gt; 0 {
            println!(&quot;log({}): {}&quot;, estado, $msj);
        }
    }};
}

fn main() {
    let estado: &amp;str = &quot;estrías reticuladas&quot;;
    log!(estado);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>log</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msj</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {{
        <span class='kw'>let</span> <span class='ident'>estado</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>obtener_estado_log</span>();
        <span class='kw'>if</span> <span class='ident'>estado</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;log({}): {}&quot;</span>, <span class='ident'>estado</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msj</span>);
        }
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>estado</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='string'>&quot;estrías reticuladas&quot;</span>;
    <span class='macro'>log</span><span class='macro'>!</span>(<span class='ident'>estado</span>);
}</pre>

<p>Esta versión funciona porque Rust tiene un <a href="http://en.wikipedia.org/wiki/Hygienic_macro">sistema de macros
higiénico</a>. Cada expansión de macro ocurre en un &quot;contexto de
sintaxis&quot; distinto, y cada variable está asociada con el
contexto de sintaxis donde fue introducida. Es como si la
variable <code>estado</code> dentro <code>main</code> está pintado de un &quot;color&quot;
diferente de la variable <code>estado</code> dentro de la macro, y por lo
tanto no entran en conflicto.</p>

<p>El sistema de macros de Rust también restringe la capacidad de las macros para introducir nuevos enlaces en
el sitio de invocación. Código como el siguiente no funcionará:</p>
<span class='rusttest'>macro_rules! foo {
    () =&gt; (let x = 3);
}

fn main() {
    foo!();
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<p>En lugar de eso necesitas pasar el nombre de la variable en la invocación, de manera que sea estiquetado
con el contexto de sintaxis correcto.</p>
<span class='rusttest'>macro_rules! foo {
    ($v:ident) =&gt; (let $v = 3);
}

fn main() {
    foo!(x);
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span>:<span class='ident'>ident</span>) <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span> <span class='op'>=</span> <span class='number'>3</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>x</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<p>Lo anterior es válido para enlaces <code>let</code> y etiquetas de bucle, pero no para <a href="../reference.html#items">items</a>. Así que el siguiente código compila:</p>
<span class='rusttest'>macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>fn</span> <span class='ident'>x</span>() { });
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='ident'>x</span>();
}</pre>

<h1 id='macros-recursivas' class='section-header'><a href='#macros-recursivas'>Macros recursivas</a></h1>
<p>La expansión de una macro puede incluir más invocaciones a macro, incluyendo
invocaciones de la misma macro que esta siendo expandida. Estas macros recursivas son
útiles para el procesamiento de entrada con estructura de árbol, como se
ilustra en esta (simplista) taquigrafía HTML:</p>
<span class='rusttest'>#![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, &quot;{}&quot;, $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, &quot;&lt;{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, &quot;&lt;/{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
  // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&amp;mut out,
        html[
            head[title[&quot;Macros guide&quot;]]
            body[h1[&quot;Macros are the best!&quot;]]
        ]);

    assert_eq!(out,
        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>write_html</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, ) <span class='op'>=&gt;</span> (());

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>tt</span>) <span class='op'>=&gt;</span> (<span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;{}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>:<span class='ident'>ident</span> [ $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>:<span class='ident'>tt</span>)<span class='op'>*</span> ] $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {{
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>)<span class='op'>*</span>);
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;/{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>)<span class='op'>*</span>);
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Write</span>;
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>out</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>out</span>,
        <span class='ident'>html</span>[
            <span class='ident'>head</span>[<span class='ident'>title</span>[<span class='string'>&quot;Macros guide&quot;</span>]]
            <span class='ident'>body</span>[<span class='ident'>h1</span>[<span class='string'>&quot;Macros are the best!&quot;</span>]]
        ]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>out</span>,
        <span class='string'>&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);
}</pre>

<h1 id='depurando-código-de-macro' class='section-header'><a href='#depurando-código-de-macro'>Depurando código de macro</a></h1>
<p>Para ver los resultados de las macros en expansión, ejecuta
<code>rustc --pretty expanded</code>. La salida representa todo un crate, por lo que también
puede alimentar de nuevo a <code>rustc</code>, que a su vez producirá mejores mensajes de
error que la compilación inicial. Es importante destacar que la salida de <code>--pretty expanded</code> puede tener un significado diferente si varias variables del mismo
nombre (pero diferentes contextos sintácticos) están en juego en el mismo
ámbito. En este caso <code>--pretty expanded,hygiene</code> te dirá acerca de los
contextos de sintaxis.</p>

<p><code>rustc</code> ofrece dos extensiones de sintaxis que ayudan con la depuración de
macros. Por ahora, son inestables y requieren puertas de características (feature gates).</p>

<ul>
<li><p><code>log_syntax!(...)</code> imprimirá sus argumentos en la salida estándar, en tiempo
de compilación, y se &quot;expandirá&quot; a nada.</p></li>
<li><p><code>trace_macros!(true)</code> habilitara un mensaje compilador cada vez que una macro es
expandida. Use <code>trace_macros!(false)</code> adelante en la expansión para apagarlo.</p></li>
</ul>

<h1 id='mas-información' class='section-header'><a href='#mas-información'>Mas información</a></h1>
<p>El <a href="advanced-macros.html">capitulo avanzado de macros</a> entra en mas detalles acerca de la sintaxis de macros.
También describe como compartir macros entre diferentes crates y módulos.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>La propia definición de <code>vec!</code> en libcollections difiere de la
       presentada aquí, por razones de eficiencia y reutilización. Algunas
       de ellas son mencionadas en el <a href="advanced-macros.html">capitulo avanzado de macros</a>.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
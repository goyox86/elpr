<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Iteradores</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Monticulo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilacion Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentacion</a>
</li>
<li><a class='active' href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribucion</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> Ciclos for</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> Ciclos while</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> Referencias y Prestamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Sintaxis de Metodos</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Genericos</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Rasgos</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Objetos de Razgo</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Sintaxis de Llamada a Funciones Universal</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates y Modulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Conversion entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Tipos sin Tamano</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador Inline</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Argumentos de Enlace</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Inverstigacion Academica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Iteradores</h1>
    <p>Hablemos de ciclos.</p>

<p>Recuerdas el ciclo <code>for</code> de Rust? He aqui un ejemplo:</p>
<span class='rusttest'>fn main() {
    for x in 0..10 {
        println!(&quot;{}&quot;, x);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>Ahora que sabes mas Rust, podemos hablar en detalle acerca de como este código funciona. Los rangos (el <code>0..10</code>) son iteradores. Un iterador es algo en lo que podemos llamar el método <code>.next()</code> repetitivamente, y el iterador nos proporciona una secuencia de elementos.</p>

<p>Por ejemplo:</p>
<span class='rusttest'>fn main() {
    let mut rango = 0..10;
    
    loop {
        match rango.next() {
            Some(x) =&gt; {
                println!(&quot;{}&quot;, x);
            },
            None =&gt; { break }
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rango</span> <span class='op'>=</span> <span class='number'>0</span>..<span class='number'>10</span>;

<span class='kw'>loop</span> {
    <span class='kw'>match</span> <span class='ident'>rango</span>.<span class='ident'>next</span>() {
        <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
        },
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { <span class='kw'>break</span> }
    }
}
</pre>

<p>Creamos un enlace (una variable) a el rango, nuestro iterador. Luego iteramos mediante el ciclo <code>loop</code>, con un <code>match</code> interno. Dicho <code>match</code> usa el resultado de <code>rango.next()</code>, que nos proporciona una referencia a el siguiente valor en el iterador. <code>next</code> retorna un <code>Option&lt;i32&gt;</code>, en este caso, que será <code>Some(i32)</code> cuando tenemos un valor y <code>None</code> cuando nos quedemos sin valores. Si obtenemos <code>Some(i32)</code>, lo imprimimos, y si obtenemos <code>None</code>, rompemos el ciclo, saliendo de el a través de <code>break</code>.</p>

<p>Este ejemplo de código es básicamente el mismo que nuestra version de un ciclo for <code>for</code>. El ciclo  <code>for</code> es solo una forma practica de escribir una construcción <code>loop</code>/<code>match</code>/<code>break</code>.</p>

<p>Sin embargo, los ciclos <code>for</code> no son la única cosa que usa iteradores. Escribir tu propio iterador implica implementar el trait <code>Iterator</code>. Si bien hacerlo esta fuera del ámbito de esta guía, Rust provee a un numero de iteradores útiles para llevar a cabo diversas tareas. Antes de hablar de eso, debemos hablar acerca de un anti-patron. Dicho anti-patron es usar rangos de la manera expuesta anteriormente.</p>

<p>Si, acabamos de hablar acerca de cuan cool son los rangos. Pero son también muy primitivos. Por ejemplo, si necesitamos iterar a través del contenido de un vector, podríamos estar tentados a escribir algo como esto:</p>
<span class='rusttest'>fn main() {
    let nums = vec![1, 2, 3];
    
    for i in 0..nums.len() {
        println!(&quot;{}&quot;, nums[i]);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nums</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='ident'>nums</span>.<span class='ident'>len</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>nums</span>[<span class='ident'>i</span>]);
}
</pre>

<p>Esto no es estrictamente peor que usar un iterador. Se puede iterar en vectores directamente, escribe esto:</p>
<span class='rusttest'>fn main() {
    let nums = vec![1, 2, 3];
    
    for num in &amp;nums {
        println!(&quot;{}&quot;, num);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nums</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>for</span> <span class='ident'>num</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>nums</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>num</span>);
}
</pre>

<p>Hay dos razones para hacerlo de esta manera. Primero, expresa lo que queremos de manera mas directa. Iteramos a través del vector completo, en vez de iterar a través de indices para luego indexar el vector. Segundo, esta version es mas eficiente: en la primera version tendremos chequeos de limites extra debido a que usa indexado, <code>nums[i]</code>. En el segundo ejemplo y debido a que con el iterador cedemos una referencia a cada elemento a la vez, ho hay chequeo de limites. Esto es muy común en iteradores: podemos ignorar chequeos de limites innecesarios, sabiendo al mismo tiempo que estamos seguros.</p>

<p>Hay otro detalle aquí que no esta el 100% claro debido a el funcionamiento <code>println!</code>. <code>num</code> es de tipo <code>&amp;i32</code>. Una referencia a un <code>i32</code>, no un <code>i32</code>.  <code>println!</code> maneja el dereferenciamiento por nosotros, es por ello que no lo vemos. Este código también es correcto:</p>
<span class='rusttest'>fn main() {
    let nums = vec![1, 2, 3];
    
    for num in &amp;nums {
        println!(&quot;{}&quot;, *num);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nums</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>for</span> <span class='ident'>num</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>nums</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='ident'>num</span>);
}
</pre>

<p>Ahora estamos dereferenciando a <code>num</code> de forma explicita. Porque <code>&amp;nums</code> nos da referencias? Primeramente, porque lo solicitamos de manera explicita con <code>&amp;</code>. Segundo, si nos diera la data en si misma, tendríamos que ser dueños de ella, lo cual implicaría la creación de una copia de la data para después darnos esa copia. Con referencias, solo estamos haciendo un préstamo (&#39;borrowing&#39;) de una referencia a la data, y por ello solo pasamos una referencia, sin necesidad de transferir la pertenencia.</p>

<p>Entonces, ahora que hemos establecido que los rangos a veces no son lo que queremos, hablemos de lo queremos.</p>

<p>Hay tres amplias clases de cosas que son relevantes: iteradores, <em>adaptadores de iteradores</em> y <em>consumidores</em>. He aquí algunas definiciones:</p>

<ul>
<li><em>iteradores</em> proporcionan una sequencia de valores.</li>
<li><em>adaptadores de iteradores</em> operan en un iterador, produciendo un nuevo iterador con una secuencia diferente de salida.</li>
<li><em>consumidores</em> operan en un iterador, produciendo un conjunto final de valores.</li>
</ul>

<p>Hablemos primeramente acerca de los consumidores, debido a que ya hemos visto un iterador, los rangos.</p>

<h2 id="consumidores" class='section-header'><a
                           href="#consumidores">Consumidores</a></h2>
<p>Un <em>consumidor</em> opera en un iterador, retornando algún tipo de valor o valores. El consumidor mas común es <code>collect()</code>. Este código no compila, pero muestra la intención:</p>
<span class='rusttest'>fn main() {
    let uno_hasta_cien = (1..101).collect();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>uno_hasta_cien</span> <span class='op'>=</span> (<span class='number'>1</span>..<span class='number'>101</span>).<span class='ident'>collect</span>();
</pre>

<p>Como puedes ver, llamamos <code>collect()</code> en el iterador. <code>collect()</code> toma tantos valores como el iterador le proporcione, retornando una colección de resultados. Entonces, porque este código no compilara? Rust no puede determinar que tipo de cosas quieres recolectar, y es por ello necesitas hacerle saber. Esta es la version que compila:</p>
<span class='rusttest'>fn main() {
    let uno_hasta_cien = (1..101).collect::&lt;Vec&lt;i32&gt;&gt;();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>uno_hasta_cien</span> <span class='op'>=</span> (<span class='number'>1</span>..<span class='number'>101</span>).<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;&gt;</span>();
</pre>

<p>Si recuerdas, la sintaxis <code>::&lt;&gt;</code> te permite dar una indicio acerca del tipo, en nuestro caso estamos diciendo que queremos un vector de enteros. No siempre es necesario usar el tipo completo. <code>_</code> te permitirá dar un indicio parcial acerca del tipo:</p>
<span class='rusttest'>fn main() {
    let uno_hasta_cien = (1..101).collect::&lt;Vec&lt;_&gt;&gt;();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>uno_hasta_cien</span> <span class='op'>=</span> (<span class='number'>1</span>..<span class='number'>101</span>).<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>();
</pre>

<p>Esto dice &quot;Recolecta en un<code>Vec&lt;T&gt;</code>, por favor, pero infiere que es <code>T</code> por mi.&quot;. <code>_</code> es por esta razón llamado algunas veces &quot;marcador de posición de tipo&quot;.</p>

<p><code>collect()</code> es el consumidor mas común, pero hay otros. <code>find()</code> es uno de ellos:</p>
<span class='rusttest'>fn main() {
    let mayores_a_cuarenta_y_dos = (0..100)
                                   .find(|x| *x &gt; 42);
    
    match mayores_a_cuarenta_y_dos {
        Some(_) =&gt; println!(&quot;Tenemos algunos números!&quot;),
        None =&gt; println!(&quot;No se encontraron números :(&quot;),
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>mayores_a_cuarenta_y_dos</span> <span class='op'>=</span> (<span class='number'>0</span>..<span class='number'>100</span>)
                               .<span class='ident'>find</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>x</span> <span class='op'>&gt;</span> <span class='number'>42</span>);

<span class='kw'>match</span> <span class='ident'>mayores_a_cuarenta_y_dos</span> {
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Tenemos algunos números!&quot;</span>),
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;No se encontraron números :(&quot;</span>),
}
</pre>

<p><code>find</code> recibe un closure, y trabaja en una referencia a cada elemento de un iterador. Dicho closure retorna <code>true</code> si el elemento es el que estamos buscando y <code>false</code> de lo contrario. Debido a que podríamos no encontrar un elemento que satisfaga nuestro criterio, <code>find</code> retorna un <code>Option</code> en lugar de un elemento.</p>

<p>Otro consumidor importante es <code>fold</code>. Luce asi:</p>
<span class='rusttest'>fn main() {
    let suma = (1..4).fold(0, |suma, x| suma + x);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>suma</span> <span class='op'>=</span> (<span class='number'>1</span>..<span class='number'>4</span>).<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>suma</span>, <span class='ident'>x</span><span class='op'>|</span> <span class='ident'>suma</span> <span class='op'>+</span> <span class='ident'>x</span>);
</pre>

<p><code>fold(base, |acumulador, elemento| ...)</code>. Toma dos argumentos: el primero es un elemento llamado <em>base</em>. El segundo es un closure que a su vez toma dos argumentos: el primero es llamado el <em>acumulador</em>, y el segundo es un <em>elemento</em>. En cada iteración, el closure es llamado, y el resultado es usado como el valor del acumulador en la siguiente iteración. En la primera iteración, la base es el valor del acumulador.</p>

<p>Bien, eso es un poco confuso. Examinemos los valores de todas las cosas en este iterador:</p>

<table><thead>
<tr>
<th>base</th>
<th>acumulador</th>
<th>elemento</th>
<th>resultado del closure</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td>3</td>
<td>6</td>
</tr>
</tbody></table>

<p>Hemos llamado a <code>fold()</code> con estos argumentos:</p>
<span class='rusttest'>fn main() {
    (1..4)
    .fold(0, |suma, x| suma + x);
    
}</span><pre class='rust rust-example-rendered'>
.<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>suma</span>, <span class='ident'>x</span><span class='op'>|</span> <span class='ident'>suma</span> <span class='op'>+</span> <span class='ident'>x</span>);
</pre>

<p>Entonces, <code>0</code> es nuestra base, <code>suma</code> es nuestro acumulador, y <code>x</code> es nuestro elemento. En la primera iteración, asignamos <code>sum</code> a <code>0</code> y <code>x</code> es el primer elemento de nuestro rango, <code>1</code>. Después sumamos <code>sum</code> y <code>x</code> lo que nos da <code>0 + 1 = 1</code>. En la segunda iteración, ese valor se convierte en el valor de nuestro acumulador, <code>sum</code>, y el elemento es el segundo elemento del rango, <code>2</code>. <code>1 + 2 = 3</code> y de igual manera se convierte en el valor del acumulador para la ultima iteración. En esa iteración, <code>x</code> es el ultimo elemento, <code>3</code>, y <code>3 + 3 = 6</code>, resultado final para nuestro <code>suma</code>. <code>1 + 2 + 3 = 6</code>, ese es el resultado que obtenemos.</p>

<p>Whew. <code>fold</code> puede ser un poco extraño a primera vista, pero una vez hace click, puedes usarlo en todos lados. Cada vez que tengas una lista de cosas, y necesites un único resultado, <code>fold</code> es apropiado.</p>

<p>Los consumidores son importantes debido a una propiedad adicional de los iteradores de la que no hemos hablado todavia: pereza (laziness). Hablemos mas acerca de los iteradores y veras porque los consumidores son importantes.</p>

<h2 id="iteradores" class='section-header'><a
                           href="#iteradores">Iteradores</a></h2>
<p>Como hemos dicho antes, un iterador es algo en lo que podemos llamar el método <code>.next()</code> repetidamente, y este nos devuelve una secuencia de elementos. Debido a que necesitamos llamar a el método, los iteradores pueden ser <em>perezosos</em> y no generar todos los valores por adelantado. Este código, por ejemplo, no genera los números <code>1-99</code>. En su lugar crea un valor que representa la secuencia:</p>
<span class='rusttest'>fn main() {
    let nums = 1..100;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nums</span> <span class='op'>=</span> <span class='number'>1</span>..<span class='number'>100</span>;
</pre>

<p>Debido a que no hicimos nada con el rango, este no genero la secuencia. Agreguemos un consumidor:</p>
<span class='rusttest'>fn main() {
    let nums = (1..100).collect::&lt;Vec&lt;i32&gt;&gt;();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nums</span> <span class='op'>=</span> (<span class='number'>1</span>..<span class='number'>100</span>).<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;&gt;</span>();
</pre>

<p>Ahora <code>collect()</code> requerirá que el rango provea algunos números, y en consecuencia tendra que llevar a cabo la labor de generar la secuencia.</p>

<p>Los rangos son una de las dos formas básicas de iteradores que veras. La otra es <code>iter()</code>. <code>iter()</code> puede transformar un vector en un iterador simple que proporciona un elemento a la vez:</p>
<span class='rusttest'>fn main() {
    let nums = vec![1, 2, 3];
    
    for num in nums.iter() {
       println!(&quot;{}&quot;, num);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nums</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>for</span> <span class='ident'>num</span> <span class='kw'>in</span> <span class='ident'>nums</span>.<span class='ident'>iter</span>() {
   <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>num</span>);
}
</pre>

<p>Estos dos iteradores básicos deberian ser de utilidad. Existen iteradores mas avanzados, incluyendo aquellos que son infinitos.</p>

<p>Suficiente acerca de iteradores, los adaptadores de iteradores son el ultimo concepto relacionado a iteradores al que debemos hacer mención. Hagamoslo!</p>

<h2 id="adaptadores-de-iterador" class='section-header'><a
                           href="#adaptadores-de-iterador">Adaptadores de iterador</a></h2>
<p>Los <em>adaptadores de iteradores</em> toman un iterador y lo modifican de alguna manera, produciendo uno nuevo. El mas simple es llamado <code>map</code>:</p>
<span class='rusttest'>fn main() {
    (1..100).map(|x| x + 1);
    
}</span><pre class='rust rust-example-rendered'>
(<span class='number'>1</span>..<span class='number'>100</span>).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>);
</pre>

<p><code>map</code> es llamado en otro iterador, <code>map</code> produce un iterador nuevo en el que cada referencia a un elemento posee el closure que se ha proporcionado como argumento. El código anterior nos dará los números <code>2-100</code>, Bueno, casi! Si compilas el ejemplo, obtendrás una advertencia:</p>

<pre><code class="language-text">warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>

<p>La pereza ataca de nuevo! Ese closure nunca se ejecutara. Este ejemplo no imprime ningún numero:</p>
<span class='rusttest'>fn main() {
    (1..100).map(|x| println!(&quot;{}&quot;, x));
    
}</span><pre class='rust rust-example-rendered'>
(<span class='number'>1</span>..<span class='number'>100</span>).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>));
</pre>

<p>Si estas intentanto ejecutar un closure en un iterador para obtener sus efectos colaterales (side-effects) usa un <code>for</code>.</p>
<span class='rusttest'>fn main() {
    for i in (1..).take(5) {
        println!(&quot;{}&quot;, i);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> (<span class='number'>1</span>..).<span class='ident'>take</span>(<span class='number'>5</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>i</span>);
}
</pre>

<p>Esto imprimira:</p>

<pre><code class="language-text">1
2
3
4
5
</code></pre>

<p><code>filter()</code> es un adaptador que toma un closure como argumento. Dicho closure retorna <code>true</code> o <code>false</code>. El nuevo iterador que <code>filter()</code> produce solo elementos para los que el closure retorna <code>true</code>:</p>
<span class='rusttest'>fn main() {
    for i in (1..100).filter(|&amp;x| x % 2 == 0) {
        println!(&quot;{}&quot;, i);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> (<span class='number'>1</span>..<span class='number'>100</span>).<span class='ident'>filter</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>2</span> <span class='op'>==</span> <span class='number'>0</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>i</span>);
}
</pre>

<p>Esto imprimirá todos los números pares entre uno y cien. (Nota que debido a que <code>filter</code> no consume los elementos que están siendo iterados, a este se le pasa una referencia a cada elemento, debido a ello, el predicado usa el patron <code>&amp;x</code> para extraer el entero.)</p>
<span class='rusttest'>fn main() {
    (1..)
        .filter(|&amp;x| x % 2 == 0)
        .filter(|&amp;x| x % 3 == 0)
        .take(5)
        .collect::&lt;Vec&lt;i32&gt;&gt;();
    
}</span><pre class='rust rust-example-rendered'>
(<span class='number'>1</span>..)
    .<span class='ident'>filter</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>2</span> <span class='op'>==</span> <span class='number'>0</span>)
    .<span class='ident'>filter</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>3</span> <span class='op'>==</span> <span class='number'>0</span>)
    .<span class='ident'>take</span>(<span class='number'>5</span>)
    .<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;&gt;</span>();
</pre>

<p>Lo anterior te  un vector conteniendo <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code>, y <code>30</code>.</p>

<p>Esta es una pequeña muestra de las cosas en las cuales los iteradores, adaptadores de iteradores, y consumidores pueden ayudarte. Existe una variedad de iteradores realmente útiles, junto al hecho que puedes escribir tus propios. Los iteradores proporcionan una manera segura y eficiente de manipular todo tipo de listas. Son un poco inusuales a primera vista, pero si juegas un poco con ellos, quedaras enganchado. Para una lista de los diferentes iteradores y consumidores echa un vistazo a la <a href="../std/iter/index.html">documentacion del modulo iterator</a> (ingles).</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
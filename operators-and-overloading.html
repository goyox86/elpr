<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Operadores y Sobrecarga</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a class='active' href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patrones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Asignadores de Memoria Personalizados</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='bibliography.html'><b>8.</b> Bibliografia</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Operadores y Sobrecarga</h1>
    <p>Rust permite una forma limitada de sobrecarga de operadores. Existen ciertos operadores que pueden ser sobrecargados. Para soportar un operador particular entre tipos, hay un trait en especifico que puedes implementar, el cual sobrecarga el operador.</p>

<p>Por ejemplo, el operador <code>+</code> puede ser sobrecargado con el trait <code>Add</code>:</p>
<span class='rusttest'>use std::ops::Add;

#[derive(Debug)]
struct Punto {
    x: i32,
    y: i32,
}

impl Add for Punto {
    type Output = Punto;

    fn add(self, otro: Punto) -&gt; Punto {
        Punto { x: self.x + otro.x, y: self.y + otro.y }
    }
}

fn main() {
    let p1 = Punto { x: 1, y: 0 };
    let p2 = Punto { x: 2, y: 3 };

    let p3 = p1 + p2;

    println!(&quot;{:?}&quot;, p3);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Add</span>;

<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Punto</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>impl</span> <span class='ident'>Add</span> <span class='kw'>for</span> <span class='ident'>Punto</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>Punto</span>;

    <span class='kw'>fn</span> <span class='ident'>add</span>(<span class='self'>self</span>, <span class='ident'>otro</span>: <span class='ident'>Punto</span>) <span class='op'>-&gt;</span> <span class='ident'>Punto</span> {
        <span class='ident'>Punto</span> { <span class='ident'>x</span>: <span class='self'>self</span>.<span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>otro</span>.<span class='ident'>x</span>, <span class='ident'>y</span>: <span class='self'>self</span>.<span class='ident'>y</span> <span class='op'>+</span> <span class='ident'>otro</span>.<span class='ident'>y</span> }
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>p1</span> <span class='op'>=</span> <span class='ident'>Punto</span> { <span class='ident'>x</span>: <span class='number'>1</span>, <span class='ident'>y</span>: <span class='number'>0</span> };
    <span class='kw'>let</span> <span class='ident'>p2</span> <span class='op'>=</span> <span class='ident'>Punto</span> { <span class='ident'>x</span>: <span class='number'>2</span>, <span class='ident'>y</span>: <span class='number'>3</span> };

    <span class='kw'>let</span> <span class='ident'>p3</span> <span class='op'>=</span> <span class='ident'>p1</span> <span class='op'>+</span> <span class='ident'>p2</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>p3</span>);
}</pre>

<p>En <code>main</code>, podemos hacer uso de <code>+</code> en nuestros dos <code>Puntos</code>s, puesto que hemos implementado <code>Add&lt;Output=Punto&gt;</code> para <code>Punto</code>.</p>

<p>Existe un numero de operadores que pueden ser sobrecargados de esta manera, y todos sus traits asociados viven en el modulo <a href="../std/ops/index.html"><code>std::ops</code></a>. Echa un vistazo a la documentación para una lista completa.</p>

<p>Implementar dichos traits sigue un patron. Analicemos a <a href="../std/ops/trait.Add.html"><code>Add</code></a> con mas detalle:</p>
<span class='rusttest'>fn main() {
    mod foo {
    pub trait Add&lt;RHS = Self&gt; {
        type Output;
    
        fn add(self, rhs: RHS) -&gt; Self::Output;
    }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Add</span><span class='op'>&lt;</span><span class='ident'>RHS</span> <span class='op'>=</span> <span class='kw'>Self</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span>;

    <span class='kw'>fn</span> <span class='ident'>add</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>RHS</span>) <span class='op'>-&gt;</span> <span class='ident'>Self</span>::<span class='ident'>Output</span>;
}</pre>

<p>Hay en total tres tipos involucrados aqui: El tipo para el cual estas implementado <code>Add</code>, <code>RHS</code> (de right hand side), que por defecto es <code>Self</code>, y <code>Output</code>. Para una expresion <code>let z = x + y</code>, <code>x</code> es el tipo <code>Self</code>, <code>y</code> es el <code>RHS</code>, y <code>z</code> es el tipo <code>Self::Output</code>.</p>
<span class='rusttest'>fn main() {
    struct Punto;
    use std::ops::Add;
    impl Add&lt;i32&gt; for Punto {
        type Output = f64;
    
        fn add(self, rhs: i32) -&gt; f64 {
            // sumar un i32 a un Punto obteniendo un f64
    1.0
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Add</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Punto</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>f64</span>;

    <span class='kw'>fn</span> <span class='ident'>add</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='comment'>// sumar un i32 a un Punto obteniendo un f64</span>
    }
}</pre>

<p>te permitira hacer lo siguiente:</p>
<span class='rusttest'>fn main() {
    let p: Point = // ...
    let x: f64 = p + 2i32;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>p</span>: <span class='ident'>Point</span> <span class='op'>=</span> <span class='comment'>// ...</span>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='ident'>p</span> <span class='op'>+</span> <span class='number'>2i32</span>;</pre>

<h1 id='usando-los-traits-de-operador-en-estructuras-genericas' class='section-header'><a href='#usando-los-traits-de-operador-en-estructuras-genericas'>Usando los traits de operador en estructuras genericas</a></h1>
<p>Ahora que sabemos como están definidos los traits de operador, podemos definir nuestro trait <code>TieneArea</code> y nuestra estructura <code>Cuadrado</code> del <a href="traits.html">capitulo de traits</a> de una forma mas genérica:</p>
<span class='rusttest'>use std::ops::Mul;

trait TieneArea&lt;T&gt; {
    fn area(&amp;self) -&gt; T;
}

struct Cuadrado&lt;T&gt; {
    x: T,
    y: T,
    lado: T,
}

impl&lt;T&gt; TieneArea&lt;T&gt; for Cuadrado&lt;T&gt;
        where T: Mul&lt;Output=T&gt; + Copy {
    fn area(&amp;self) -&gt; T {
        self.lado * self.lado
    }
}

fn main() {
    let s = Cuadrado {
        x: 0.0f64,
        y: 0.0f64,
        lado: 12.0f64,
    };

    println!(&quot;Area de s: {}&quot;, s.area());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Mul</span>;

<span class='kw'>trait</span> <span class='ident'>TieneArea</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span>;
}

<span class='kw'>struct</span> <span class='ident'>Cuadrado</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='ident'>T</span>,
    <span class='ident'>y</span>: <span class='ident'>T</span>,
    <span class='ident'>lado</span>: <span class='ident'>T</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>TieneArea</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Cuadrado</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>
        <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>Output</span><span class='op'>=</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>+</span> <span class='ident'>Copy</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
        <span class='self'>self</span>.<span class='ident'>lado</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>lado</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>Cuadrado</span> {
        <span class='ident'>x</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>y</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>lado</span>: <span class='number'>12.0f64</span>,
    };

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Area de s: {}&quot;</span>, <span class='ident'>s</span>.<span class='ident'>area</span>());
}</pre>

<p>Para <code>TieneArea</code> y <code>Cuadrado</code>, solo declaramos un parametro de tipo <code>T</code> y reemplazamos el <code>f64</code>. El bloque <code>impl</code> necesita mas modificaciones:</p>
<span class='rusttest'>fn main() {
    impl&lt;T&gt; TieneArea&lt;T&gt; for Cuadrado&lt;T&gt;
            where T: Mul&lt;Output=T&gt; + Copy { ... }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>TieneArea</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Cuadrado</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>
        <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>Output</span><span class='op'>=</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>+</span> <span class='ident'>Copy</span> { ... }</pre>

<p>El método <code>area</code> requiere que podamos multiplicar los lados, es por ello que declaramos que <code>T</code> debe implementar <code>std::ops::Mul</code>. Como <code>Add</code>, mencionado anteriormente, <code>Mul</code> toma un parámetro <code>Output</code>: debido a que sabemos que los números no cambian de tipo cuando son multiplicados, también lo definimos como <code>T</code>. <code>T</code> también debe soportar copiado, de manera que Rust no trate de mover <code>self.lado</code> a el valor de retorno.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Enlaces a Variable</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a class='active' href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patrones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Asignadores de Memoria Personalizados</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='bibliography.html'><b>8.</b> Bibliografia</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Enlaces a Variable</h1>
    <p>Virtualmente cualquier programa no-&#39;Hola Mundo’ usa <em>enlaces a variables</em>. Dichos enlaces a variables lucen así:</p>
<span class='rusttest'>fn main() {
    let x = 5;
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
}</pre>

<p>Colocar <code>fn main() {</code> en cada ejemplo es un poco tedioso, así que en el futuro lo omitiremos. Si estas siguiendo paso a paso, asegurate de editar tu función <code>main()</code>, en lugar de dejarla por fuera. De otro modo obtendrás un error.</p>

<p>En muchos lenguajes, esto es llamado una <em>variable</em>, pero los enlaces a variable de Rust tienen un par de trucos bajo la manga. Por ejemplo el lado izquierdo de una expresión <code>let</code> es un ‘<a href="patterns.html">patron</a>’, no un simple nombre de variable. Esto se traduce en que podemos hacer cosas como:</p>
<span class='rusttest'>fn main() {
    let (x, y) = (1, 2);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>);</pre>

<p>Después de que esta expresión es evaluada, <code>x</code> sera uno, y <code>y</code> sera dos. Los patrones son realmente poderosos, y tienen <a href="patterns.html">su propia sección</a> en el libro. No necesitamos esas facilidades por ahora, solo mantengamos esto en nuestras mentes mientras avanzamos.</p>

<p>Rust es un lenguaje estáticamente tipificado, lo que significa que especificamos nuestros tipos por adelantado, y estos son chequeados en tiempo de compilación. Entonces, porque nuestro primer ejemplo compila? Bueno, Rust tiene esta cosa llamada ‘inferencia de tipos’. Si puede determinar el tipo de algo, Rust no requiere que escribas el tipo.</p>

<p>Podemos agregar el tipo si lo deseamos. Los tipos vienen después de dos puntos (<code>:</code>):</p>
<span class='rusttest'>fn main() {
    let x: i32 = 5;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>5</span>;</pre>

<p>Si te pidiera leer esto en voz alta al resto de la clase, dirías “<code>x</code> es un enlace con el tipo <code>i32</code> y el valor <code>cinco</code>.”</p>

<p>En este caso decidimos representar <code>x</code> como un entero con signo de 32 bits. Rust posee muchos tipos de enteros primitivos diferentes. Estos comienzan con <code>i</code> para los enteros con signo y con <code>u</code> para los enteros sin signo. Los tamaños posibles para enteros son 8, 16, 32, y 64 bits.</p>

<p>En ejemplos futuros, podríamos anotar el tipo en un comentario. El ejemplo luciría así:</p>
<span class='rusttest'>fn main() {
    let x = 5; // x: i32
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// x: i32</span>
}</pre>

<p>Nota las similitudes entre la anotación y la sintaxis que usas con <code>let</code>. Incluir esta clase de comentarios no es idiomático en Rust, pero los incluiremos ocasionalmente para ayudarte a entender cuales son los tipos que Rust infiere.</p>

<p>Por defecto, los enlaces son <em>inmutables</em>. Este código no compilara:</p>
<span class='rusttest'>fn main() {
    let x = 5;
    x = 10;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10</span>;</pre>

<p>Dara como resultado el siguiente error:</p>

<pre><code class="language-text">error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
</code></pre>

<p>Si deseas que un enlace a variable sea mutable, puedes hacer uso de <code>mut</code>:</p>
<span class='rusttest'>fn main() {
    let mut x = 5; // mut x: i32
    x = 10;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// mut x: i32</span>
<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10</span>;</pre>

<p>No hay una razón única por la cual los enlaces a variable son inmutables por defecto, pero podemos pensar acerca de ello a través de uno de los focos principales de Rust: seguridad. Si olvidas decir <code>mut</code>. el compilador lo notará, y te hará saber que has mutado algo que no tenias intención de mutar. Si los enlaces a variables fuesen mutables por defecto, el compilador no seria capaz de decirte esto. Si tenias la intención de mutar algo, entonces la solución es muy fácil: agregar <code>mut</code>.</p>

<p>Hay otras buenas razones para evitar estado mutable siempre que sea posible, pero estan fuera del alcance de esta guisa. En general, puedes frecuentemente evitar mutación explicita, y esto es preferible en Rust. Dicho esto, algunas veces, la mutación es justo lo que necesitas, es por ello que no esta prohibida.</p>

<p>Volvamos a los enlaces a variables. Los enlaces a variable en Rust poseen un aspecto mas que difiere de otros lenguajes: se requiere esten inicializados a un valor antes que puedas usarlos.</p>

<p>Pongamos esto a prueba. Cambia tu archivo <code>src/main.rs</code> para que luzca así: </p>
<span class='rusttest'>fn main() {
    let x: i32;

    println!(&quot;Hola, mundo!&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hola, mundo!&quot;</span>);
}</pre>

<p>Puedes usar <code>cargo build</code> en la linea de comando para compilarlo. Obtendrás una advertencia pero aun así imprimirá &quot;Hola, mundo!&quot;:</p>

<pre><code class="language-text">   Compiling hola_mundo v0.0.1 (file:///home/tu/proyectos/hola_mundo)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
</code></pre>

<p>Rust nos advierte que nunca hacemos uso del enlace a variable, pero debido a que nunca la usamos, no hay peligro, no hay falta. Sin embargo, las cosas cambian si efectivamente intentamos usar <code>x</code>. Hagamos eso. Cambia tu programa para que luzca de la siguiente manera:</p>
<span class='rusttest'>fn main() {
    let x: i32;

    println!(&quot;El valor de x es: {}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;El valor de x es: {}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<p>Intenta compilarlo. Obtendrás un error:</p>

<pre><code class="language-bash">$ cargo build
   Compiling hola_mundo v0.0.1 (file:///home/tu/proyectos/hola_mundo)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!(&quot;El valor de x es: {}&quot;, x);
                                                    ^
note: in expansion of format_args!
&lt;std macros&gt;:2:23: 2:77 note: expansion site
&lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
</code></pre>

<p>Rust no te permitirá usar un valor que no haya sido inicializado previamente. A continuación hablemos de lo que le hemos agregado a <code>println!</code>.</p>

<p>Si incluyes un par de llaves (<code>{}</code>, algunas personas los llaman bigotes/moustaches...) en la cadena de caracteres a imprimir, Rust lo interpretara como una petición para interpolar alguna clase de valor. <em>La interpolación en cadenas de caracteres</em> es un termino en ciencias de la computación que significa &quot;coloca esto dentro de la cadena de caracteres&quot;. Agregamos una coma, y luego <code>x</code>, para indicar que queremos que este sea el valor interpolado. La coma es usada para separar los argumentos que pasamos a las funciones y los macros, en el caso de pasar mas de uno.</p>

<p>Cuando usas las llaves, Rust intentará mostrar el valor de una forma que tenga sentido después de chequear su tipo. Si deseamos especificar un formato mas detallado, existen <a href="../std/fmt/index.html">un amplio numero de opciones disponible</a>. Por ahora, nos apegaremos al comportamiento por defecto: los números enteros no son muy complicados de imprimir.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>
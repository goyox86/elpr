<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Pruebas de rendimiento</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a  href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a class='active' href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patrones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Pruebas de rendimiento</h1>
    <p>Rust soporta benchmarks, los cuales pueden probar el rendimiento de tu código. Pongamos esto en nuestro <code>src/lib.rs</code> (comentarios omitidos):</p>
<span class='rusttest'>#![feature(test)]

fn main() {
    extern crate test;
    
    pub fn suma_dos(a: i32) -&gt; i32 {
        a + 2
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
        use test::Bencher;
    
        #[test]
        fn funciona() {
            assert_eq!(4, suma_dos(2));
        }
    
        #[bench]
        fn bench_suma_dos(b: &amp;mut Bencher) {
            b.iter(|| add_two(2));
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>test</span>)]</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>test</span>;

<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>suma_dos</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>a</span> <span class='op'>+</span> <span class='number'>2</span>
}

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>tests</span> {
    <span class='kw'>use</span> <span class='ident'>super</span>::<span class='op'>*</span>;
    <span class='kw'>use</span> <span class='ident'>test</span>::<span class='ident'>Bencher</span>;

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>funciona</span>() {
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>suma_dos</span>(<span class='number'>2</span>));
    }

    <span class='attribute'>#[<span class='ident'>bench</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>bench_suma_dos</span>(<span class='ident'>b</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Bencher</span>) {
        <span class='ident'>b</span>.<span class='ident'>iter</span>(<span class='op'>||</span> <span class='ident'>add_two</span>(<span class='number'>2</span>));
    }
}</pre>

<p>Nota el feature gate <code>test</code>, que habilita esta facilidad inestable.</p>

<p>Hemos importado el crate <code>test</code>, que contiene nuestro soporte para pruebas de desempeño. Tenemos también una función nueva, con el atributo <code>bench</code>. A diferencia de las pruebas regulares, los cuales no reciben argumentos, las pruebas de rendimiento reciben un un <code>&amp;mut Bencher</code>. Dicho <code>Bencher</code> provee de un método <code>iter</code>, que recibe un closure como argumento. Dicho closure contiene el código al cual queremos medir el desempeño.</p>

<p>Podemos ejecutar los tests con <code>cargo bench</code>:</p>

<pre><code class="language-bash">$ cargo bench
   Compiling sumador v0.0.1 (file:///home/tu/proyectos/sumador)
     Running target/release/sumador-91b3e234d4ed382a

running 2 tests
test tests::funciona ... ignored
test tests::bench_suma_dos ... bench:  1 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured
</code></pre>

<p>Nuestro test regular fue ignorado. Puedes haber notado también que <code>cargo bench</code> se demora un poco mas que <code>cargo test</code>. Esto es debido a que Rust ejecuta las pruebas de rendimiento unas cuantas veces, tomando luego el promedio. Debido a que estamos haciendo tan poco en este ejemplo, tenemos un <code>1 ns/iter (+/- 0)</code>, pero, de existir alguna varianza, hubiera sido mostrada aquí.</p>

<p>Algunos consejos en la escritura de pruebas de rendimiento:</p>

<ul>
<li>Coloca el código de inicialización fuera del loop <code>iter</code>, solo coloca en su interior la parte que deseas medir</li>
<li>Haz que el código &quot;haga lo mismo&quot; en cada iteración; no acumules o cambies estado</li>
<li>Haz la función exterior idempotente también, el ejecutador de pruebas de rendimiento lo correrá potencialmente unas cuantas veces</li>
<li>Haz el ciclo interno <code>iter</code> corto y rápido de manera tal que las pruebas de rendimiento sean rápidas y el calibrador pueda ajustar la duración de ejecución a una buena resolución.</li>
<li>Haz del código en ciclo <code>iter</code> algo simple, para ayudar a la identificación de mejoras de rendimiento (o regresiones)</li>
</ul>

<h2 id='gotcha-optimizaciones' class='section-header'><a href='#gotcha-optimizaciones'>Gotcha: optimizaciones</a></h2>
<p>Hay otra parte difícil acerca de escribir pruebas de rendimiento: los benchmarks compilados con optimizaciones activadas pueden ser cambiados de manera dramática por el optimizador de una manera que la prueba deje de medir lo que esperas. Por ejemplo, el compilador podría reconocer que algún calculo no posea efectos externos removiéndolo por completo.</p>
<span class='rusttest'>#![feature(test)]

fn main() {
    extern crate test;
    use test::Bencher;
    
    #[bench]
    fn bench_xor_1000_enteros(b: &amp;mut Bencher) {
        b.iter(|| {
            (0..1000).fold(0, |viejo, nuevo| viejo ^ nuevo);
        });
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>test</span>)]</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>test</span>;
<span class='kw'>use</span> <span class='ident'>test</span>::<span class='ident'>Bencher</span>;

<span class='attribute'>#[<span class='ident'>bench</span>]</span>
<span class='kw'>fn</span> <span class='ident'>bench_xor_1000_enteros</span>(<span class='ident'>b</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Bencher</span>) {
    <span class='ident'>b</span>.<span class='ident'>iter</span>(<span class='op'>||</span> {
        (<span class='number'>0</span>..<span class='number'>1000</span>).<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>viejo</span>, <span class='ident'>nuevo</span><span class='op'>|</span> <span class='ident'>viejo</span> <span class='op'>^</span> <span class='ident'>nuevo</span>);
    });
}</pre>

<p>produce los siguientes resultados</p>

<pre><code class="language-text">running 1 test
test bench_xor_1000_enteros ... bench: 0 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>

<p>El ejecutador de pruebas de rendimiento ofrece dos formas de evitar lo anterior. Bien sea, el closure que el método <code>iter</code> recibe puede retornar un valor arbitrario que obligue a el optimizador a considerar el resultado usado asegurandose que la computación no sea removida por completo. Esto puede ser logrado para el ejemplo anterior ajustando la llamada a <code>b.iter</code> a:</p>
<span class='rusttest'>fn main() {
    struct X;
    impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
    b.iter(|| {
        // note la omisión de `;` ( pudimos haber usado un también `return` explicito).
        (0..1000).fold(0, |viejo, nuevo| viejo ^ nuevo)
    });
    
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>b</span>.<span class='ident'>iter</span>(<span class='op'>||</span> {
    <span class='comment'>// note la omisión de `;` ( pudimos haber usado un también `return` explicito).</span>
    (<span class='number'>0</span>..<span class='number'>1000</span>).<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>viejo</span>, <span class='ident'>nuevo</span><span class='op'>|</span> <span class='ident'>viejo</span> <span class='op'>^</span> <span class='ident'>nuevo</span>)
});</pre>

<p>La otra opción es llamar a la función genérica <code>test::black_box</code>, que actúa como una &quot;caja negra&quot; opaca para el optimizador obligándolo a considerar cualquier argumento usado.</p>
<span class='rusttest'>#![feature(test)]

extern crate test;

fn main() {
struct X;
impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
b.iter(|| {
    let n = test::black_box(1000);

    (0..n).fold(0, |a, b| a ^ b)
})
}
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>test</span>)]</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>test</span>;

<span class='ident'>b</span>.<span class='ident'>iter</span>(<span class='op'>||</span> {
    <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='ident'>test</span>::<span class='ident'>black_box</span>(<span class='number'>1000</span>);

    (<span class='number'>0</span>..<span class='ident'>n</span>).<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>a</span>, <span class='ident'>b</span><span class='op'>|</span> <span class='ident'>a</span> <span class='op'>^</span> <span class='ident'>b</span>)
})</pre>

<p>Ninguna de las anteriores lee o modifica el valor, y son realmente baratas para valores pequeños, valores mas grandes pueden ser pasados de manera indirecta para reducir el overhead (e.j. <code>black_box(&amp;struct_inmenso)</code>)</p>

<p>Efectuar cualquiera de los cambios anteriores produce los siguientes resultados para las pruebas de rendimiento:</p>

<pre><code class="language-text">running 1 test
test bench_xor_1000_enteros ... bench: 131 ns/iter (+/- 3)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>

<p>Sin embargo, aun cuando se usen cualquiera de las técnicas anteriores el optimizador todavía podría modificar un caso de pruebas de una manera indeseada.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
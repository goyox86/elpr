<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Closures</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Primeros Pasos</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Instalando Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> ¡Hola, mundo!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> ¡Hola, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Aprende Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> El Juego de las Adivinanzas</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> La Cena de los Filósofos</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust dentro de otros Lenguajes</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Rust Efectivo</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> La Pila y el Montículo</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Pruebas</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Compilación Condicional</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentación</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iteradores</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrencia</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Manejo de Errores</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow y AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Canales de Distribución</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Sintaxis y Semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Enlaces a Variables</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Funciones</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Tipos Primitivos</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comentarios</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>5.6.</b> Ciclos</a>
</li>
<li><a  href='ownership.html'><b>5.7.</b> Pertenencia</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.8.</b> Referencias y Préstamo</a>
</li>
<li><a  href='lifetimes.html'><b>5.9.</b> Tiempos de Vida</a>
</li>
<li><a  href='mutability.html'><b>5.10.</b> Mutabilidad</a>
</li>
<li><a  href='structs.html'><b>5.11.</b> Estructuras</a>
</li>
<li><a  href='enums.html'><b>5.12.</b> Enumeraciones</a>
</li>
<li><a  href='match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.14.</b> Patrones</a>
</li>
<li><a  href='method-syntax.html'><b>5.15.</b> Sintaxis de Métodos</a>
</li>
<li><a  href='vectors.html'><b>5.16.</b> Vectores</a>
</li>
<li><a  href='strings.html'><b>5.17.</b> Cadenas de Caracteres</a>
</li>
<li><a  href='generics.html'><b>5.18.</b> Genéricos</a>
</li>
<li><a  href='traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.22.</b> Objetos Trait</a>
</li>
<li><a class='active' href='closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.24.</b> Sintaxis Universal  de Llamada a Funciones</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.25.</b> Crates y Módulos</a>
</li>
<li><a  href='const-and-static.html'><b>5.26.</b> `const` y `static`</a>
</li>
<li><a  href='attributes.html'><b>5.27.</b> Atributos</a>
</li>
<li><a  href='type-aliases.html'><b>5.28.</b> Alias `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>5.29.</b> Conversión entre Tipos</a>
</li>
<li><a  href='associated-types.html'><b>5.30.</b> Tipos Asociados</a>
</li>
<li><a  href='unsized-types.html'><b>5.31.</b> Tipos sin Tamaño</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.32.</b> Operadores y Sobrecarga</a>
</li>
<li><a  href='deref-coercions.html'><b>5.33.</b> Coerciones Deref</a>
</li>
<li><a  href='macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.35.</b> Apuntadores Planos</a>
</li>
<li><a  href='unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust Nocturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugins del Compilador</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Ensamblador en Linea</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrínsecos</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Items de Lenguaje</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Enlace Avanzado</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Pruebas de Rendimiento</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintaxis Box y Patrones</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Patrones Slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Constantes Asociadas</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glosario</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Investigación Académica</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Closures</h1>
    <p>Algunas veces es util envolver una función y sus <em>variables libres</em> para mejor claridad y reusabilidad. Las variables libres que pueden ser usadas provienen del ámbito exterior y son ‘cerradas’ (‘closed over’) cuando son usadas en la función. De allí el nombre ‘closure’. Rust provee una muy buena implementación, como veremos a continuación.</p>

<h1 id='sintaxis' class='section-header'><a href='#sintaxis'>Sintaxis</a></h1>
<p>Los closures lucen así:</p>
<span class='rusttest'>fn main() {
    let suma_uno = |x: i32| x + 1;
    
    assert_eq!(2, suma_uno(1));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>suma_uno</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>2</span>, <span class='ident'>suma_uno</span>(<span class='number'>1</span>));</pre>

<p>Creamos un enlace a variable, <code>suma_uno</code> y lo asignamos a un closure. Los argumentos del closure van entre pipes (<code>|</code>), y el cuerpo es una expresión, en este caso, <code>x + 1</code>. Recuerda que <code>{ }</code> es una expresión, de manera que podemos tener también closures multi-linea:</p>
<span class='rusttest'>fn main() {
    let suma_dos = |x| {
        let mut resultado: i32 = x;
    
        resultado += 1;
        resultado += 1;
    
        resultado
    };
    
    assert_eq!(4, suma_dos(2));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>suma_dos</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>resultado</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>x</span>;

    <span class='ident'>resultado</span> <span class='op'>+=</span> <span class='number'>1</span>;
    <span class='ident'>resultado</span> <span class='op'>+=</span> <span class='number'>1</span>;

    <span class='ident'>resultado</span>
};

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>suma_dos</span>(<span class='number'>2</span>));</pre>

<p>Notaras un par de cosas acerca de los closures que son un poco diferentes de las funciones regulares definidas con <code>fn</code>. Lo primero es que no necesitamos anotar los tipos de los argumentos los valores de retorno. Podemos:</p>
<span class='rusttest'>fn main() {
    let suma_uno = |x: i32| -&gt; i32 { x + 1 };
    
    assert_eq!(2, suma_uno(1));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>suma_uno</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> };

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>2</span>, <span class='ident'>suma_uno</span>(<span class='number'>1</span>));</pre>

<p>Pero no necesitamos hacerlo. Porque? Básicamente, se implemento de esa manera por razones de ergonomia. Si bien especificar el tipo completo para funciones con nombre es de utilidad para cosas como documentación e inferencia de tipos, la firma completa en los closures es raramente documentada puesto a que casi siempre son anónimos, y no causan los problemas de tipo de error-a-distancia que la inferencia en funciones con nombre pueden causar.</p>

<p>La segunda sintaxis es similar, pero un tanto diferente. He agregado espacios acá para facilitar la comparación:</p>
<span class='rusttest'>fn main() {
    fn  suma_uno_v1   (x: i32) -&gt; i32 { x + 1 }
    let suma_uno_v2 = |x: i32| -&gt; i32 { x + 1 };
    let suma_uno_v3 = |x: i32|          x + 1  ;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span>  <span class='ident'>suma_uno_v1</span>   (<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
<span class='kw'>let</span> <span class='ident'>suma_uno_v2</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> };
<span class='kw'>let</span> <span class='ident'>suma_uno_v3</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span>          <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>  ;</pre>

<p>Pequenas diferencias, pero son similares.</p>

<h1 id='closures-y-su-entorno' class='section-header'><a href='#closures-y-su-entorno'>Closures y su entorno</a></h1>
<p>El entorno para un closure puede incluir enlaces a variable del ámbito que los envuelve en adición a los parámetros y variables locales. De esta manera:</p>
<span class='rusttest'>fn main() {
    let num = 5;
    let suma_num = |x: i32| x + num;
    
    assert_eq!(10, suma_num(5));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>suma_num</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>10</span>, <span class='ident'>suma_num</span>(<span class='number'>5</span>));</pre>

<p>El closure <code>suma_num</code>, hace referencia a el enlace <code>let</code> en su ámbito: <code>num</code>. Mas específicamente, toma prestado el enlace. Si hacemos algo que resulte en un conflicto con dicho enlace, obtendríamos un error como este:</p>
<span class='rusttest'>fn main() {
    let mut num = 5;
    let suma_num = |x: i32| x + num;
    
    let y = &amp;mut num;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>suma_num</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>;

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>num</span>;</pre>

<p>Que falla con:</p>

<pre><code class="language-text">error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &amp;mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let suma_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let suma_num = |x| x + num;

    let y = &amp;mut num;
}
^
</code></pre>

<p>Un error un tanto verbose pero igual de util! Como lo dice, no podemos tomar un préstamo mutable en <code>num</code> debido a que el closure ya esta tomándolo prestado. Si dejamos el closure fuera de ámbito, entonces es posible:</p>
<span class='rusttest'>fn main() {
    let mut num = 5;
    {
        let suma_num = |x: i32| x + num;
    
    } // suma_num sale de ambito, el prestamo termina aqui
    
    let y = &amp;mut num;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;
{
    <span class='kw'>let</span> <span class='ident'>suma_num</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>;

} <span class='comment'>// suma_num sale de ambito, el prestamo termina aqui</span>

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>num</span>;</pre>

<p>Sin embargo, si tu closure así lo requiere, Rust tomara pertenecia y moverá el entorno. Lo siguiente no funciona:</p>
<span class='rusttest'>fn main() {
    let nums = vec![1, 2, 3];
    
    let toma_nums = || nums;
    
    println!(&quot;{:?}&quot;, nums);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nums</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>toma_nums</span> <span class='op'>=</span> <span class='op'>||</span> <span class='ident'>nums</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>nums</span>);</pre>

<p>Obtenemos este error:</p>

<pre><code class="language-text">note: `nums` moved into closure environment here because it has type
  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
let toma_nums = || nums;
                 ^~~~~~~
</code></pre>

<p><code>Vec&lt;T&gt;</code> posee pertenecia de su contenido, y es por ello, que al hacer referencia a el dentro de nuestro closure, tenemos que tomar pertenencia de <code>nums</code>. Es lo mismo que si hubiéramos proporcionado <code>nums</code> como argumento a una función que tomara pertenencia sobre el.</p>

<h2 id='closures-move' class='section-header'><a href='#closures-move'>Closures <code>move</code></a></h2>
<p>Podemos forzar nuestro closure a tomar pertenecia de su entorno con la palabra reservada <code>move</code>:</p>
<span class='rusttest'>fn main() {
    let num = 5;
    
    let toma_pertenecia_num = move |x: i32| x + num;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

<span class='kw'>let</span> <span class='ident'>toma_pertenecia_num</span> <span class='op'>=</span> <span class='kw'>move</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>;</pre>

<p>Ahora, aun cuando la palabra reservada <code>move</code> esta presente, las variables siguen la semántica normal. En este caso, <code>5</code> implementa <code>Copy</code>, y en consecuencia, <code>toma_pertenecia_num</code> toma pertenecia de una copia de <code>num</code>. Entonces, cual es la diferencia?</p>
<span class='rusttest'>fn main() {
    let mut num = 5;
    
    {
        let mut suma_num = |x: i32| num += x;
    
        suma_num(5);
    }
    
    assert_eq!(10, num);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

{
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>suma_num</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>num</span> <span class='op'>+=</span> <span class='ident'>x</span>;

    <span class='ident'>suma_num</span>(<span class='number'>5</span>);
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>10</span>, <span class='ident'>num</span>);</pre>

<p>En este caso, nuestro closure tomo una referencia mutable a <code>num</code>, y cuando llamamos a <code>suma_num</code>, este muto el valor subyacente, tal y como lo esperábamos. También necesitamos declarar <code>suma_num</code> como <code>mut</code>, puesto a que estamos mutando su entorno.   </p>

<p>Si lo cambiamos a un closure <code>move</code>, es diferente:</p>
<span class='rusttest'>fn main() {
    let mut num = 5;
    
    {
        let mut suma_num = move |x: i32| num += x;
    
        suma_num(5);
    }
    
    assert_eq!(5, num);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

{
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>suma_num</span> <span class='op'>=</span> <span class='kw'>move</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>num</span> <span class='op'>+=</span> <span class='ident'>x</span>;

    <span class='ident'>suma_num</span>(<span class='number'>5</span>);
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='ident'>num</span>);</pre>

<p>Obtenemos solo <code>5</code>. En lugar de tomar un prestamo mutable en nuestro <code>num</code>, tomamos pertenecia sobre una copia.</p>

<p>Otra forma de pensar acerca de los closures <code>move</code> es: estos proporcionan a el closure su propio registro de activación. Sin <code>move</code>, el closure puede ser asociado a el registro de activación que lo creo, mientras que un closure <code>move</code> es autocontenido. Lo que significa, por ejemplo, que generalmente no puedes retornar un closure no-<code>move</code> desde una función.</p>

<p>Pero antes de hablar de recibir closures como parámetros y usarlos como valores de retorno, debemos hablar un poco mas acerca de su implementación. Como un lenguaje de programación de sistemas Rust te proporciona una tonelada de control acerca de lo que tu código hace, y los closures no son diferentes.</p>

<h1 id='implementación-de-los-closures' class='section-header'><a href='#implementación-de-los-closures'>Implementación de los Closures</a></h1>
<p>La implementación de closures de Rust es un poco diferente a la de otros lenguajes. En Rust, los closures son efectivamente una sintaxis alterna para los traits. Antes de continuar, necesitaras haber leído el <a href="traits.html">capitulo de traits</a> asi como el capitulo acerca de <a href="trait-objects.html">objetos trait</a>.</p>

<p>Ya los has leído? Excelente.</p>

<p>La clave para entender como funcionan los closures es algo un poco extraño: Usar <code>()</code> para llamar una función, como <code>foo()</code>, es un operador sobrecargable. Partiendo desde esta premisa, todo lo demás encaja. En Rust hacemos uso de el sistema de traits para sobrecargar operadores. Llamar funciones no es diferente. Existen tres traits que podemos sobrecargar:</p>
<span class='rusttest'>fn main() {
    mod foo {
    pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
        extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
    }
    
    pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
        extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
    }
    
    pub trait FnOnce&lt;Args&gt; {
        type Output;
    
        extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
    }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Fn</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> : <span class='ident'>FnMut</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> {
    <span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> <span class='kw'>fn</span> <span class='ident'>call</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>args</span>: <span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='ident'>Self</span>::<span class='ident'>Output</span>;
}

<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>FnMut</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> : <span class='ident'>FnOnce</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> {
    <span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> <span class='kw'>fn</span> <span class='ident'>call_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>args</span>: <span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='ident'>Self</span>::<span class='ident'>Output</span>;
}

<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>FnOnce</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span>;

    <span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> <span class='kw'>fn</span> <span class='ident'>call_once</span>(<span class='self'>self</span>, <span class='ident'>args</span>: <span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='ident'>Self</span>::<span class='ident'>Output</span>;
}</pre>

<p>Notaras unas pocas diferencias entre dichos traits, pero una grande es <code>self</code>: <code>Fn</code> recibe <code>&amp;self</code>, <code>FnMut</code> toma <code>&amp;mut self</code> y <code>FnOnce</code> recibe <code>self</code>. Lo anterior cubre los tres tipos de <code>self</code> a través de la sintaxis usual de llamadas a métodos. Pero han sido separados en tres traits, en lugar de uno solo. Esto nos proporciona gran control acerca del tipo de closures que podemos recibir.</p>

<p>La sintaxis <code>|| {}</code> es una sintaxis alterna para esos tres traits. Rust generara un <code>struct</code> para el entorno, <code>impl</code> el trait apropiado, y luego hará uso de este.</p>

<h1 id='recibiendo-closures-como-argumentos' class='section-header'><a href='#recibiendo-closures-como-argumentos'>Recibiendo closures como argumentos</a></h1>
<p>Ahora que sabemos que los closures son traits, entonces sabemos como aceptar y retornar closures: justo como cualquier otro trait!</p>

<p>Lo anterior también significa que podemos elegir entre despacho estático o dinámico. Primero, creemos una función que reciba algo llamable, ejecute una llamada sobre el y luego retorne el resultado:</p>
<span class='rusttest'>fn main() {
    fn llamar_con_uno&lt;F&gt;(algun_closure: F) -&gt; i32
        where F : Fn(i32) -&gt; i32 {
    
        algun_closure(1)
    }
    
    let respuesta = llamar_con_uno(|x| x + 2);
    
    assert_eq!(3, respuesta);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>llamar_con_uno</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>algun_closure</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>
    <span class='kw'>where</span> <span class='ident'>F</span> : <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {

    <span class='ident'>algun_closure</span>(<span class='number'>1</span>)
}

<span class='kw'>let</span> <span class='ident'>respuesta</span> <span class='op'>=</span> <span class='ident'>llamar_con_uno</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>3</span>, <span class='ident'>respuesta</span>);</pre>

<p>Pasamos nuestro closure, <code>|x| x + 2</code>, a <code>llamar_con_uno</code>. <code>llamar_con_uno</code> hace lo que sugiere: llama el closure, proporcionándole <code>1</code> como argumento.</p>

<p>Examinemos la firma de <code>llamar_con_uno</code> con mayor detalle:</p>
<span class='rusttest'>fn main() {
    fn llamar_con_uno&lt;F&gt;(algun_closure: F) -&gt; i32
       where F : Fn(i32) -&gt; i32 {
       algun_closure(1) }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>llamar_con_uno</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>algun_closure</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span></pre>

<p>Recibimos un parámetro, de tipo <code>F</code>. También retornamos un <code>i32</code>. Esta parte no es interesante. La siguiente lo es:</p>
<span class='rusttest'>fn main() {
    fn llamar_con_uno&lt;F&gt;(algun_closure: F) -&gt; i32
        where F : Fn(i32) -&gt; i32 {
      algun_closure(1) }
    
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>where</span> <span class='ident'>F</span> : <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {</pre>

<p>Debido a que <code>Fn</code> es un trait, podemos limitar nuestro genérico con el. En este caso, nuestro closure recibe un <code>i32</code> y retorna un <code>i32</code>, es por ello que el limite de genéricos que usamos es <code>Fn(i32) -&gt; i32</code>.</p>

<p>Hay otro punto clave acá: debido a que estamos limitando un genérico con un trait, la llamada sera monomorfizada, y en consecuencia, estaremos haciendo despacho estático en el closure. Eso es super cool. En muchos lenguajes, los closures son inherentemente asignados desde el montículo, y casi siempre involucraran despacho dinámico. En Rust podemos asignar el entorno de nuestros closures desde la pila, así como despachar la llamada de manera estática. Esto ocurre con bastante frecuencia con los iteradores y sus adaptadores, quienes reciben closures como argumentos.</p>

<p>Por supuesto, si deseamos despacho dinámico, podemos tenerlo también. Un objeto trait, como es usual, maneja este caso:</p>
<span class='rusttest'>fn main() {
    fn llamar_con_uno(algun_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
        algun_closure(1)
    }
    
    let answer = llamar_con_uno(&amp;|x| x + 2);
    
    assert_eq!(3, answer);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>llamar_con_uno</span>(<span class='ident'>algun_closure</span>: <span class='kw-2'>&amp;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>algun_closure</span>(<span class='number'>1</span>)
}

<span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='ident'>llamar_con_uno</span>(<span class='kw-2'>&amp;</span><span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>3</span>, <span class='ident'>answer</span>);</pre>

<p>Ahora recibimos un objeto trait, un <code>&amp;Fn</code>. Y tenemos que hacer una referencia a nuestro closure cuando lo pasemos a <code>llamar_con_uno</code>, es por ello que usamos <code>&amp;||</code>.</p>

<h1 id='apuntadores-a-función-y-closures' class='section-header'><a href='#apuntadores-a-función-y-closures'>Apuntadores a función y closures</a></h1>
<p>Un apuntador a función es una especie de closure que no posee entorno. Como consecuencia, podemos pasar un apuntador a función a cualquier función que reciba un closure como argumento:</p>
<span class='rusttest'>fn main() {
    fn llamar_con_uno(algun_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
        algun_closure(1)
    }
    
    fn suma_uno(i: i32) -&gt; i32 {
        i + 1
    }
    
    let f = suma_uno;
    
    let respuesta = llamar_con_uno(&amp;f);
    
    assert_eq!(2, respuesta);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>llamar_con_uno</span>(<span class='ident'>algun_closure</span>: <span class='kw-2'>&amp;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>algun_closure</span>(<span class='number'>1</span>)
}

<span class='kw'>fn</span> <span class='ident'>suma_uno</span>(<span class='ident'>i</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>i</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>suma_uno</span>;

<span class='kw'>let</span> <span class='ident'>respuesta</span> <span class='op'>=</span> <span class='ident'>llamar_con_uno</span>(<span class='kw-2'>&amp;</span><span class='ident'>f</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>2</span>, <span class='ident'>respuesta</span>);</pre>

<p>En el ejemplo anterior no necesitamos la variable intermedia <code>f</code> de manera estricta, el nombre de la función también sirve:</p>
<span class='rusttest'>fn main() {
    let respuesta = llamar_con_uno(&amp;suma_uno);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>respuesta</span> <span class='op'>=</span> <span class='ident'>llamar_con_uno</span>(<span class='kw-2'>&amp;</span><span class='ident'>suma_uno</span>);</pre>

<h1 id='retornando-closures' class='section-header'><a href='#retornando-closures'>Retornando closures</a></h1>
<p>Es muy común para código con estilo funcional el retornar closures en diversas situaciones. Si intentas retornar un closure, podrías incurrir en un error. Al principio puede parecer extraño, pero mas adelante lo entenderemos. Probablemente intentarías retornar un closure desde una función de esta manera:</p>
<span class='rusttest'>fn main() {
    fn factory() -&gt; (Fn(i32) -&gt; i32) {
        let num = 5;
    
        |x| x + num
    }
    
    let f = factory();
    
    let respuesta = f(1);
    assert_eq!(6, respuesta);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> (<span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>respuesta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>respuesta</span>);</pre>

<p>Lo anterior genera estos largos, pero relacionados errores:</p>

<pre><code class="language-text">error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -&gt; i32` [E0277]
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn(i32) -&gt; i32` [E0277]
let f = factory();
    ^
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
let f = factory();
    ^
</code></pre>

<p>Para retornar algo desde una función, Rust necesita saber el tamaño del tipo de retorno. Pero debido q que <code>Fn</code> es un trait, puede ser varias cosas de diversos tamaños: muchos tipos pueden implementar <code>Fn</code>. Una manera fácil de darle tamaño a algo es tomando una referencia a este, debido a que las referencias tienen un tamaño conocido. En lugar de lo anterior podemos escribir:</p>
<span class='rusttest'>fn main() {
    fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
        let num = 5;
    
        |x| x + num
    }
    
    let f = factory();
    
    let respuesta = f(1);
    assert_eq!(6, respuesta);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span>(<span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>respuesta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>respuesta</span>);</pre>

<p>Pero obtenemos otro error:</p>

<pre><code class="language-text">error: missing lifetime specifier [E0106]
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~~
</code></pre>

<p>Bien. Debido a que tenemos una referencia, necesitamos proporcionar un tiempo de vida. pero nuestra función <code>factory()</code> no recibe ningun argumento y por ello la <a href="lifetimes.html#lifetime-elision">elision</a> de tiempos de vida no es posible en este caso. Entonces que opciones tenemos? Intentemos con <code>&#39;static</code>:</p>
<span class='rusttest'>fn main() {
    fn factory() -&gt; &amp;&#39;static (Fn(i32) -&gt; i32) {
        let num = 5;
    
        |x| x + num
    }
    
    let f = factory();
    
    let respuesta = f(1);
    assert_eq!(6, respuesta);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> (<span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>respuesta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>respuesta</span>);</pre>

<p>Pero obtenemos otro error:</p>

<pre><code class="language-text">error: mismatched types:
 expected `&amp;&#39;static core::ops::Fn(i32) -&gt; i32`,
    found `[closure@&lt;anon&gt;:7:9: 7:20]`
(expected &amp;-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

</code></pre>

<p>El error nos dice que no tenemos un <code>&amp;&#39;static Fn(i32) -&gt; i32</code>, sino un <code>[closure@&lt;anon&gt;:7:9: 7:20]</code>. Un momento, que?</p>

<p>Debido a que nuestro closure genera su propio <code>struct</code> para el entorno así como una implementación para <code>Fn</code>, <code>FnMut</code> y <code>FnOnce</code>, dichos tipos son anónimos. Solo existen para este closure. Es por ello que Rust los muestra como <code>closure@&lt;anon&gt;</code> en vez de algún nombre autogenerado.</p>

<p>El error también habla de que se espera que el tipo de retorno sea una referencia, pero lo que estamos tratando de retornar no lo es. Mas aun, no podemos asignar directamente un tiempo de vida <code>&#39;static&#39;</code> a un objeto. Entonces tomaremos un enfoque diferente y retornaremos un ‘trait object’ envolviendo el <code>Fn</code> en un <code>Box</code>. Lo siguiente <em>casi</em> funciona:</p>
<span class='rusttest'>fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(|x| x + num)
}
fn main() {
let f = factory();

let respuesta = f(1);
assert_eq!(6, respuesta);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>)
}
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>respuesta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>respuesta</span>);</pre>

<p>Hay un ultimo problema:</p>

<pre><code class="language-text">error: closure may outlive the current function, but it borrows `num`,
which is owned by the current function [E0373]
Box::new(|x| x + num)
         ^~~~~~~~~~~
</code></pre>

<p>Bueno, como discutimos anteriormente, los closures toman su entorno prestado. Y en este caso, nuestro entorno esta basado en un <code>5</code> asignado desde la pila, la variable <code>num</code>. Debido a esto el prestamo posee el tiempo de vida del registro de activación. De retornar este closure, la llamada a función podría terminar, el registro de activación desaparecería y nuestro closure estaría capturando un entorno de memoria basura! Con un ultimo arreglo, podemos hacer que funcione:</p>
<span class='rusttest'>fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(move |x| x + num)
}
fn main() {
let f = factory();

let respuesta = f(1);
assert_eq!(6, respuesta);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='kw'>move</span> <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>)
}
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>respuesta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>respuesta</span>);</pre>

<p>Al hacer el closure interno un <code>move Fn</code>, hemos creado un nuevo registro de activación para nuestro closure. Envolviéndolo con un <code>Box</code>, le hemos proporcionado un tamaño conocido, permitiéndole escapar nuestro registro de activación.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>